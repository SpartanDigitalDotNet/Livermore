---
phase: 38-binance-test-harness-handoff
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/test-subscription-harness.ts
  - scripts/test-subscription-harness.ps1
autonomous: true
must_haves:
  truths:
    - "Running the test harness with an exchange name performs a BTC 1d warmup via REST, caching candles in Redis at the correct exchange-scoped key"
    - "The same test harness runs a 2-second WebSocket subscription, receives at least one kline or miniTicker message, and logs parsed output"
    - "The harness exits cleanly with a pass/fail summary and process exit code (0=pass, 1=fail)"
  artifacts:
    - path: "scripts/test-subscription-harness.ts"
      provides: "Subscription test harness script"
      contains: "BinanceRestClient"
    - path: "scripts/test-subscription-harness.ps1"
      provides: "PowerShell wrapper for running harness with env vars"
      contains: "test-subscription-harness.ts"
  key_links:
    - from: "scripts/test-subscription-harness.ts"
      to: "@livermore/binance-client"
      via: "BinanceRestClient.getCandles()"
      pattern: "BinanceRestClient.*getCandles"
    - from: "scripts/test-subscription-harness.ts"
      to: "@livermore/cache"
      via: "CandleCacheStrategy.addCandles() and exchangeCandleKey verification"
      pattern: "exchangeCandleKey|addCandles"
    - from: "scripts/test-subscription-harness.ts"
      to: "ws (WebSocket)"
      via: "Raw WebSocket via 'ws' library for 2s streaming test (not BinanceAdapter)"
      pattern: "WebSocket|subscribe"
---

<objective>
Create a Subscription Test Harness script that validates the complete Binance data pipeline end-to-end: REST candle fetching with Redis caching (TST-01) and WebSocket live streaming (TST-02).

Purpose: This is the validation gate before Kaia handoff -- proves the Binance adapter pipeline works with real exchange data, not just compilation checks.
Output: A reusable test script at `scripts/test-subscription-harness.ts` with a PowerShell wrapper.
</objective>

<execution_context>
@C:/Users/Mike McWilliams/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Mike McWilliams/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context (key artifacts this plan depends on)
@.planning/phases/35-smart-warmup-engine/35-02-SUMMARY.md
@.planning/phases/36-binance-websocket-adapter/36-01-SUMMARY.md
@.planning/phases/36-binance-websocket-adapter/36-02-SUMMARY.md

# Key source files
@packages/binance-client/src/rest/client.ts
@packages/exchange-core/src/adapter/binance-adapter.ts
@packages/cache/src/keys.ts
@scripts/test-v6-redis.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Subscription Test Harness script</name>
  <files>scripts/test-subscription-harness.ts</files>
  <action>
Create a TypeScript script `scripts/test-subscription-harness.ts` that accepts an exchange name argument (default: 'binance_us') and performs two sequential tests:

**Test 1: REST Warmup (TST-01)**
1. Look up the exchange by name from the database (use drizzle + exchanges table, same pattern as `scripts/seed-exchanges.ts`)
2. Create a `BinanceRestClient` with the exchange's `restUrl` from the DB
3. Fetch BTC candles for 1d timeframe using `restClient.getCandles('BTCUSDT', '1d')` -- the Binance symbol format is BTCUSDT (no dash)
4. Create a Redis client using `getRedisClient()` from `@livermore/cache`
5. Create a `CandleCacheStrategy` and write the fetched candles to Redis using `addCandles(1, exchangeId, candles)` -- userId=1 is standard for shared tier
6. Verify the candles were cached by reading back from Redis using the exchange-scoped key: `exchangeCandleKey(exchangeId, 'BTCUSDT', '1d')` and checking `zcard` returns > 0
7. Log: number of candles fetched from REST, number of candles in Redis, newest candle timestamp
8. Mark test as PASS if candles fetched > 0 AND candles in Redis > 0

**Test 2: WebSocket Streaming (TST-02)**
1. Import `WebSocket` from the `ws` library (already a workspace dependency)
2. Connect to Binance WebSocket: `new WebSocket(\`${wsUrl}/ws\`)`
3. On open, send SUBSCRIBE message: `JSON.stringify({ method: 'SUBSCRIBE', params: ['btcusdt@kline_1m'], id: 1 })`
4. On message, parse JSON and check for kline data (event `e` === 'kline', with `k.o`, `k.c`, `k.h`, `k.l`, `k.v` fields)
5. After 2 seconds, close the WebSocket and disconnect
6. Mark test as PASS if at least 1 kline message was received and successfully parsed

**Script structure:**
- Use `process.argv[2]` for exchange name (default 'binance_us')
- Database connection: use same pattern as `scripts/seed-exchanges.ts` (drizzle + Pool from env vars)
- Print a clear pass/fail summary at the end with both test results
- Exit with code 0 if both tests pass, code 1 if any fail
- Handle errors gracefully -- a REST failure should still attempt the WebSocket test
- Import `WebSocket` from 'ws' for the streaming test

**Environment variables used (all standard, already available):**
- DATABASE_HOST, DATABASE_PORT, DATABASE_LIVERMORE_USERNAME, DATABASE_LIVERMORE_PASSWORD, LIVERMORE_DATABASE_NAME (for DB)
- LIVERMORE_REDIS_URL (for Redis via getRedisClient)

**Do NOT:**
- Use the full SmartWarmupService (overkill for a test -- just do a direct REST fetch + cache write)
- Use the full BinanceAdapter for the WebSocket test (too much state -- raw WebSocket is cleaner for a 2s test)
- Hardcode exchange IDs -- always look up by name from the database
  </action>
  <verify>
Run `npx tsc --noEmit scripts/test-subscription-harness.ts` or verify the script compiles by checking for TypeScript errors. The script should not have any import resolution errors against workspace packages.
  </verify>
  <done>
`scripts/test-subscription-harness.ts` exists, compiles without errors, and contains both REST warmup test and WebSocket streaming test logic. The script looks up exchange config from the database, fetches BTC 1d candles via BinanceRestClient, caches them in Redis, and runs a 2-second WebSocket subscription to verify live data flows.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PowerShell wrapper script</name>
  <files>scripts/test-subscription-harness.ps1</files>
  <action>
Create a PowerShell wrapper `scripts/test-subscription-harness.ps1` that:

1. Accepts an optional `-Exchange` parameter (default: 'binance_us')
2. Prints a header banner: "=== Livermore Subscription Test Harness ==="
3. Runs the TypeScript script via `npx tsx scripts/test-subscription-harness.ts $Exchange`
4. Captures the exit code and prints the result

Follow the same pattern as existing PowerShell wrappers (e.g., `scripts/test-rest-candles.ps1`, `scripts/check-redis.ps1`).

This is a simple wrapper -- no complex logic needed. The TypeScript script does all the work.
  </action>
  <verify>
File exists at `scripts/test-subscription-harness.ps1` and contains the PowerShell param block and tsx invocation.
  </verify>
  <done>
PowerShell wrapper script exists and provides a convenient way to run the test harness with `.\scripts\test-subscription-harness.ps1 -Exchange binance_us`.
  </done>
</task>

</tasks>

<verification>
1. `scripts/test-subscription-harness.ts` compiles without TypeScript errors
2. `scripts/test-subscription-harness.ps1` exists with correct parameter and tsx invocation
3. The harness imports BinanceRestClient from `@livermore/binance-client`
4. The harness uses `exchangeCandleKey` from `@livermore/cache` for verification
5. The harness connects to WebSocket at `{wsUrl}/ws` and sends SUBSCRIBE for `btcusdt@kline_1m`
6. Exit code is 0 for all-pass, 1 for any-fail
</verification>

<success_criteria>
A test harness script exists that can validate the Binance REST and WebSocket pipelines against any Binance-family exchange by name, with clear pass/fail output.
</success_criteria>

<output>
After completion, create `.planning/phases/38-binance-test-harness-handoff/38-01-SUMMARY.md`
</output>
