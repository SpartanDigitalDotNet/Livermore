---
phase: 32-trpc-network-router
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/routers/network.router.ts
  - apps/api/src/routers/index.ts
autonomous: true

must_haves:
  truths:
    - "network.getInstances returns a status entry for every active exchange in the DB, including offline ones with online=false"
    - "network.getActivityLog returns stream entries in reverse chronological order with cursor-based pagination for single-exchange queries"
    - "network.getExchangeStatus returns the full InstanceStatus payload for a single exchange, or online=false when the key has expired"
    - "No SCAN, KEYS, or MGET commands are used anywhere in the router"
    - "All three procedures use protectedProcedure (not publicProcedure)"
  artifacts:
    - path: "apps/api/src/routers/network.router.ts"
      provides: "Network tRPC router with getInstances, getActivityLog, getExchangeStatus procedures"
      exports: ["networkRouter", "NetworkRouter"]
    - path: "apps/api/src/routers/index.ts"
      provides: "Root router with network sub-router registered"
      contains: "network: networkRouter"
  key_links:
    - from: "apps/api/src/routers/network.router.ts"
      to: "@livermore/database"
      via: "DB query for authoritative exchange list"
      pattern: "from\\(exchanges\\)"
    - from: "apps/api/src/routers/network.router.ts"
      to: "@livermore/cache"
      via: "instanceStatusKey and networkActivityStreamKey key builders"
      pattern: "instanceStatusKey|networkActivityStreamKey"
    - from: "apps/api/src/routers/network.router.ts"
      to: "redis.get and redis.xrevrange"
      via: "Individual GET per exchange (no MGET), individual XREVRANGE per stream (no multi-stream XREAD)"
      pattern: "redis\\.get|redis\\.xrevrange"
    - from: "apps/api/src/routers/index.ts"
      to: "apps/api/src/routers/network.router.ts"
      via: "Router registration in appRouter"
      pattern: "network: networkRouter"
---

<objective>
Create the `network` tRPC router with three read-only procedures (`getInstances`, `getActivityLog`, `getExchangeStatus`) and register it in the root app router.

Purpose: Phase 33 Admin UI needs an API surface to display instance status and activity logs. This router provides all three endpoints the UI will consume, using the DB-then-Redis merge pattern already established in `exchange-symbol.router.ts` and XREVRANGE for stream reading.
Output: 1 new router file, 1 modified index file. Three working tRPC procedures.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/32-trpc-network-router/32-RESEARCH.md

Key source files (patterns to follow):
@apps/api/src/routers/exchange-symbol.router.ts (lines 220-260: DB+Redis merge pattern for exchangeStatuses)
@apps/api/src/routers/control.router.ts (protectedProcedure usage, router structure)
@apps/api/src/routers/index.ts (router registration)
@packages/schemas/src/network/instance-status.schema.ts (InstanceStatus type)
@packages/schemas/src/network/activity-log.schema.ts (stream entry schemas)
@packages/cache/src/keys.ts (instanceStatusKey, networkActivityStreamKey)
@packages/database/src/schema/exchanges.ts (exchanges table)
@packages/trpc-config/src/trpc.ts (router, protectedProcedure exports)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create network.router.ts with three procedures</name>
  <files>apps/api/src/routers/network.router.ts</files>
  <action>
    Create `apps/api/src/routers/network.router.ts` with a `networkRouter` exporting three protectedProcedure queries.

    **Imports:**
    ```typescript
    import { z } from 'zod';
    import { router, protectedProcedure } from '@livermore/trpc-config';
    import { getDbClient, exchanges } from '@livermore/database';
    import { getRedisClient, instanceStatusKey, networkActivityStreamKey } from '@livermore/cache';
    import { eq, asc } from 'drizzle-orm';
    import type { InstanceStatus } from '@livermore/schemas';
    ```

    Do NOT import `createLogger` or `@livermore/utils` -- these are read-only query procedures, not services. No logging needed beyond what tRPC middleware already provides.

    **Procedure 1: `getInstances`** (RPC-01)
    - No input
    - Query the `exchanges` table for active exchanges: select id, name, displayName where isActive=true, order by id asc
    - For each exchange, GET `instanceStatusKey(ex.id)` from Redis using individual GET calls (NOT MGET -- CROSSSLOT in Cluster)
    - Use `Promise.all()` for parallel fetches
    - Wrap `JSON.parse(data)` in try-catch -- on parse failure, treat as offline
    - Return shape: `{ instances: Array<{ exchangeId, exchangeName, displayName, online: boolean, status: InstanceStatus | null }> }`
    - Online = Redis key exists and parses. Offline = key missing or parse error, status = null.
    - Follow the exact pattern from `exchange-symbol.router.ts` lines 220-260 (exchangeStatuses procedure)

    **Procedure 2: `getActivityLog`** (RPC-02)
    - Input: `{ exchangeName?: string, count: number (1-200, default 50), cursor?: string }`
    - Define a local helper `parseStreamEntry(id: string, fields: string[]): Record<string, string> & { id: string }` that iterates the flat field-value array in pairs
    - **Single-exchange mode** (when exchangeName is provided):
      - Build stream key via `networkActivityStreamKey(exchangeName)`
      - Use `redis.xrevrange(streamKey, end, '-', 'COUNT', count + 1)` where end = cursor ?? '+'
      - If cursor was provided and first entry's ID matches cursor, skip it (XREVRANGE is inclusive)
      - Slice to `count` entries
      - Parse each entry with `parseStreamEntry`
      - nextCursor = last entry's ID if we got a full page, else null
      - Wrap in try-catch: return `{ entries: [], nextCursor: null }` on any error (stream may not exist)
    - **Global mode** (when exchangeName is omitted):
      - Query `exchanges` table for active exchanges (select name only)
      - XREVRANGE each exchange's stream individually with COUNT=count (NOT multi-stream XREAD -- CROSSSLOT)
      - Use `Promise.all()` for parallel reads
      - Wrap each XREVRANGE in try-catch returning empty array on error
      - Flatten all results, parse entries, sort by stream ID descending (b.id.localeCompare(a.id)), take top `count`
      - Return `{ entries: parsed, nextCursor: null }` (no cursor pagination in global mode per RESEARCH.md recommendation)

    **Procedure 3: `getExchangeStatus`** (RPC-03)
    - Input: `{ exchangeId: z.number() }`
    - GET `instanceStatusKey(input.exchangeId)` from Redis
    - Parse JSON, wrap in try-catch
    - Return `{ online: true, status }` if key exists and parses
    - Return `{ online: false, status: null }` if key missing, expired, or parse error

    **Critical constraints:**
    - Use `protectedProcedure` for all three (NOT publicProcedure -- STATE.md tech debt)
    - Use individual GET calls, never MGET (CROSSSLOT in Azure Redis Cluster)
    - Use individual XREVRANGE calls, never multi-stream XREAD (CROSSSLOT)
    - Parse stream entries by iterating flat field-value pairs, NOT JSON.parse (stream entries are flat)
    - Export both `networkRouter` and `type NetworkRouter`
  </action>
  <verify>
    Run `npx tsc --noEmit -p apps/api/tsconfig.json` -- no type errors.
    Grep for `protectedProcedure` in the file -- should appear 3 times (one per procedure).
    Grep for `MGET`, `XREAD`, `keys(`, `scan(` in the file -- should return zero matches.
    Grep for `publicProcedure` in the file -- should return zero matches.
  </verify>
  <done>
    network.router.ts exports networkRouter with getInstances, getActivityLog, getExchangeStatus. All use protectedProcedure. No SCAN/KEYS/MGET/XREAD. Type-checks clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register network router in the root app router</name>
  <files>apps/api/src/routers/index.ts</files>
  <action>
    Modify `apps/api/src/routers/index.ts` to register the network router:

    1. Add import: `import { networkRouter } from './network.router';`
    2. Add `network: networkRouter,` to the `appRouter` router object (after `exchangeSymbol: exchangeSymbolRouter,`)
    3. Add re-export: `export { networkRouter } from './network.router';`

    Follow the exact pattern of existing router registrations in the file. The import goes with the other imports, the registration goes in the router object, and the re-export goes at the bottom with the other re-exports.
  </action>
  <verify>
    Run `npx tsc --noEmit -p apps/api/tsconfig.json` -- no type errors.
    Grep for `network: networkRouter` in index.ts -- should match.
    Grep for `networkRouter` in index.ts -- should appear 3 times (import, registration, re-export).
  </verify>
  <done>
    `appRouter` includes `network: networkRouter`. The network router type is part of `AppRouter` for client inference. Re-export present.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit -p apps/api/tsconfig.json` passes with zero errors
- network.router.ts has exactly 3 procedures: getInstances, getActivityLog, getExchangeStatus
- All 3 procedures use protectedProcedure (grep confirms)
- No SCAN, KEYS, MGET, or multi-stream XREAD used (grep confirms zero matches)
- getInstances queries exchanges DB table then GETs individual Redis keys
- getActivityLog uses XREVRANGE with COUNT, supports cursor for single-exchange mode
- getExchangeStatus takes exchangeId number input, returns online boolean + status
- index.ts registers network: networkRouter in appRouter
- AppRouter type includes the network sub-router for client type inference
</verification>

<success_criteria>
- RPC-01: `network.getInstances` returns all active exchanges with online/offline status from DB + individual Redis GETs
- RPC-02: `network.getActivityLog` returns reverse-chronological stream entries with pagination (cursor for single-exchange, top-N for global)
- RPC-03: `network.getExchangeStatus` returns full InstanceStatus for one exchange or offline indicator
- No SCAN/KEYS/MGET used (cluster-safe)
- All procedures use protectedProcedure (not publicProcedure)
</success_criteria>

<output>
After completion, create `.planning/phases/32-trpc-network-router/32-01-SUMMARY.md`
</output>
