---
phase: 18-control-channel-foundation
plan: 03
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - apps/api/src/server.ts
autonomous: true

must_haves:
  truths:
    - "ControlChannelService starts during server startup after pre-flight checks"
    - "ControlChannelService stops during graceful shutdown before Redis quit"
    - "Service receives identitySub from environment or hardcoded test value"
  artifacts:
    - path: "apps/api/src/server.ts"
      provides: "Server startup integration for ControlChannelService"
      contains: "ControlChannelService"
  key_links:
    - from: "apps/api/src/server.ts"
      to: "apps/api/src/services/control-channel.service.ts"
      via: "import and instantiation"
      pattern: "import.*ControlChannelService.*from"
    - from: "apps/api/src/server.ts"
      to: "shutdown sequence"
      via: "controlChannelService.stop()"
      pattern: "await controlChannelService\\.stop\\(\\)"
---

<objective>
Integrate ControlChannelService with API server startup and shutdown.

Purpose: The service must be running before it can receive commands. Integration ensures the control channel is always available when the API is running and cleanly stopped during shutdown.

Output: Modified server.ts with ControlChannelService lifecycle management
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-control-channel-foundation/18-RESEARCH.md
@.planning/phases/18-control-channel-foundation/18-01-SUMMARY.md
@.planning/phases/18-control-channel-foundation/18-02-SUMMARY.md
@apps/api/src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ControlChannelService import and startup</name>
  <files>apps/api/src/server.ts</files>
  <action>
Modify apps/api/src/server.ts to integrate ControlChannelService:

1. Add import near other service imports (around line 14):
   ```typescript
   import { ControlChannelService } from './services/control-channel.service';
   ```

2. Add TEST_IDENTITY_SUB constant near other constants (after MIN_POSITION_VALUE_USD):
   ```typescript
   // Temporary: hardcode test identity_sub until multi-user support
   // This should match the Clerk user.id of the test user
   // TODO: Replace with dynamic identity from authenticated context
   const TEST_IDENTITY_SUB = 'user_test_001';
   ```

3. Start ControlChannelService AFTER pre-flight checks pass but BEFORE other services (around line 193, after "Pre-flight checks passed"):
   ```typescript
   // Start Control Channel Service (must be early - receives runtime commands)
   const controlChannelService = new ControlChannelService(TEST_IDENTITY_SUB);
   await controlChannelService.start();
   logger.info({ identitySub: TEST_IDENTITY_SUB }, 'Control Channel Service started');
   ```

   Place this after Discord service initialization and before "Fetching symbols from Coinbase account".

4. Ensure controlChannelService variable is accessible in shutdown handler (it needs to be in the same scope or passed to shutdown).
  </action>
  <verify>
Run: `pnpm -F api build`
Verify no TypeScript errors.
Check import: `grep "ControlChannelService" apps/api/src/server.ts`
  </verify>
  <done>
- ControlChannelService imported from ./services/control-channel.service
- TEST_IDENTITY_SUB constant defined for test user
- Service started after pre-flight checks, before data services
- Logger confirms control channel startup with identitySub
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ControlChannelService to graceful shutdown</name>
  <files>apps/api/src/server.ts</files>
  <action>
Add ControlChannelService to the shutdown sequence in server.ts:

1. Locate the shutdown handler (around line 333):
   ```typescript
   const shutdown = async () => {
   ```

2. Add controlChannelService.stop() EARLY in shutdown sequence (before alertService.stop()):
   ```typescript
   // Stop Control Channel first (no new commands accepted)
   await controlChannelService.stop();
   ```

   The order should be:
   1. controlChannelService.stop() - stop accepting commands first
   2. alertService.stop()
   3. coinbaseAdapter.disconnect()
   4. boundaryRestService.stop()
   5. indicatorService.stop()
   6. subscriberRedis.quit()
   7. Discord notification
   8. redis.quit()
   9. fastify.close()

3. Update health check endpoint to include control channel status (optional but useful):
   ```typescript
   // In health check handler, add to services object:
   controlChannel: 'active',
   ```
  </action>
  <verify>
Run: `pnpm -F api build`
Verify no TypeScript errors.
Check shutdown sequence: `grep -A 5 "controlChannelService.stop" apps/api/src/server.ts`
  </verify>
  <done>
- controlChannelService.stop() called early in shutdown sequence
- Service stops before data services (correct order)
- Health check optionally reports control channel status
- No new commands accepted after shutdown begins
  </done>
</task>

</tasks>

<verification>
1. Run `pnpm -F api build` - no TypeScript errors
2. Verify startup sequence: `grep -n "ControlChannelService" apps/api/src/server.ts`
3. Verify shutdown sequence: `grep -n "controlChannelService.stop" apps/api/src/server.ts`
4. Start server locally and check logs for "Control Channel Service started"
</verification>

<success_criteria>
- ControlChannelService imported and instantiated in server.ts
- Service started after pre-flight checks with TEST_IDENTITY_SUB
- Service stopped first in graceful shutdown sequence
- Server builds without TypeScript errors
- Startup logs confirm control channel is active
</success_criteria>

<output>
After completion, create `.planning/phases/18-control-channel-foundation/18-03-SUMMARY.md`
</output>
