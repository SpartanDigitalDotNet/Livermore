---
phase: 18-control-channel-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/schemas/src/control/command.schema.ts
  - packages/schemas/src/index.ts
  - packages/cache/src/keys.ts
autonomous: true

must_haves:
  truths:
    - "Command messages have correlationId, type, payload, timestamp, priority"
    - "Response messages have correlationId, status, message, data, timestamp"
    - "Channel key functions produce correct livermore:commands:{sub} and livermore:responses:{sub} patterns"
  artifacts:
    - path: "packages/schemas/src/control/command.schema.ts"
      provides: "Zod schemas for Command and CommandResponse"
      exports: ["CommandTypeSchema", "CommandSchema", "CommandResponseSchema", "Command", "CommandResponse", "CommandType"]
    - path: "packages/cache/src/keys.ts"
      provides: "Channel key helper functions"
      exports: ["commandChannel", "responseChannel"]
  key_links:
    - from: "packages/schemas/src/control/command.schema.ts"
      to: "packages/schemas/src/index.ts"
      via: "barrel export"
      pattern: "export \\* from './control/command.schema'"
---

<objective>
Create Zod schemas for control channel messages and Redis channel key helpers.

Purpose: Foundation types and channel keys must exist before ControlChannelService can be implemented. Schemas ensure type-safe message validation. Key helpers ensure consistent channel naming.

Output: Command/CommandResponse schemas in packages/schemas, channel key functions in packages/cache
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-control-channel-foundation/18-RESEARCH.md
@packages/schemas/src/settings/user-settings.schema.ts (pattern reference)
@packages/cache/src/keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create command.schema.ts with Zod schemas</name>
  <files>packages/schemas/src/control/command.schema.ts</files>
  <action>
Create `packages/schemas/src/control/command.schema.ts` with:

1. CommandTypeSchema - z.enum with all command types:
   - 'pause', 'resume' (Phase 18 - control channel foundation)
   - 'reload-settings', 'switch-mode', 'force-backfill', 'clear-cache' (Phase 19 - runtime commands)
   - 'add-symbol', 'remove-symbol' (Phase 20 - symbol management)
   Note: Define all types now for forward compatibility. Only pause/resume will be implemented in Phase 18.

2. CommandSchema - z.object:
   - correlationId: z.string().uuid()
   - type: CommandTypeSchema
   - payload: z.record(z.unknown()).optional()
   - timestamp: z.number()
   - priority: z.number().min(1).max(100)

3. CommandResponseSchema - z.object:
   - correlationId: z.string().uuid()
   - status: z.enum(['ack', 'success', 'error'])
   - message: z.string().optional()
   - data: z.unknown().optional()
   - timestamp: z.number()

4. Export TypeScript types: CommandType, Command, CommandResponse

Follow existing pattern from user-settings.schema.ts (z.infer for types, JSDoc comments).
  </action>
  <verify>
Run: `pnpm -F @livermore/schemas build`
Verify no TypeScript errors.
  </verify>
  <done>
- CommandTypeSchema exported with all 8 command types
- CommandSchema exported with correlationId, type, payload, timestamp, priority
- CommandResponseSchema exported with correlationId, status, message, data, timestamp
- Types Command, CommandResponse, CommandType exported
  </done>
</task>

<task type="auto">
  <name>Task 2: Export schemas from barrel and add channel keys</name>
  <files>packages/schemas/src/index.ts, packages/cache/src/keys.ts</files>
  <action>
1. Add export to packages/schemas/src/index.ts:
   ```typescript
   // Control channel schemas
   export * from './control/command.schema';
   ```
   Add after the "User settings schemas" section.

2. Add channel key functions to packages/cache/src/keys.ts:

   ```typescript
   /**
    * Build Redis pub/sub channel for control commands
    * Admin UI publishes commands, API subscribes
    * @param identitySub - Clerk user identity subject (user.id)
    */
   export function commandChannel(identitySub: string): string {
     return `livermore:commands:${identitySub}`;
   }

   /**
    * Build Redis pub/sub channel for command responses
    * API publishes responses, Admin UI subscribes
    * @param identitySub - Clerk user identity subject (user.id)
    */
   export function responseChannel(identitySub: string): string {
     return `livermore:responses:${identitySub}`;
   }
   ```
   Add at the end of the file, following existing function patterns.
  </action>
  <verify>
Run: `pnpm -F @livermore/schemas build && pnpm -F @livermore/cache build`
Verify both packages build without errors.
Verify exports by checking: `grep -r "commandChannel\|responseChannel" packages/cache/src/`
  </verify>
  <done>
- packages/schemas/src/index.ts exports control schemas
- packages/cache/src/keys.ts has commandChannel and responseChannel functions
- Both packages build successfully
  </done>
</task>

</tasks>

<verification>
1. Run `pnpm build` from monorepo root - all packages build
2. Verify schema exports: `grep -r "CommandSchema" packages/schemas/src/`
3. Verify key exports: `grep -r "commandChannel" packages/cache/src/`
</verification>

<success_criteria>
- CommandTypeSchema includes all 8 command types for forward compatibility
- CommandSchema validates command messages with required fields
- CommandResponseSchema validates response messages with status enum
- Channel key functions produce livermore:commands:{sub} and livermore:responses:{sub}
- Both packages build without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/18-control-channel-foundation/18-01-SUMMARY.md`
</output>
