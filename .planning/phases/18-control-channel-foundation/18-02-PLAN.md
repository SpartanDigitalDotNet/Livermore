---
phase: 18-control-channel-foundation
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - apps/api/src/services/control-channel.service.ts
autonomous: true

must_haves:
  truths:
    - "Service subscribes to command channel on start"
    - "Service publishes ACK immediately on command receipt"
    - "Service publishes result after command execution"
    - "Commands older than 30s are rejected as expired"
    - "Service unsubscribes and cleans up on stop"
  artifacts:
    - path: "apps/api/src/services/control-channel.service.ts"
      provides: "ControlChannelService class with start/stop methods"
      exports: ["ControlChannelService"]
      min_lines: 100
  key_links:
    - from: "apps/api/src/services/control-channel.service.ts"
      to: "@livermore/schemas"
      via: "import CommandSchema"
      pattern: "import.*CommandSchema.*from '@livermore/schemas'"
    - from: "apps/api/src/services/control-channel.service.ts"
      to: "@livermore/cache"
      via: "import getRedisClient"
      pattern: "import.*getRedisClient.*from '@livermore/cache'"
---

<objective>
Create ControlChannelService that subscribes to Redis command channel, validates commands, and publishes ACK/results to response channel.

Purpose: Core service that enables Admin-to-API communication. Handles RUN-01 (command channel), RUN-02 (response channel), RUN-03 (command handler), RUN-10 (ACK), RUN-11 (result), RUN-12 (timeout).

Output: ControlChannelService class in apps/api/src/services/
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-control-channel-foundation/18-RESEARCH.md
@.planning/phases/18-control-channel-foundation/18-01-SUMMARY.md
@apps/api/src/services/indicator-calculation.service.ts (pattern reference for pub/sub)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ControlChannelService with pub/sub handling</name>
  <files>apps/api/src/services/control-channel.service.ts</files>
  <action>
Create `apps/api/src/services/control-channel.service.ts` following the indicator-calculation.service.ts pattern:

1. Imports:
   - getRedisClient from @livermore/cache
   - createLogger from @livermore/utils
   - CommandSchema, type Command, type CommandResponse from @livermore/schemas
   - type Redis from ioredis

2. Create logger: `createLogger({ name: 'control-channel', service: 'control' })`

3. ControlChannelService class:
   ```typescript
   export class ControlChannelService {
     private redis = getRedisClient();
     private subscriber: Redis | null = null;
     private identitySub: string;
     private commandChannel: string;
     private responseChannel: string;
     private readonly COMMAND_TIMEOUT_MS = 30_000; // RUN-12

     constructor(identitySub: string) {
       this.identitySub = identitySub;
       this.commandChannel = `livermore:commands:${identitySub}`;
       this.responseChannel = `livermore:responses:${identitySub}`;
     }
   }
   ```

4. start() method:
   - Create subscriber via redis.duplicate() (CRITICAL - required for pub/sub mode)
   - Subscribe to commandChannel
   - Set up 'message' event handler that calls handleMessage()
   - Log channel subscription

5. handleMessage(message: string) method:
   - Parse JSON (catch parse errors, log and return)
   - Validate with CommandSchema.safeParse() (reject invalid, log errors)
   - Check timeout: if (Date.now() - command.timestamp > COMMAND_TIMEOUT_MS), publish error response "Command expired", return
   - Call handleCommand() with validated command

6. handleCommand(command: Command) method:
   - Publish immediate ACK (RUN-10):
     ```typescript
     await this.publishResponse({
       correlationId: command.correlationId,
       status: 'ack',
       timestamp: Date.now(),
     });
     ```
   - Execute command in try/catch
   - Publish success result (RUN-11) or error result on failure

7. executeCommand(command: Command) method:
   - For Phase 18, return stub: `{ executed: true, type: command.type }`
   - Log: `logger.info({ type: command.type, payload: command.payload }, 'Executing command')`
   - Phase 19 will implement actual command handlers

8. publishResponse(response: CommandResponse) method:
   - `await this.redis.publish(this.responseChannel, JSON.stringify(response))`

9. stop() method:
   - Unsubscribe from channel
   - Quit subscriber connection
   - Set subscriber to null
   - Log shutdown

Note: Follow indicator-calculation.service.ts EXACTLY for subscriber setup pattern. The duplicate() call is critical.
  </action>
  <verify>
Run: `pnpm -F api build`
Verify no TypeScript errors.
Verify file exists: `ls apps/api/src/services/control-channel.service.ts`
  </verify>
  <done>
- ControlChannelService class created with constructor accepting identitySub
- start() creates duplicate Redis connection and subscribes to command channel
- handleMessage() parses, validates, checks timeout, dispatches to handleCommand
- handleCommand() publishes ACK immediately, then executes and publishes result
- executeCommand() is stub for Phase 19
- stop() unsubscribes and cleans up Redis connection
- Uses correct import paths for @livermore/schemas and @livermore/cache
  </done>
</task>

<task type="auto">
  <name>Task 2: Add priority queue support for command ordering</name>
  <files>apps/api/src/services/control-channel.service.ts</files>
  <action>
Enhance ControlChannelService to support command priority (RUN-13):

1. Add PRIORITY constant at module level:
   ```typescript
   const PRIORITY = {
     PAUSE: 1,
     RESUME: 1,
     RELOAD_SETTINGS: 10,
     SWITCH_MODE: 10,
     FORCE_BACKFILL: 20,
     CLEAR_CACHE: 20,
     ADD_SYMBOL: 15,
     REMOVE_SYMBOL: 15,
   } as const;
   ```

2. Add queue key property:
   ```typescript
   private commandQueueKey: string;
   // In constructor:
   this.commandQueueKey = `livermore:command-queue:${identitySub}`;
   ```

3. Modify handleMessage to queue instead of direct execute:
   - Instead of calling handleCommand directly, add command to sorted set:
     ```typescript
     await this.redis.zadd(this.commandQueueKey, command.priority, JSON.stringify(command));
     ```
   - Trigger queue processing

4. Add processQueue() method:
   ```typescript
   private async processQueue(): Promise<void> {
     // Process one command at a time from priority queue
     const results = await this.redis.zpopmin(this.commandQueueKey, 1);
     if (!results || results.length === 0) return;

     const [commandJson] = results;
     const command = JSON.parse(commandJson) as Command;

     await this.handleCommand(command);

     // Process next if queue not empty
     const remaining = await this.redis.zcard(this.commandQueueKey);
     if (remaining > 0) {
       // Use setImmediate to prevent blocking
       setImmediate(() => this.processQueue().catch(err =>
         logger.error({ error: err }, 'Error processing queue')
       ));
     }
   }
   ```

5. Update handleMessage to call processQueue after queuing

6. Add getQueueDepth() method for observability:
   ```typescript
   async getQueueDepth(): Promise<number> {
     return this.redis.zcard(this.commandQueueKey);
   }
   ```

Note: This ensures pause/resume (priority 1) are processed before backfill (priority 20).
  </action>
  <verify>
Run: `pnpm -F api build`
Verify no TypeScript errors.
  </verify>
  <done>
- PRIORITY constant defines priority levels for all command types
- Commands are queued in Redis sorted set by priority
- processQueue() processes lowest priority (highest urgency) first
- pause/resume at priority 1 processed before other commands at 10-20
- getQueueDepth() method available for monitoring
  </done>
</task>

</tasks>

<verification>
1. Run `pnpm -F api build` - no TypeScript errors
2. Verify service file: `cat apps/api/src/services/control-channel.service.ts | head -50`
3. Check imports are correct for @livermore/schemas and @livermore/cache
</verification>

<success_criteria>
- ControlChannelService subscribes to Redis command channel for specific user
- Commands validated with Zod schema before processing
- ACK published within handleCommand() before execution (RUN-10)
- Result published after execution completes (RUN-11)
- Commands older than 30s rejected as expired (RUN-12)
- Priority queue ensures pause/resume processed first (RUN-13)
- Clean shutdown unsubscribes and quits subscriber connection
</success_criteria>

<output>
After completion, create `.planning/phases/18-control-channel-foundation/18-02-SUMMARY.md`
</output>
