---
phase: 30-instance-registry-and-state-machine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/schemas/src/network/instance-status.schema.ts
  - packages/schemas/src/index.ts
  - packages/cache/src/keys.ts
  - apps/api/src/utils/detect-public-ip.ts
autonomous: true

must_haves:
  truths:
    - "ConnectionState type has exactly 6 values: idle, starting, warming, active, stopping, stopped"
    - "InstanceStatus schema validates full identity payload with all required fields"
    - "instanceStatusKey(1) returns 'exchange:1:status'"
    - "detectPublicIp() returns an IP string or null within 3 seconds, never throws"
  artifacts:
    - path: "packages/schemas/src/network/instance-status.schema.ts"
      provides: "ConnectionState enum, InstanceStatus Zod schema, TypeScript types, VALID_TRANSITIONS map, HEARTBEAT_INTERVAL_MS, HEARTBEAT_TTL_MS constants"
      exports: ["ConnectionStateSchema", "ConnectionState", "InstanceStatusSchema", "InstanceStatus", "VALID_TRANSITIONS", "HEARTBEAT_INTERVAL_MS", "HEARTBEAT_TTL_MS"]
    - path: "packages/schemas/src/index.ts"
      provides: "Re-export of network schemas"
      contains: "export * from './network/instance-status.schema'"
    - path: "packages/cache/src/keys.ts"
      provides: "instanceStatusKey function"
      exports: ["instanceStatusKey"]
    - path: "apps/api/src/utils/detect-public-ip.ts"
      provides: "detectPublicIp async function"
      exports: ["detectPublicIp"]
  key_links:
    - from: "packages/schemas/src/index.ts"
      to: "packages/schemas/src/network/instance-status.schema.ts"
      via: "barrel re-export"
      pattern: "export \\* from './network/instance-status\\.schema'"
    - from: "packages/cache/src/keys.ts"
      to: "exchange:{id}:status"
      via: "key builder function"
      pattern: "instanceStatusKey"
---

<objective>
Create the foundational types, schemas, key builders, and utilities that the InstanceRegistryService and StateMachineService will depend on.

Purpose: All subsequent plans in Phase 30 import from these artifacts. Building them first means Plans 02 and 03 can import real types instead of inline stubs.
Output: 4 files -- Zod schema with types and constants, updated schema barrel, updated key builder, and IP detection utility.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-instance-registry-and-state-machine/30-RESEARCH.md

Key source files:
@packages/schemas/src/index.ts
@packages/cache/src/keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InstanceStatus Zod schema with state machine constants</name>
  <files>
    packages/schemas/src/network/instance-status.schema.ts
    packages/schemas/src/index.ts
  </files>
  <action>
    Create `packages/schemas/src/network/instance-status.schema.ts` with the following:

    1. **ConnectionStateSchema** -- Zod enum with exactly 6 values: `'idle'`, `'starting'`, `'warming'`, `'active'`, `'stopping'`, `'stopped'`. Export the inferred `ConnectionState` type.

    2. **VALID_TRANSITIONS** -- `Record<ConnectionState, ConnectionState[]>` defining allowed state transitions:
       - idle: ['starting']
       - starting: ['warming', 'stopping', 'idle']  (idle for error recovery)
       - warming: ['active', 'stopping', 'idle']     (idle for error recovery)
       - active: ['stopping']
       - stopping: ['stopped']
       - stopped: ['idle']                            (ready for restart)

    3. **Heartbeat constants**:
       - `HEARTBEAT_INTERVAL_MS = 15_000` (15 seconds)
       - `HEARTBEAT_TTL_MS = 45_000` (45 seconds, 3x interval)
       - `HEARTBEAT_TTL_SECONDS = 45` (for Redis SET EX)

    4. **InstanceStatusSchema** -- Zod object with these fields:
       - exchangeId: z.number()
       - exchangeName: z.string()
       - hostname: z.string()
       - ipAddress: z.string().nullable()
       - adminEmail: z.string().nullable()
       - adminDisplayName: z.string().nullable()
       - connectionState: ConnectionStateSchema
       - symbolCount: z.number()
       - connectedAt: z.string().nullable()       (ISO string, set when entering 'active')
       - lastHeartbeat: z.string()                 (ISO string, updated every heartbeat)
       - lastStateChange: z.string()               (ISO string, updated on every transition)
       - registeredAt: z.string()                  (ISO string, set once at registration)
       - lastError: z.string().nullable()
       - lastErrorAt: z.string().nullable()

       Export the inferred `InstanceStatus` type.

    5. Update `packages/schemas/src/index.ts` to add: `export * from './network/instance-status.schema';`

    IMPORTANT: The `adminEmail` and `adminDisplayName` fields must be nullable because at registration time (before first authenticated request), the user identity is not yet available (see RESEARCH.md Open Question #2).

    Do NOT add `satisfies` or type assertion on `VALID_TRANSITIONS`. Use `as const satisfies Record<ConnectionState, readonly ConnectionState[]>` to get readonly tuple inference while ensuring type safety.
  </action>
  <verify>
    Run `npx tsc --noEmit -p packages/schemas/tsconfig.json` -- no type errors.
    Verify the schema file exports ConnectionStateSchema, ConnectionState, InstanceStatusSchema, InstanceStatus, VALID_TRANSITIONS, HEARTBEAT_INTERVAL_MS, HEARTBEAT_TTL_MS, HEARTBEAT_TTL_SECONDS by checking the barrel export.
  </verify>
  <done>
    ConnectionState has 6 values. InstanceStatus schema has 14 fields. VALID_TRANSITIONS has 6 entries. Constants defined. Schema barrel re-exports everything.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add instanceStatusKey to cache keys and create detectPublicIp utility</name>
  <files>
    packages/cache/src/keys.ts
    apps/api/src/utils/detect-public-ip.ts
  </files>
  <action>
    **Part A: Key builder**

    Add `instanceStatusKey` function to `packages/cache/src/keys.ts`. Place it in a new section at the top of the file (before Tier 1 section) labeled `// INSTANCE REGISTRY KEYS`. Follow the existing JSDoc pattern:

    ```typescript
    // ============================================
    // INSTANCE REGISTRY: Network Status Keys
    // ============================================

    /**
     * Build Redis key for exchange instance status.
     * Phase 30: Exchange-scoped instance registration with TTL.
     *
     * @example instanceStatusKey(1) // 'exchange:1:status'
     */
    export function instanceStatusKey(exchangeId: number): string {
      return `exchange:${exchangeId}:status`;
    }
    ```

    This replaces the prototype's `connectionStatusKey` in `adapter-factory.ts` which used `exchange:status:{id}` (note the different key order). The new pattern `exchange:{id}:status` is consistent with other exchange-scoped keys.

    **Part B: Public IP detection**

    Create `apps/api/src/utils/detect-public-ip.ts`:

    - Export async function `detectPublicIp(timeoutMs = 3000): Promise<string | null>`
    - Use `node:https` (NOT `node:http`, NOT `fetch`, NOT any npm package) to GET `https://api.ipify.org`
    - Set timeout to `timeoutMs` milliseconds
    - On success, return trimmed response string
    - On ANY error (network, timeout, empty response), resolve with `null` -- NEVER throw
    - On timeout, call `req.destroy()` then resolve `null`
    - Create the `apps/api/src/utils/` directory if it does not exist

    The function must NEVER block startup. It returns a Promise that resolves to a string or null. The caller will use the result to update the instance status payload asynchronously.
  </action>
  <verify>
    Run `npx tsc --noEmit -p packages/cache/tsconfig.json` -- no type errors.
    Run `npx tsc --noEmit -p apps/api/tsconfig.json` -- no type errors.
    Verify `instanceStatusKey(1)` pattern is correct by grepping the file.
    Verify `detectPublicIp` function signature and error handling.
  </verify>
  <done>
    `instanceStatusKey(1)` returns `'exchange:1:status'`. `detectPublicIp()` compiles cleanly and handles timeout/error by returning null.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes for both packages/schemas and packages/cache
- `npx tsc --noEmit -p apps/api/tsconfig.json` passes (detect-public-ip compiles)
- ConnectionState has exactly 6 values (grep for the enum)
- InstanceStatus has all 14 fields from REG-02
- VALID_TRANSITIONS covers all 6 states
- instanceStatusKey follows existing key builder pattern
- detectPublicIp uses node:https, has timeout, never throws
</verification>

<success_criteria>
- REG-01 (partial): Key pattern `exchange:{id}:status` defined
- REG-02: Full identity payload schema with all fields
- REG-03: 6-state ConnectionState with transition map
- REG-05: Public IP detection utility with timeout and fallback
- REG-06: Hostname detection will use os.hostname() (referenced in schema, implemented in Plan 02)
- HB-02: Heartbeat interval (15s) and TTL (45s) constants defined
</success_criteria>

<output>
After completion, create `.planning/phases/30-instance-registry-and-state-machine/30-01-SUMMARY.md`
</output>
