---
phase: 30-instance-registry-and-state-machine
plan: 02
type: execute
wave: 2
depends_on: ["30-01"]
files_modified:
  - apps/api/src/services/state-machine.service.ts
  - apps/api/src/services/instance-registry.service.ts
autonomous: true

must_haves:
  truths:
    - "StateMachineService rejects invalid transitions with an error describing from/to states"
    - "StateMachineService accepts valid transitions and updates both Redis payload and in-memory RuntimeState"
    - "InstanceRegistryService.register() atomically claims exchange slot via SET NX EX and returns false if another instance holds it"
    - "InstanceRegistryService.register() includes hostname, IP, exchange info, and timestamps in the Redis payload"
    - "InstanceRegistryService starts a heartbeat timer that refreshes the key every 15 seconds with full payload and 45s TTL"
    - "InstanceRegistryService.deregister() stops the heartbeat and deletes the Redis key"
    - "When heartbeat finds key missing (expired), it logs a warning and re-registers"
    - "Conflict error message includes hostname, IP, and connectedAt of the instance holding the lock"
  artifacts:
    - path: "apps/api/src/services/state-machine.service.ts"
      provides: "StateMachineService class with transition(), getCurrentState(), getTransitionHistory()"
      exports: ["StateMachineService"]
    - path: "apps/api/src/services/instance-registry.service.ts"
      provides: "InstanceRegistryService class with register(), deregister(), startHeartbeat(), stopHeartbeat(), updateStatus(), getStatus(), recordError()"
      exports: ["InstanceRegistryService"]
  key_links:
    - from: "apps/api/src/services/state-machine.service.ts"
      to: "packages/schemas/src/network/instance-status.schema.ts"
      via: "import types and transition map"
      pattern: "import.*ConnectionState.*VALID_TRANSITIONS.*from '@livermore/schemas'"
    - from: "apps/api/src/services/state-machine.service.ts"
      to: "apps/api/src/services/instance-registry.service.ts"
      via: "calls registry.updateStatus() after valid transition"
      pattern: "this\\.registry\\.updateStatus"
    - from: "apps/api/src/services/instance-registry.service.ts"
      to: "packages/cache/src/keys.ts"
      via: "import instanceStatusKey"
      pattern: "import.*instanceStatusKey.*from '@livermore/cache'"
    - from: "apps/api/src/services/instance-registry.service.ts"
      to: "Redis SET NX EX"
      via: "atomic exchange claim"
      pattern: "redis\\.set\\(.*'NX'"
    - from: "apps/api/src/services/state-machine.service.ts"
      to: "apps/api/src/services/runtime-state.ts"
      via: "updates in-memory state for backward compatibility"
      pattern: "updateRuntimeState"
---

<objective>
Build the two core services: StateMachineService (validates and executes state transitions) and InstanceRegistryService (manages Redis key lifecycle with TTL heartbeat and atomic claims).

Purpose: These services replace the broken prototype in adapter-factory.ts. They are the core of Phase 30, implementing registration, heartbeat, one-instance-per-exchange enforcement, and state management.
Output: 2 new service files that handle all Redis instance state operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-instance-registry-and-state-machine/30-RESEARCH.md
@.planning/phases/30-instance-registry-and-state-machine/30-01-SUMMARY.md

Key source files (read these before implementing):
@apps/api/src/services/runtime-state.ts
@apps/api/src/services/types/service-registry.ts
@packages/schemas/src/network/instance-status.schema.ts
@packages/cache/src/keys.ts
@apps/api/src/utils/detect-public-ip.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StateMachineService</name>
  <files>apps/api/src/services/state-machine.service.ts</files>
  <action>
    Create `apps/api/src/services/state-machine.service.ts` with a `StateMachineService` class.

    **Constructor:**
    - Accepts an `InstanceRegistryService` instance (will be injected in Plan 03)
    - Starts in `'idle'` state
    - Uses `createLogger({ name: 'state-machine', service: 'network' })` from `@livermore/utils`

    **Properties:**
    - `private currentState: ConnectionState = 'idle'`
    - `private registry: InstanceRegistryService`
    - `private transitionHistory: Array<{ from: ConnectionState; to: ConnectionState; at: string }>` (max 50 entries, FIFO)

    **Methods:**

    1. `async transition(to: ConnectionState): Promise<void>`
       - Check `VALID_TRANSITIONS[this.currentState]` for whether `to` is allowed
       - If NOT allowed: log error with `{ from: this.currentState, to }` and throw `Error('Invalid state transition: {from} -> {to}')`
       - If allowed:
         a. Record in transitionHistory (push, then trim to last 50)
         b. Set `this.currentState = to`
         c. Call `this.registry.updateStatus({ connectionState: to, lastStateChange: new Date().toISOString() })` to update the Redis payload via KEEPTTL
         d. If `to === 'active'`: also update `connectedAt` to current ISO string
         e. Update in-memory RuntimeState for backward compatibility:
            ```typescript
            updateRuntimeState({
              connectionState: to as any,  // Old type has different values, cast needed
              connectionStateChangedAt: Date.now(),
              exchangeConnected: to === 'active',
            });
            ```
            NOTE: The old `ConnectionState` type in runtime-state.ts has values `'idle' | 'connecting' | 'connected' | 'disconnected' | 'error'`. The new type has `'idle' | 'starting' | 'warming' | 'active' | 'stopping' | 'stopped'`. For backward compat with the existing ControlPanel UI which reads `connectionState` from RuntimeState, map as follows when calling updateRuntimeState:
            - 'idle' -> 'idle'
            - 'starting' -> 'connecting'
            - 'warming' -> 'connecting'
            - 'active' -> 'connected'
            - 'stopping' -> 'disconnected'
            - 'stopped' -> 'disconnected'

            Create a private helper `mapToLegacyState(state: ConnectionState)` that returns the old ConnectionState string.

         f. Log info: `{ from, to }` "State transition"

    2. `getCurrentState(): ConnectionState` -- returns `this.currentState`

    3. `getTransitionHistory(): Array<{ from: ConnectionState; to: ConnectionState; at: string }>` -- returns copy of history array

    4. `resetToIdle(): void` -- Force-resets state to 'idle' without validation (used during error recovery / crash recovery). Logs a warning. Updates RuntimeState.

    **IMPORTANT anti-patterns to avoid:**
    - Do NOT throw in the heartbeat code path. Throwing kills the heartbeat timer. Only throw in `transition()` which is called from explicit lifecycle points.
    - Do NOT log at debug level for transitions. Transitions are important lifecycle events -- log at info level.
    - Do NOT import from `adapter-factory.ts`. That file's connection tracking is being replaced.
  </action>
  <verify>
    Run `npx tsc --noEmit -p apps/api/tsconfig.json` -- no type errors.
    Grep for `VALID_TRANSITIONS` import to confirm it uses the shared schema.
    Grep for `updateRuntimeState` to confirm backward compat wiring.
    Confirm `mapToLegacyState` helper exists for state mapping.
  </verify>
  <done>
    StateMachineService compiles. Has transition(), getCurrentState(), getTransitionHistory(), resetToIdle(). Validates transitions against VALID_TRANSITIONS. Updates both Redis (via registry) and in-memory RuntimeState with legacy state mapping.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create InstanceRegistryService</name>
  <files>apps/api/src/services/instance-registry.service.ts</files>
  <action>
    Create `apps/api/src/services/instance-registry.service.ts` with an `InstanceRegistryService` class.

    **Constructor options (passed as object):**
    ```typescript
    interface RegistryOptions {
      exchangeId: number;
      exchangeName: string;
      redis: RedisClient;  // import type from @livermore/cache
    }
    ```
    - Stores exchangeId, exchangeName, redis
    - Detects hostname via `os.hostname()` from `node:os` (REG-06)
    - Sets `ipAddress` to `null` initially (will be updated async)
    - Generates instanceId: `${hostname}:${exchangeId}:${process.pid}:${Date.now()}`
    - Sets `adminEmail` and `adminDisplayName` to `null` initially
    - Uses `createLogger({ name: 'instance-registry', service: 'network' })` from `@livermore/utils`
    - Heartbeat timer reference: `private heartbeatTimer: ReturnType<typeof setInterval> | null = null`

    **Methods:**

    1. `async register(): Promise<boolean>`
       - Build the initial InstanceStatus payload:
         ```
         {
           exchangeId, exchangeName, hostname, ipAddress: null,
           adminEmail: null, adminDisplayName: null,
           connectionState: 'idle',
           symbolCount: 0,
           connectedAt: null,
           lastHeartbeat: new Date().toISOString(),
           lastStateChange: new Date().toISOString(),
           registeredAt: new Date().toISOString(),
           lastError: null, lastErrorAt: null,
         }
         ```
       - Store as `this.currentStatus`
       - Attempt atomic claim: `redis.set(instanceStatusKey(exchangeId), JSON.stringify(payload), 'EX', HEARTBEAT_TTL_SECONDS, 'NX')`
       - If result is `'OK'`: Registration succeeded.
         - Log info: `{ exchangeId, exchangeName, hostname, instanceId }` "Instance registered"
         - Clean up old prototype key: `redis.del('exchange:status:' + exchangeId)` (one-time cleanup, see RESEARCH.md Open Question #3)
         - Start IP detection asynchronously: `detectPublicIp().then(ip => { if (ip) this.updateStatus({ ipAddress: ip }); })`
         - Start heartbeat: `this.startHeartbeat()`
         - Return `true`
       - If result is `null`: Another instance owns this exchange (LOCK-01, LOCK-02).
         - Read the existing key: `const existing = await redis.get(instanceStatusKey(exchangeId))`
         - Parse it and check if it belongs to THIS instance (same hostname + pid -- self-restart scenario per RESEARCH.md Pitfall 5):
           - If same hostname: overwrite with `SET ... EX HEARTBEAT_TTL_SECONDS XX`, start heartbeat, return `true`
           - If different hostname: throw Error with LOCK-04 message: `Exchange ${exchangeId} (${exchangeName}) is already claimed by ${owner.hostname} (${owner.ipAddress}) since ${owner.connectedAt}. Stop that instance first, or wait for TTL to expire (${ttl}s remaining).`
             - Read TTL via `redis.ttl(key)` to include in the error message.

    2. `startHeartbeat(): void`
       - If timer already running, clear it first
       - `this.heartbeatTimer = setInterval(() => this.heartbeatTick(), HEARTBEAT_INTERVAL_MS)`
       - Use `unref()` on the timer so it does not prevent Node.js from exiting

    3. `private async heartbeatTick(): Promise<void>`
       - Update `this.currentStatus.lastHeartbeat = new Date().toISOString()`
       - Write full payload with TTL refresh: `redis.set(key, JSON.stringify(this.currentStatus), 'EX', HEARTBEAT_TTL_SECONDS, 'XX')`
       - If result is `null` (key expired/deleted):
         - Log warn: "Instance key missing during heartbeat, re-registering"
         - Call `this.register()` to re-claim
       - Wrap entire body in try/catch. On error: log error but do NOT throw (anti-pattern from RESEARCH.md -- throwing kills the heartbeat loop)
       - Do NOT log at info/debug on success. Heartbeat is high-frequency (every 15s). Only log on failure.

    4. `stopHeartbeat(): void`
       - If `this.heartbeatTimer`: `clearInterval(this.heartbeatTimer)`, set to `null`

    5. `async deregister(): Promise<void>`
       - Stop heartbeat
       - Delete key: `await redis.del(instanceStatusKey(this.exchangeId))`
       - Log info: "Instance deregistered"

    6. `async updateStatus(updates: Partial<InstanceStatus>): Promise<void>`
       - Merge updates into `this.currentStatus`: `Object.assign(this.currentStatus, updates)`
       - Write to Redis preserving TTL: `redis.set(key, JSON.stringify(this.currentStatus), 'KEEPTTL')`
       - This is used by StateMachineService for state transitions and by async IP update

    7. `async getStatus(): Promise<InstanceStatus | null>`
       - Read from Redis: `redis.get(instanceStatusKey(this.exchangeId))`
       - Parse and return, or null if key missing

    8. `async recordError(error: string): Promise<void>` (FIX-02)
       - Updates `lastError` and `lastErrorAt` on currentStatus
       - Calls `updateStatus({ lastError: error, lastErrorAt: new Date().toISOString() })`
       - This fixes FIX-02: errors now always persist because we write from in-memory state, not by reading the key first (which could be null)

    9. `setAdminInfo(email: string, displayName: string): void`
       - Sets `this.currentStatus.adminEmail = email` and `this.currentStatus.adminDisplayName = displayName`
       - Does NOT write to Redis immediately. Next heartbeat tick will persist it.
       - This is called when ControlChannelService initializes with authenticated user context.

    10. `setSymbolCount(count: number): void`
        - Sets `this.currentStatus.symbolCount = count`
        - Does NOT write to Redis immediately. Next heartbeat tick will persist it.

    **IMPORTANT constraints:**
    - EVERY `redis.set()` call MUST include either `'EX', HEARTBEAT_TTL_SECONDS` or `'KEEPTTL'`. NEVER do a naked `redis.set(key, value)` which would remove the TTL. This is the root cause of FIX-03.
    - Import `HEARTBEAT_INTERVAL_MS`, `HEARTBEAT_TTL_SECONDS` from `@livermore/schemas`
    - Import `instanceStatusKey` from `@livermore/cache`
    - Import `detectPublicIp` from `../utils/detect-public-ip`
    - Import `type RedisClient` from `@livermore/cache`
    - Import `type InstanceStatus, type ConnectionState` from `@livermore/schemas`
    - Import `createLogger` from `@livermore/utils`
    - Import `hostname` from `node:os`
  </action>
  <verify>
    Run `npx tsc --noEmit -p apps/api/tsconfig.json` -- no type errors.
    Grep for `'NX'` to confirm atomic claim pattern.
    Grep for `'KEEPTTL'` to confirm status updates preserve TTL.
    Grep for `'EX'` to confirm heartbeat sets TTL.
    Grep for `'XX'` to confirm heartbeat only writes if key exists.
    Confirm there are zero naked `redis.set(key, value)` calls (no SET without EX or KEEPTTL).
    Confirm heartbeatTick wraps in try/catch and does not throw.
    Confirm `unref()` is called on the heartbeat timer.
  </verify>
  <done>
    InstanceRegistryService compiles. register() uses SET NX EX for atomic claim. Heartbeat runs every 15s with SET EX XX. Status updates use KEEPTTL. Deregister deletes key. Error recording works without reading key first (FIX-02). All SET calls include TTL (FIX-03). Self-restart detection handles Pitfall 5.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit -p apps/api/tsconfig.json` passes
- StateMachineService validates transitions against VALID_TRANSITIONS
- StateMachineService updates both Redis and in-memory RuntimeState
- InstanceRegistryService uses SET NX EX for atomic exchange claim (LOCK-02)
- InstanceRegistryService heartbeat uses SET EX XX every 15s (HB-01, HB-03)
- InstanceRegistryService conflict message includes hostname, IP, connectedAt (LOCK-04)
- InstanceRegistryService stale detection via TTL check (LOCK-03)
- No naked redis.set() calls exist (all have EX or KEEPTTL)
- Heartbeat timer uses unref() and does not throw on error
- Public IP detected asynchronously and updated via KEEPTTL
</verification>

<success_criteria>
- REG-01: Exchange-scoped status key created via register()
- REG-02: Full identity payload with all fields populated
- REG-03: 6-state machine with validated transitions
- REG-04: State transitions maintained via StateMachineService.transition()
- REG-05: Public IP detected async, updated via KEEPTTL
- REG-06: Hostname from os.hostname() in payload
- HB-01: Heartbeat refreshes TTL via SET EX XX
- HB-02: 15s interval, 45s TTL (configurable via constants)
- HB-03: lastHeartbeat ISO timestamp updated every tick
- LOCK-01: Register checks if key exists with valid TTL
- LOCK-02: Atomic SET NX EX prevents race condition
- LOCK-03: Stale lock detection (expired key means exchange available)
- LOCK-04: Conflict error includes hostname, IP, connectedAt of holder
- FIX-01: Heartbeat actually runs via setInterval (prototype never called it)
- FIX-02: Error recording works without null status check
- FIX-03: TTL on every SET prevents ghost idle instances
</success_criteria>

<output>
After completion, create `.planning/phases/30-instance-registry-and-state-machine/30-02-SUMMARY.md`
</output>
