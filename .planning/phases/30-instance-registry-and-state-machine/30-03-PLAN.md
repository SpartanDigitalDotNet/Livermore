---
phase: 30-instance-registry-and-state-machine
plan: 03
type: execute
wave: 3
depends_on: ["30-02"]
files_modified:
  - apps/api/src/services/types/service-registry.ts
  - apps/api/src/services/runtime-state.ts
  - apps/api/src/services/exchange/adapter-factory.ts
  - apps/api/src/server.ts
  - apps/api/src/services/control-channel.service.ts
autonomous: true

must_haves:
  truths:
    - "When the API starts, an exchange-scoped Redis key appears with full identity payload and 45s TTL"
    - "When the API starts in autostart mode, state progresses idle -> starting -> warming -> active with each transition visible in Redis"
    - "When a start command is received, state progresses idle -> starting -> warming -> active with one-instance-per-exchange check before starting"
    - "When a stop command is received, state goes active -> stopping -> stopped, key is deleted, state resets to idle"
    - "When the API shuts down gracefully, state goes to stopping, key is deleted"
    - "A second instance trying to start the same exchange gets an error with the first instance's hostname, IP, and connectedAt"
    - "The heartbeat timer refreshes the key TTL every 15s after the instance is registered"
    - "The old prototype connection tracking code in adapter-factory.ts is removed"
    - "Existing ControlPanel UI continues to work via getRuntimeState() backward compatibility"
  artifacts:
    - path: "apps/api/src/services/types/service-registry.ts"
      provides: "ServiceRegistry with instanceRegistry and stateMachine fields"
      contains: "instanceRegistry"
    - path: "apps/api/src/services/runtime-state.ts"
      provides: "Updated ConnectionState type with 6 states for new code paths"
      contains: "warming"
    - path: "apps/api/src/services/exchange/adapter-factory.ts"
      provides: "Clean adapter factory without connection tracking"
    - path: "apps/api/src/server.ts"
      provides: "Instance registration after pre-flight, state transitions in autostart and shutdown"
      contains: "instanceRegistry.register"
    - path: "apps/api/src/services/control-channel.service.ts"
      provides: "State machine transitions in handleStart/handleStop, one-instance check"
      contains: "stateMachine.transition"
  key_links:
    - from: "apps/api/src/server.ts"
      to: "apps/api/src/services/instance-registry.service.ts"
      via: "instantiation and register() call after pre-flight"
      pattern: "instanceRegistry\\.register"
    - from: "apps/api/src/server.ts"
      to: "apps/api/src/services/state-machine.service.ts"
      via: "instantiation and transition() calls in autostart path"
      pattern: "stateMachine\\.transition"
    - from: "apps/api/src/services/control-channel.service.ts"
      to: "apps/api/src/services/state-machine.service.ts"
      via: "transition() calls replacing updateConnectionState()"
      pattern: "stateMachine\\.transition"
    - from: "apps/api/src/services/control-channel.service.ts"
      to: "apps/api/src/services/instance-registry.service.ts"
      via: "one-instance check in handleStart, deregister in handleStop"
      pattern: "instanceRegistry\\.register|instanceRegistry\\.deregister"
    - from: "apps/api/src/server.ts"
      to: "shutdown handler"
      via: "deregister and state transition in graceful shutdown"
      pattern: "instanceRegistry\\.deregister"
---

<objective>
Wire the InstanceRegistryService and StateMachineService into the existing application lifecycle. Remove the broken prototype connection tracking from adapter-factory.ts. Update service-registry.ts and runtime-state.ts types.

Purpose: This is the integration plan that makes the new services live. After this plan, every API instance self-reports to Redis with validated state transitions, TTL heartbeat, and one-instance-per-exchange enforcement.
Output: 5 modified files -- services wired into server startup, command handlers, and shutdown.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-instance-registry-and-state-machine/30-RESEARCH.md
@.planning/phases/30-instance-registry-and-state-machine/30-01-SUMMARY.md
@.planning/phases/30-instance-registry-and-state-machine/30-02-SUMMARY.md

Key source files (read ALL of these before making changes):
@apps/api/src/server.ts
@apps/api/src/services/control-channel.service.ts
@apps/api/src/services/exchange/adapter-factory.ts
@apps/api/src/services/runtime-state.ts
@apps/api/src/services/types/service-registry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update types and clean up adapter-factory.ts</name>
  <files>
    apps/api/src/services/types/service-registry.ts
    apps/api/src/services/runtime-state.ts
    apps/api/src/services/exchange/adapter-factory.ts
  </files>
  <action>
    **Part A: Update ServiceRegistry type**

    In `apps/api/src/services/types/service-registry.ts`:
    - Add import for InstanceRegistryService and StateMachineService
    - Add two new fields to the ServiceRegistry interface:
      ```typescript
      /** Phase 30: Instance registry for Redis-backed status and heartbeat */
      instanceRegistry: InstanceRegistryService;

      /** Phase 30: State machine for validated connection state transitions */
      stateMachine: StateMachineService;
      ```
    - These are required (not optional) fields because they are created in server.ts before the registry is built.

    **Part B: Update RuntimeState ConnectionState type**

    In `apps/api/src/services/runtime-state.ts`:
    - Update the `ConnectionState` type to include the new states. Change from:
      ```typescript
      export type ConnectionState = 'idle' | 'connecting' | 'connected' | 'disconnected' | 'error';
      ```
      To:
      ```typescript
      export type ConnectionState = 'idle' | 'connecting' | 'connected' | 'disconnected' | 'error' | 'starting' | 'warming' | 'active' | 'stopping' | 'stopped';
      ```
    - This is a UNION of old and new states. The old values ('connecting', 'connected', 'disconnected', 'error') are kept for backward compatibility with the ControlPanel UI which checks for these specific strings. The new values ('starting', 'warming', 'active', 'stopping', 'stopped') are added so the StateMachineService can write them directly without casting.
    - Do NOT remove or rename any existing fields in RuntimeState interface.

    **Part C: Remove prototype connection tracking from adapter-factory.ts**

    In `apps/api/src/services/exchange/adapter-factory.ts`:
    - REMOVE the `ExchangeConnectionStatus` interface (lines ~12-19)
    - REMOVE the `connectionStatusKey()` function (lines ~24-27)
    - REMOVE the `setupConnectionTracking()` private method entirely (lines ~177-226)
    - REMOVE the `updateHeartbeat()` method (lines ~231-237)
    - REMOVE the `getConnectionStatus()` method (lines ~242-247)
    - REMOVE the `setConnectionStatus()` private method (lines ~252-259)
    - In the `create()` method: remove the call to `this.setConnectionStatus()` that writes initial idle status (lines ~117-124). The instance registry now owns initial status.
    - In `createCoinbaseAdapter()`: remove the call to `this.setupConnectionTracking(adapter, ...)` (line ~163). Connection tracking is now owned by the state machine and registry, not the adapter factory.
    - KEEP: The `create()` method (db lookup, createAdapterByType call), `createAdapterByType()`, `createCoinbaseAdapter()` (without the setupConnectionTracking call), and the `AdapterFactoryConfig` interface.
    - After cleanup, the factory should ONLY create adapters. It should not track connection state.
  </action>
  <verify>
    Run `npx tsc --noEmit -p apps/api/tsconfig.json` -- expect type errors in server.ts and control-channel.service.ts (because they reference old patterns that Plan 03 Task 2 will fix). The three files modified in this task should compile in isolation.
    Grep adapter-factory.ts for `connectionStatusKey` -- should return 0 matches.
    Grep adapter-factory.ts for `setupConnectionTracking` -- should return 0 matches.
    Grep adapter-factory.ts for `updateHeartbeat` -- should return 0 matches.
    Grep adapter-factory.ts for `ExchangeConnectionStatus` -- should return 0 matches.
    Verify ServiceRegistry has `instanceRegistry` and `stateMachine` fields.
    Verify RuntimeState ConnectionState includes both old and new states.
  </verify>
  <done>
    ServiceRegistry type has instanceRegistry and stateMachine fields. RuntimeState ConnectionState is a union of old and new states. Adapter factory is clean -- only creates adapters, no connection tracking code remains.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire services into server.ts and control-channel.service.ts</name>
  <files>
    apps/api/src/server.ts
    apps/api/src/services/control-channel.service.ts
  </files>
  <action>
    **Part A: Wire into server.ts**

    Read `server.ts` carefully before making changes. The wiring points are:

    1. **Add imports** at top of file:
       ```typescript
       import { InstanceRegistryService } from './services/instance-registry.service';
       import { StateMachineService } from './services/state-machine.service';
       ```

    2. **After pre-flight checks pass** (after "Pre-flight checks passed" log, around line ~239):
       - Create InstanceRegistryService:
         ```typescript
         const instanceRegistry = new InstanceRegistryService({
           exchangeId: activeExchangeId ?? 0,  // 0 means no exchange yet (idle mode)
           exchangeName: activeExchangeName ?? 'unknown',
           redis,
         });
         ```
       - Create StateMachineService:
         ```typescript
         const stateMachine = new StateMachineService(instanceRegistry);
         ```
       - Register only if we have an active exchange (autostart mode):
         ```typescript
         if (isAutostart && activeExchangeId) {
           const registered = await instanceRegistry.register();
           if (!registered) {
             logger.error({ exchangeId: activeExchangeId }, 'Failed to register instance -- another instance may be running');
             process.exit(1);
           }
           await stateMachine.transition('starting');
         }
         ```

    3. **In the autostart block** (where services are started, around lines 376-421):
       - After backfill completes, before indicator service starts: `await stateMachine.transition('warming');`
       - After all services are started (after alertService.start), before initRuntimeState: `await stateMachine.transition('active');`
       - Update the `initRuntimeState` calls to also set the new state. The existing initRuntimeState calls should remain as-is for backward compat, but add symbolCount update:
         ```typescript
         instanceRegistry.setSymbolCount(monitoredSymbols.length);
         ```
       - In the idle (non-autostart) block: do NOT register yet. Registration happens when `handleStart()` is called.

    4. **In the ServiceRegistry construction** (around line 436):
       - Add `instanceRegistry` and `stateMachine` to the registry object:
         ```typescript
         instanceRegistry,
         stateMachine,
         ```

    5. **In the graceful shutdown handler** (around line 485):
       - BEFORE stopping services, transition state and deregister:
         ```typescript
         // Phase 30: Graceful shutdown -- signal stopping state, then deregister
         try {
           await stateMachine.transition('stopping');
         } catch { /* may fail if already stopped */ }
         ```
       - AFTER stopping all services (after subscriberRedis.quit), BEFORE redis.quit:
         ```typescript
         await instanceRegistry.deregister();
         ```

    **Part B: Wire into control-channel.service.ts**

    Read `control-channel.service.ts` carefully. The changes are in `handleStart()` and `handleStop()`:

    1. **Add access to new services**: The services are available via `this.services.instanceRegistry` and `this.services.stateMachine`.

    2. **In handleStart()** (around line 418):
       - BEFORE any exchange work begins (before "Loading Tier 1 symbols"), add one-instance-per-exchange check:
         ```typescript
         // Phase 30: Register instance for this exchange (atomic claim)
         // First, update the registry with the correct exchange info if needed
         const exchangeId = this.services.exchangeId;
         if (exchangeId) {
           // Re-initialize registry with correct exchange if it was created with placeholder
           // The registry was created in server.ts possibly with exchangeId=0 for idle mode
           // We need to create a new registry with the actual exchange ID
           // NOTE: InstanceRegistryService is immutable for exchangeId after construction.
           // For idle-mode start, server.ts created it with exchangeId=0.
           // We need to handle this. Options:
           // a) Create a new InstanceRegistryService here (simple but wasteful)
           // b) Add a setExchange() method to InstanceRegistryService
           // Choose (a) for now -- create new registry with correct exchange, replace on services
         }
         ```

         Actually, the simpler approach: In `handleStart()`, if `this.services.exchangeId` is now set (after resolving from user_exchanges), create a fresh InstanceRegistryService with the correct exchangeId and replace it on the services object. Then register:
         ```typescript
         // Phase 30: Create registry for this exchange and attempt atomic claim
         const registry = new InstanceRegistryService({
           exchangeId: this.services.exchangeId!,
           exchangeName: userExchange.exchangeName,
           redis: this.services.redis,
         });
         this.services.instanceRegistry = registry;
         this.services.stateMachine = new StateMachineService(registry);

         const registered = await registry.register();
         if (!registered) {
           // This should not happen since register() throws on conflict,
           // but handle defensively
           throw new Error('Failed to register instance');
         }

         await this.services.stateMachine.transition('starting');
         ```

         Place this AFTER the exchange ID is resolved from user_exchanges (after `this.services.exchangeId = userExchange.exchangeId`) but BEFORE backfill starts.

       - After backfill, before indicator service start: `await this.services.stateMachine.transition('warming');`

       - After ALL services started (after alertService.start): `await this.services.stateMachine.transition('active');`

       - Update symbol count: `this.services.instanceRegistry.setSymbolCount(this.services.monitoredSymbols.length);`

       - REMOVE the existing `this.updateConnectionState('connecting');` call at the start of handleStart
       - REMOVE the existing `this.updateConnectionState('connected');` call after services start
       - REMOVE the existing `this.updateConnectionState('error', errorMessage);` call in the catch block
       - In the catch block, REPLACE with:
         ```typescript
         // Record error on registry
         if (this.services.instanceRegistry) {
           await this.services.instanceRegistry.recordError(errorMessage);
         }
         // Reset state machine to idle for retry
         this.services.stateMachine.resetToIdle();
         ```

    3. **In handleStop()** (around line 600):
       - BEFORE stopping services: `await this.services.stateMachine.transition('stopping');`
       - AFTER all services stopped: `await this.services.stateMachine.transition('stopped');`
       - Then deregister: `await this.services.instanceRegistry.deregister();`
       - Then reset to idle: `this.services.stateMachine.resetToIdle();`
       - REMOVE the existing `this.updateConnectionState('idle');` call

    4. **Remove or gut the `updateConnectionState` method**:
       - The private `updateConnectionState()` method (around line 648) is now replaced by the state machine. However, it may still be called from handlePause/handleResume. Check:
         - `handlePause` does NOT call updateConnectionState (it calls updateRuntimeState directly). Leave it.
         - `handleResume` does NOT call updateConnectionState. Leave it.
       - Since handleStart/handleStop were the only callers of updateConnectionState, and those now use the state machine, the `updateConnectionState` private method can be removed entirely.
       - Also remove the `setIdleState` public method (line ~663) -- no longer needed. If anything calls it, replace the call with `this.services.stateMachine.resetToIdle()`.

    5. **Update admin info when control channel initializes**:
       - In `initControlChannelService()` in server.ts, after the ControlChannelService is created and started, set admin info on the registry. However, we don't have the user's email/name from just the clerkUserId. For now, set the clerkUserId as the admin identifier:
         ```typescript
         if (globalServiceRegistry?.instanceRegistry) {
           globalServiceRegistry.instanceRegistry.setAdminInfo(clerkUserId, clerkUserId);
         }
         ```
       - This will be replaced with actual email/displayName when the user's profile is loaded. For Phase 30, the clerkUserId is sufficient to identify the admin.

    **IMPORTANT: Preserve backward compatibility**
    - `getRuntimeState()` must continue returning valid data for the existing `control.getStatus` tRPC endpoint
    - The ControlPanel UI reads `connectionState` from RuntimeState -- StateMachineService's `mapToLegacyState()` handles the mapping
    - Do NOT change the handlePause/handleResume implementations -- they update RuntimeState directly and that is fine
    - Do NOT modify any command handlers other than handleStart and handleStop
    - The import of `ConnectionState` from `./runtime-state` in control-channel.service.ts is no longer needed for updateConnectionState. Remove it if the only usage was that method. Keep it if used elsewhere in the file.
  </action>
  <verify>
    Run `npx tsc --noEmit -p apps/api/tsconfig.json` -- no type errors.
    Grep server.ts for `instanceRegistry.register` -- should find 1 match (autostart path).
    Grep server.ts for `stateMachine.transition` -- should find matches for 'starting', 'warming', 'active', 'stopping'.
    Grep server.ts for `instanceRegistry.deregister` -- should find 1 match (shutdown).
    Grep control-channel.service.ts for `stateMachine.transition` -- should find matches in handleStart and handleStop.
    Grep control-channel.service.ts for `instanceRegistry.register` -- should find 1 match (handleStart).
    Grep control-channel.service.ts for `instanceRegistry.deregister` -- should find 1 match (handleStop).
    Grep control-channel.service.ts for `updateConnectionState` -- should find 0 matches (method removed).
    Grep control-channel.service.ts for `setupConnectionTracking` -- should find 0 matches.
    Verify that `getRuntimeState()` still works (it's a simple getter, should be unchanged).
  </verify>
  <done>
    Instance registry registers after pre-flight (autostart) or on start command (idle mode). State machine transitions at each lifecycle phase. Shutdown deregisters cleanly. One-instance-per-exchange enforced in handleStart. Old connection tracking removed. ControlPanel backward compatibility preserved via legacy state mapping.
  </done>
</task>

</tasks>

<verification>
Full integration test (manual):
1. Start API with `--autostart coinbase`:
   - Redis key `exchange:1:status` exists with TTL ~45s
   - Key contains full identity payload (hostname, connectionState: 'active', etc.)
   - Key TTL refreshes every 15s (check with `TTL exchange:1:status`)
2. Start a SECOND instance with same exchange:
   - Should fail with error message containing hostname and IP of first instance
3. Send "stop" command from Admin UI:
   - State transitions: active -> stopping -> stopped
   - Key is deleted
   - State resets to idle
4. Send "start" command from Admin UI:
   - One-instance check passes (key was deleted)
   - State transitions: idle -> starting -> warming -> active
   - New key appears with TTL
5. Kill the process (Ctrl+C):
   - Graceful shutdown: state -> stopping, key deleted
6. Kill the process (kill -9):
   - Key expires after 45s (TTL-based dead instance detection)
7. Old prototype key `exchange:status:1` should be cleaned up on first registration

Code verification:
- `npx tsc --noEmit -p apps/api/tsconfig.json` passes
- Zero references to old `connectionStatusKey` function
- Zero references to `setupConnectionTracking`
- Zero references to `ExchangeConnectionStatus` interface
- Zero naked `redis.set()` calls without EX or KEEPTTL in the new services
</verification>

<success_criteria>
All 17 Phase 30 requirements delivered:
- REG-01: exchange:{id}:status key appears on start
- REG-02: Full identity payload in key
- REG-03: 6-state machine with validated transitions
- REG-04: State maintained at each lifecycle phase (start, warmup, active, stop, shutdown)
- REG-05: Public IP detected async and written to payload
- REG-06: Hostname in payload via os.hostname()
- HB-01: Heartbeat refreshes TTL periodically via SET EX XX
- HB-02: 15s interval, 45s TTL
- HB-03: lastHeartbeat timestamp updated every tick
- HB-04: Graceful shutdown transitions to stopping, deregisters
- LOCK-01: Check if key exists before registering
- LOCK-02: Atomic SET NX EX prevents race
- LOCK-03: Expired key (TTL gone) means exchange available
- LOCK-04: Conflict error includes hostname, IP, connectedAt
- FIX-01: Heartbeat runs via setInterval (was never called in prototype)
- FIX-02: Error persists via recordError() without null check
- FIX-03: TTL on all SET calls prevents ghost idle instances
</success_criteria>

<output>
After completion, create `.planning/phases/30-instance-registry-and-state-machine/30-03-SUMMARY.md`
</output>
