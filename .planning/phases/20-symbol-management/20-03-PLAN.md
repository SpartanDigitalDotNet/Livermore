---
phase: 20-symbol-management
plan: 03
type: execute
wave: 3
depends_on: ["20-01", "20-02"]
files_modified:
  - apps/api/src/routers/symbol.router.ts
  - apps/api/src/services/control-channel.service.ts
autonomous: true

must_haves:
  truths:
    - "User can submit array of symbols for bulk validation"
    - "Bulk validation shows valid/invalid/duplicate status for each symbol"
    - "Bulk add command adds all valid symbols that are not duplicates"
    - "Validation results include metrics for valid symbols"
  artifacts:
    - path: "apps/api/src/routers/symbol.router.ts"
      provides: "bulkValidate endpoint"
      contains: "bulkValidate"
    - path: "apps/api/src/services/control-channel.service.ts"
      provides: "handleBulkAddSymbols handler"
      contains: "handleBulkAddSymbols"
  key_links:
    - from: "apps/api/src/routers/symbol.router.ts"
      to: "CoinbaseRestClient.getProduct"
      via: "Sequential validation with rate limit delay"
      pattern: "getProduct.*setTimeout"
---

<objective>
Implement bulk symbol import validation and command

Purpose: Enable users to paste a JSON array of symbols and see validation results for each (valid, invalid, or duplicate), then add all valid non-duplicate symbols in one operation.

Output: bulkValidate endpoint in symbol.router.ts and bulk-add-symbols handler in ControlChannelService
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-symbol-management/20-RESEARCH.md
@.planning/phases/20-symbol-management/20-01-SUMMARY.md
@.planning/phases/20-symbol-management/20-02-SUMMARY.md
@apps/api/src/routers/symbol.router.ts
@apps/api/src/services/control-channel.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add bulkValidate endpoint to symbol.router.ts</name>
  <files>apps/api/src/routers/symbol.router.ts</files>
  <action>
Add `bulkValidate` endpoint to symbol.router.ts (SYM-05, delta-based validation SYM-03):

```typescript
/**
 * POST /symbol.bulkValidate
 *
 * Validate multiple symbols for bulk import.
 * Returns validation status for each: valid, invalid, or duplicate.
 * Implements delta-based validation - skips symbols already in user's list.
 *
 * Requirement: SYM-05 (bulk import), SYM-03 (delta validation)
 */
bulkValidate: protectedProcedure
  .input(z.object({
    symbols: z.array(z.string()).min(1).max(50),
  }))
  .query(async ({ ctx, input }) => {
    const db = getDbClient();
    const clerkId = ctx.auth.userId;

    // Get user's current symbols for delta calculation
    const [user] = await db
      .select({ settings: users.settings })
      .from(users)
      .where(
        and(
          eq(users.identityProvider, 'clerk'),
          eq(users.identitySub, clerkId)
        )
      )
      .limit(1);

    if (!user) {
      throw new TRPCError({
        code: 'NOT_FOUND',
        message: 'User not found',
      });
    }

    const existing = new Set<string>((user.settings as any)?.symbols ?? []);

    // Get Coinbase client
    const apiKeyId = process.env.COINBASE_API_KEY_ID;
    const privateKey = process.env.COINBASE_PRIVATE_KEY?.replace(/\\n/g, '\n');

    if (!apiKeyId || !privateKey) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Exchange credentials not configured',
      });
    }

    const client = new CoinbaseRestClient(apiKeyId, privateKey);

    // Validate each symbol
    type ValidationResult = {
      symbol: string;
      status: 'valid' | 'invalid' | 'duplicate';
      metrics?: {
        price: string;
        volume24h: string;
        priceChange24h: string;
        baseName: string;
        quoteName: string;
      };
      error?: string;
    };

    const results: ValidationResult[] = [];

    for (const rawSymbol of input.symbols) {
      const symbol = normalizeSymbol(rawSymbol);

      // Check duplicates first (no API call needed)
      if (existing.has(symbol)) {
        results.push({ symbol, status: 'duplicate' });
        continue;
      }

      // Validate against exchange
      try {
        const product = await client.getProduct(symbol);

        if (product.trading_disabled || product.status !== 'online') {
          results.push({
            symbol,
            status: 'invalid',
            error: 'Symbol not available for trading',
          });
        } else {
          results.push({
            symbol,
            status: 'valid',
            metrics: {
              price: product.price || '0',
              volume24h: product.volume_24h || '0',
              priceChange24h: product.price_percentage_change_24h || '0',
              baseName: product.base_name || '',
              quoteName: product.quote_name || '',
            },
          });
        }
      } catch {
        results.push({
          symbol,
          status: 'invalid',
          error: 'Symbol not found on exchange',
        });
      }

      // Rate limit: 100ms delay between API calls (safe for 10 req/sec limit)
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    return {
      results,
      summary: {
        valid: results.filter(r => r.status === 'valid').length,
        invalid: results.filter(r => r.status === 'invalid').length,
        duplicate: results.filter(r => r.status === 'duplicate').length,
        total: results.length,
      },
    };
  }),
```

Add required imports if not present:
```typescript
import { getDbClient, users } from '@livermore/database';
import { eq, and } from 'drizzle-orm';
```
  </action>
  <verify>
TypeScript compiles: `cd apps/api && pnpm tsc --noEmit`
  </verify>
  <done>
bulkValidate endpoint validates up to 50 symbols with delta-based duplicate detection
  </done>
</task>

<task type="auto">
  <name>Task 2: Add bulk-add-symbols command handler</name>
  <files>apps/api/src/services/control-channel.service.ts</files>
  <action>
Add `bulk-add-symbols` command type and handler to ControlChannelService:

1. Add to PRIORITY map (after 'remove-symbol'):
```typescript
'bulk-add-symbols': 15,
```

2. Add case to executeCommand switch:
```typescript
case 'bulk-add-symbols':
  return this.handleBulkAddSymbols(payload);
```

3. Add handler method:
```typescript
/**
 * Handle bulk-add-symbols command (SYM-05)
 * Adds multiple validated symbols in one operation
 *
 * Payload:
 * - symbols: string[] (required) - Array of pre-validated symbols
 *
 * Note: Validation should happen in Admin UI via bulkValidate endpoint.
 * This handler assumes symbols are already validated.
 */
private async handleBulkAddSymbols(payload?: Record<string, unknown>): Promise<Record<string, unknown>> {
  if (!this.services) {
    throw new Error('Services not initialized');
  }

  const symbols = payload?.symbols as string[];
  if (!symbols || !Array.isArray(symbols) || symbols.length === 0) {
    throw new Error('symbols array is required in payload');
  }

  // Normalize all symbols
  const normalizedSymbols = symbols.map(s => s.toUpperCase().trim());

  logger.info({ count: normalizedSymbols.length }, 'Bulk adding symbols to watchlist');

  // 1. Get current symbols from database
  const result = await this.services.db
    .select({ settings: users.settings })
    .from(users)
    .where(
      and(
        eq(users.identityProvider, 'clerk'),
        eq(users.identitySub, this.identitySub)
      )
    )
    .limit(1);

  if (result.length === 0) {
    throw new Error(`User not found: ${this.identitySub}`);
  }

  const currentSymbols: string[] = (result[0].settings as any)?.symbols ?? [];
  const existingSet = new Set(currentSymbols);

  // Filter out duplicates
  const toAdd = normalizedSymbols.filter(s => !existingSet.has(s));

  if (toAdd.length === 0) {
    return {
      added: 0,
      skipped: normalizedSymbols.length,
      message: 'All symbols already in watchlist',
      totalSymbols: this.services.monitoredSymbols.length,
    };
  }

  // 2. Update database with all new symbols at once
  const newSymbols = [...currentSymbols, ...toAdd];
  await this.services.db.execute(sql`
    UPDATE users
    SET settings = jsonb_set(
      COALESCE(settings, '{}'),
      '{symbols}',
      ${JSON.stringify(newSymbols)}::jsonb,
      true
    ),
    updated_at = NOW()
    WHERE identity_provider = 'clerk' AND identity_sub = ${this.identitySub}
  `);

  // 3. Update in-memory list
  this.services.monitoredSymbols.push(...toAdd);

  // 4. If not paused, initialize monitoring for new symbols
  const addedResults: Array<{ symbol: string; backfilled: boolean }> = [];

  if (!this.isPaused) {
    // Backfill all new symbols
    const backfillService = new StartupBackfillService(
      this.services.config.apiKeyId,
      this.services.config.privateKeyPem,
      this.services.redis
    );
    await backfillService.backfill(toAdd, this.services.timeframes);

    // Add indicator configs for all new symbols
    for (const symbol of toAdd) {
      const newConfigs = this.services.timeframes.map(tf => ({
        symbol,
        timeframe: tf
      }));
      this.services.indicatorConfigs.push(...newConfigs);

      // Force indicator calculation
      for (const tf of this.services.timeframes) {
        await this.services.indicatorService.forceRecalculate(symbol, tf);
      }

      addedResults.push({ symbol, backfilled: true });
    }

    // Resubscribe WebSocket with all symbols
    this.services.coinbaseAdapter.subscribe(this.services.monitoredSymbols, '5m');
  } else {
    // Not paused - just record without backfill
    for (const symbol of toAdd) {
      addedResults.push({ symbol, backfilled: false });
    }
  }

  logger.info(
    { added: toAdd.length, skipped: normalizedSymbols.length - toAdd.length, total: this.services.monitoredSymbols.length },
    'Bulk add symbols complete'
  );

  return {
    added: toAdd.length,
    skipped: normalizedSymbols.length - toAdd.length,
    symbols: addedResults,
    totalSymbols: this.services.monitoredSymbols.length,
    timestamp: Date.now(),
  };
}
```

4. Update CommandTypeSchema in packages/schemas if needed - but check first if 'bulk-add-symbols' needs to be added there.
  </action>
  <verify>
TypeScript compiles: `cd apps/api && pnpm tsc --noEmit`
  </verify>
  <done>
bulk-add-symbols handler adds multiple symbols atomically with backfill
  </done>
</task>

<task type="auto">
  <name>Task 3: Add bulk-add-symbols to CommandTypeSchema</name>
  <files>packages/schemas/src/control/command.schema.ts</files>
  <action>
Check packages/schemas/src/control/command.schema.ts for CommandTypeSchema and add 'bulk-add-symbols' if not present.

The schema likely looks like:
```typescript
export const CommandTypeSchema = z.enum([
  'pause',
  'resume',
  'reload-settings',
  'switch-mode',
  'force-backfill',
  'clear-cache',
  'add-symbol',
  'remove-symbol',
]);
```

Add 'bulk-add-symbols' to this list.
  </action>
  <verify>
TypeScript compiles across workspace: `pnpm -r tsc --noEmit` or `cd packages/schemas && pnpm tsc --noEmit`
  </verify>
  <done>
'bulk-add-symbols' added to CommandTypeSchema, all TypeScript compiles
  </done>
</task>

</tasks>

<verification>
- [ ] bulkValidate endpoint in symbol.router.ts accepts array of symbols
- [ ] bulkValidate returns { results: [...], summary: {...} }
- [ ] Each result has status: 'valid' | 'invalid' | 'duplicate'
- [ ] Valid results include metrics (price, volume, change)
- [ ] bulk-add-symbols handler in control-channel.service.ts
- [ ] bulk-add-symbols filters duplicates and adds only new symbols
- [ ] bulk-add-symbols triggers backfill when not paused
- [ ] CommandTypeSchema includes 'bulk-add-symbols'
- [ ] TypeScript compiles: `pnpm -r tsc --noEmit`
</verification>

<success_criteria>
1. User can submit up to 50 symbols for bulk validation
2. Validation shows valid/invalid/duplicate for each symbol
3. Valid symbols include metrics preview (price, volume, 24h change)
4. bulk-add-symbols command adds all valid non-duplicate symbols atomically
5. Backfill runs for all new symbols before live subscription
</success_criteria>

<output>
After completion, create `.planning/phases/20-symbol-management/20-03-SUMMARY.md`
</output>
