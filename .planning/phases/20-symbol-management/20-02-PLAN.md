---
phase: 20-symbol-management
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - apps/api/src/services/control-channel.service.ts
  - apps/api/src/services/types/service-registry.ts
autonomous: true

must_haves:
  truths:
    - "add-symbol command adds symbol to user settings and starts monitoring within 30s"
    - "remove-symbol command removes symbol from settings and cleans up Redis cache"
    - "Adding a symbol triggers backfill before live subscription"
    - "Removing a symbol deletes all cached candles/indicators for that symbol"
  artifacts:
    - path: "apps/api/src/services/control-channel.service.ts"
      provides: "handleAddSymbol and handleRemoveSymbol implementations"
      contains: "handleAddSymbol"
    - path: "apps/api/src/services/types/service-registry.ts"
      provides: "Extended service methods for incremental add/remove"
      exports: ["ServiceRegistry"]
  key_links:
    - from: "apps/api/src/services/control-channel.service.ts"
      to: "users.settings"
      via: "jsonb_set for symbols array"
      pattern: "jsonb_set.*symbols"
    - from: "apps/api/src/services/control-channel.service.ts"
      to: "StartupBackfillService"
      via: "backfill for new symbol"
      pattern: "backfillService\\.backfill"
---

<objective>
Implement add-symbol and remove-symbol command handlers

Purpose: Enable API to dynamically add/remove symbols from user's watchlist via Redis pub/sub commands, with proper database persistence, cache backfill, and service updates.

Output: Working handleAddSymbol and handleRemoveSymbol methods in ControlChannelService
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-symbol-management/20-RESEARCH.md
@.planning/phases/20-symbol-management/20-01-SUMMARY.md
@apps/api/src/services/control-channel.service.ts
@apps/api/src/services/types/service-registry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement handleAddSymbol command handler</name>
  <files>apps/api/src/services/control-channel.service.ts</files>
  <action>
Replace the stub `handleAddSymbol` method with full implementation (SYM-01):

```typescript
/**
 * Handle add-symbol command (SYM-01)
 * Adds symbol to user's watchlist and starts monitoring
 *
 * Payload:
 * - symbol: string (required) - e.g., "SOL-USD"
 */
private async handleAddSymbol(payload?: Record<string, unknown>): Promise<Record<string, unknown>> {
  if (!this.services) {
    throw new Error('Services not initialized');
  }

  const symbol = payload?.symbol as string;
  if (!symbol) {
    throw new Error('symbol is required in payload');
  }

  // Normalize symbol format
  const normalizedSymbol = symbol.toUpperCase().trim();

  logger.info({ symbol: normalizedSymbol }, 'Adding symbol to watchlist');

  // 1. Get current symbols from database
  const result = await this.services.db
    .select({ settings: users.settings })
    .from(users)
    .where(
      and(
        eq(users.identityProvider, 'clerk'),
        eq(users.identitySub, this.identitySub)
      )
    )
    .limit(1);

  if (result.length === 0) {
    throw new Error(`User not found: ${this.identitySub}`);
  }

  const currentSymbols: string[] = (result[0].settings as any)?.symbols ?? [];

  // 2. Check if already exists
  if (currentSymbols.includes(normalizedSymbol)) {
    logger.info({ symbol: normalizedSymbol }, 'Symbol already in watchlist');
    return {
      status: 'already_exists',
      symbol: normalizedSymbol,
      message: 'Symbol is already in your watchlist',
    };
  }

  // 3. Update database (atomic JSONB operation)
  const newSymbols = [...currentSymbols, normalizedSymbol];
  await this.services.db.execute(sql`
    UPDATE users
    SET settings = jsonb_set(
      COALESCE(settings, '{}'),
      '{symbols}',
      ${JSON.stringify(newSymbols)}::jsonb,
      true
    ),
    updated_at = NOW()
    WHERE identity_provider = 'clerk' AND identity_sub = ${this.identitySub}
  `);

  // 4. Update in-memory list
  this.services.monitoredSymbols.push(normalizedSymbol);

  // 5. If not paused, start monitoring the new symbol
  if (!this.isPaused) {
    // 5a. Backfill historical data first
    const backfillService = new StartupBackfillService(
      this.services.config.apiKeyId,
      this.services.config.privateKeyPem,
      this.services.redis
    );
    await backfillService.backfill([normalizedSymbol], this.services.timeframes);

    // 5b. Add indicator configs
    const newConfigs = this.services.timeframes.map(tf => ({
      symbol: normalizedSymbol,
      timeframe: tf
    }));
    this.services.indicatorConfigs.push(...newConfigs);

    // 5c. Force indicator calculation from backfilled data
    for (const tf of this.services.timeframes) {
      await this.services.indicatorService.forceRecalculate(normalizedSymbol, tf);
    }

    // 5d. Resubscribe WebSocket with updated symbol list
    this.services.coinbaseAdapter.subscribe(this.services.monitoredSymbols, '5m');
  }

  logger.info(
    { symbol: normalizedSymbol, totalSymbols: this.services.monitoredSymbols.length },
    'Symbol added to watchlist'
  );

  return {
    added: true,
    symbol: normalizedSymbol,
    totalSymbols: this.services.monitoredSymbols.length,
    backfilled: !this.isPaused,
    timestamp: Date.now(),
  };
}
```

Add required import at top of file:
```typescript
import { sql } from 'drizzle-orm';
```

Note: `sql` should already be available from existing imports. Check and add if missing.
  </action>
  <verify>
TypeScript compiles: `cd apps/api && pnpm tsc --noEmit`
  </verify>
  <done>
handleAddSymbol implemented with database update, backfill, and service subscription
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement handleRemoveSymbol command handler</name>
  <files>apps/api/src/services/control-channel.service.ts</files>
  <action>
Replace the stub `handleRemoveSymbol` method with full implementation (SYM-02):

```typescript
/**
 * Handle remove-symbol command (SYM-02)
 * Removes symbol from watchlist and cleans up cache
 *
 * Payload:
 * - symbol: string (required) - e.g., "SOL-USD"
 */
private async handleRemoveSymbol(payload?: Record<string, unknown>): Promise<Record<string, unknown>> {
  if (!this.services) {
    throw new Error('Services not initialized');
  }

  const symbol = payload?.symbol as string;
  if (!symbol) {
    throw new Error('symbol is required in payload');
  }

  const normalizedSymbol = symbol.toUpperCase().trim();

  logger.info({ symbol: normalizedSymbol }, 'Removing symbol from watchlist');

  // 1. Get current symbols
  const result = await this.services.db
    .select({ settings: users.settings })
    .from(users)
    .where(
      and(
        eq(users.identityProvider, 'clerk'),
        eq(users.identitySub, this.identitySub)
      )
    )
    .limit(1);

  if (result.length === 0) {
    throw new Error(`User not found: ${this.identitySub}`);
  }

  const currentSymbols: string[] = (result[0].settings as any)?.symbols ?? [];

  // 2. Check if exists
  if (!currentSymbols.includes(normalizedSymbol)) {
    return {
      status: 'not_found',
      symbol: normalizedSymbol,
      message: 'Symbol not in watchlist',
    };
  }

  // 3. Update database
  const newSymbols = currentSymbols.filter(s => s !== normalizedSymbol);
  await this.services.db.execute(sql`
    UPDATE users
    SET settings = jsonb_set(
      COALESCE(settings, '{}'),
      '{symbols}',
      ${JSON.stringify(newSymbols)}::jsonb,
      true
    ),
    updated_at = NOW()
    WHERE identity_provider = 'clerk' AND identity_sub = ${this.identitySub}
  `);

  // 4. Update in-memory list
  const idx = this.services.monitoredSymbols.indexOf(normalizedSymbol);
  if (idx > -1) {
    this.services.monitoredSymbols.splice(idx, 1);
  }

  // 5. Clean up Redis cache for removed symbol
  await this.cleanupSymbolCache(normalizedSymbol);

  // 6. If not paused, update running services
  if (!this.isPaused) {
    // Remove from indicator configs
    this.services.indicatorConfigs = this.services.indicatorConfigs.filter(
      c => c.symbol !== normalizedSymbol
    );

    // Resubscribe WebSocket without removed symbol
    // (CoinbaseAdapter handles unsubscribe internally when new list doesn't include symbol)
    this.services.coinbaseAdapter.subscribe(this.services.monitoredSymbols, '5m');
  }

  logger.info(
    { symbol: normalizedSymbol, totalSymbols: this.services.monitoredSymbols.length },
    'Symbol removed from watchlist'
  );

  return {
    removed: true,
    symbol: normalizedSymbol,
    totalSymbols: this.services.monitoredSymbols.length,
    timestamp: Date.now(),
  };
}

/**
 * Clean up Redis cache for a removed symbol
 * Deletes ticker, candles, and indicator keys
 */
private async cleanupSymbolCache(symbol: string): Promise<void> {
  // Hardcoded userId/exchangeId - will be dynamic in multi-user
  const userId = 1;
  const exchangeId = 1;
  const keysToDelete: string[] = [];

  // Ticker key
  keysToDelete.push(`ticker:${userId}:${exchangeId}:${symbol}`);

  // Candle and indicator keys for all timeframes
  for (const tf of this.services!.timeframes) {
    keysToDelete.push(`candles:${userId}:${exchangeId}:${symbol}:${tf}`);
    keysToDelete.push(`indicator:${userId}:${exchangeId}:${symbol}:${tf}:macd-v`);
  }

  if (keysToDelete.length > 0) {
    const deleted = await this.services!.redis.del(...keysToDelete);
    logger.debug({ symbol, keysDeleted: deleted }, 'Cleaned up symbol cache');
  }
}
```
  </action>
  <verify>
TypeScript compiles: `cd apps/api && pnpm tsc --noEmit`
  </verify>
  <done>
handleRemoveSymbol implemented with database update, cache cleanup, and service update
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify sql import and test compilation</name>
  <files>apps/api/src/services/control-channel.service.ts</files>
  <action>
Ensure all required imports are present at top of control-channel.service.ts:

1. Check if `sql` is imported from 'drizzle-orm'. If not, update the existing drizzle import:
   ```typescript
   import { eq, and, sql } from 'drizzle-orm';
   ```

2. Verify StartupBackfillService is imported (should already be from force-backfill implementation)

3. Run full type check to verify no errors
  </action>
  <verify>
TypeScript compiles without errors: `cd apps/api && pnpm tsc --noEmit`
Verify imports are correct by checking for any "Cannot find name 'sql'" errors
  </verify>
  <done>
All imports present, TypeScript compiles cleanly, add-symbol and remove-symbol handlers complete
  </done>
</task>

</tasks>

<verification>
- [ ] handleAddSymbol updates database via jsonb_set
- [ ] handleAddSymbol triggers backfill before adding to live subscription
- [ ] handleAddSymbol adds indicator configs for all timeframes
- [ ] handleRemoveSymbol updates database to remove symbol
- [ ] handleRemoveSymbol cleans up Redis cache (ticker, candles, indicators)
- [ ] handleRemoveSymbol removes from indicatorConfigs
- [ ] Both handlers update in-memory monitoredSymbols array
- [ ] TypeScript compiles: `cd apps/api && pnpm tsc --noEmit`
</verification>

<success_criteria>
1. add-symbol command persists new symbol to users.settings.symbols JSONB array
2. add-symbol triggers backfill and indicator calculation when not paused
3. remove-symbol removes symbol from database and cleans up all Redis keys
4. Both commands update in-memory arrays for running services
5. Changes persist across API restarts (database is source of truth)
</success_criteria>

<output>
After completion, create `.planning/phases/20-symbol-management/20-02-SUMMARY.md`
</output>
