---
phase: 37-admin-ui-connect-setup-warmup
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/routers/exchange-symbol.router.ts
  - apps/admin/src/components/exchange/ExchangeSetupModal.tsx
autonomous: true
must_haves:
  truths:
    - "Admin can update API key env var names and display name for an existing user_exchanges record"
    - "Setting a new exchange as default automatically unsets the previous default for that user"
    - "Exchange Setup Modal supports both create (new exchange) and edit (existing exchange) modes"
  artifacts:
    - path: "apps/api/src/routers/exchange-symbol.router.ts"
      provides: "updateExchange mutation with is_default orchestration"
      contains: "updateExchange"
    - path: "apps/admin/src/components/exchange/ExchangeSetupModal.tsx"
      provides: "Enhanced modal with edit mode for existing records"
      min_lines: 100
  key_links:
    - from: "apps/admin/src/components/exchange/ExchangeSetupModal.tsx"
      to: "exchangeSymbol.updateExchange"
      via: "tRPC mutation for updating existing exchange config"
      pattern: "updateExchange\\.mutate"
    - from: "apps/api/src/routers/exchange-symbol.router.ts"
      to: "userExchanges table"
      via: "Drizzle ORM update with is_default orchestration"
      pattern: "db\\.update\\(userExchanges\\)"
---

<objective>
Add the ability to update existing user_exchanges records (API key env var names, display name) and implement is_active/is_default orchestration so that setting a new default exchange automatically unsets the previous default for that user.

Purpose: ADM-03 and ADM-04 -- Exchange Setup Modal supports both creating and updating exchange configurations with correct default orchestration.
Output: updateExchange tRPC mutation and enhanced ExchangeSetupModal with edit mode.
</objective>

<execution_context>
@C:/Users/Mike McWilliams/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Mike McWilliams/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/api/src/routers/exchange-symbol.router.ts
@apps/admin/src/components/exchange/ExchangeSetupModal.tsx
@packages/database/src/schema/user-exchanges.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add updateExchange mutation with is_default orchestration</name>
  <files>apps/api/src/routers/exchange-symbol.router.ts</files>
  <action>
Add a new `updateExchange` mutation to the `exchangeSymbolRouter` in `apps/api/src/routers/exchange-symbol.router.ts`.

**Input schema:**
```typescript
z.object({
  exchangeName: z.string().min(1),
  apiKeyEnvVar: z.string().min(1).optional(),
  apiSecretEnvVar: z.string().min(1).optional(),
  displayName: z.string().max(100).optional(),
  isDefault: z.boolean().optional(),
})
```

**Implementation:**
1. Look up the user from Clerk identity (same pattern as `setupExchange` -- get clerkId from `ctx.auth.userId`, query users table for matching identity_provider='clerk' and identity_sub)
2. Find the existing user_exchanges record for this user+exchangeName combo:
   ```typescript
   const [existing] = await db
     .select({ id: userExchanges.id })
     .from(userExchanges)
     .where(
       and(
         eq(userExchanges.userId, user.id),
         eq(userExchanges.exchangeName, input.exchangeName)
       )
     )
     .limit(1);
   ```
3. If not found, throw `TRPCError({ code: 'NOT_FOUND', message: 'Exchange not configured for this user' })`
4. Build the update object dynamically from provided optional fields:
   ```typescript
   const updates: Record<string, unknown> = { updatedAt: new Date() };
   if (input.apiKeyEnvVar) updates.apiKeyEnvVar = input.apiKeyEnvVar;
   if (input.apiSecretEnvVar) updates.apiSecretEnvVar = input.apiSecretEnvVar;
   if (input.displayName !== undefined) updates.displayName = input.displayName;
   ```
5. **is_default orchestration**: If `input.isDefault === true`:
   - First, unset all other defaults for this user:
     ```typescript
     await db.update(userExchanges)
       .set({ isDefault: false, updatedAt: new Date() })
       .where(
         and(
           eq(userExchanges.userId, user.id),
           eq(userExchanges.isDefault, true)
         )
       );
     ```
   - Then set `updates.isDefault = true`
   - If `input.isDefault === false`, set `updates.isDefault = false`
6. Execute the update:
   ```typescript
   await db.update(userExchanges)
     .set(updates)
     .where(eq(userExchanges.id, existing.id));
   ```
7. Return `{ success: true }`

Also update the existing `setupExchange` mutation to handle is_default orchestration:
- Before inserting a new record with `isDefault: true`, first unset any existing defaults for this user:
  ```typescript
  await db.update(userExchanges)
    .set({ isDefault: false, updatedAt: new Date() })
    .where(
      and(
        eq(userExchanges.userId, user.id),
        eq(userExchanges.isDefault, true)
      )
    );
  ```
- This ensures only one exchange is default at a time
  </action>
  <verify>
Run `npx tsc --noEmit --project apps/api/tsconfig.json` -- zero type errors.
Grep for `updateExchange` in exchange-symbol.router.ts to confirm the mutation exists.
Grep for `isDefault: false` in the setupExchange mutation to confirm orchestration was added.
  </verify>
  <done>updateExchange mutation accepts optional fields and orchestrates is_default (unsetting previous default before setting new). setupExchange also orchestrates is_default on create.</done>
</task>

<task type="auto">
  <name>Task 2: Enhance ExchangeSetupModal with edit mode</name>
  <files>apps/admin/src/components/exchange/ExchangeSetupModal.tsx</files>
  <action>
Enhance the ExchangeSetupModal to support editing existing exchange configurations.

**New props:**
```typescript
interface ExchangeSetupModalProps {
  open: boolean;
  onComplete: () => void;
  userName: string | null;
  // New: edit mode props
  editExchange?: {
    exchangeName: string;
    displayName: string;
    apiKeyEnvVar: string;
    apiSecretEnvVar: string;
    isDefault: boolean;
  } | null;
}
```

**Behavior changes:**

1. **Edit mode detection**: If `editExchange` is provided and not null, skip Step 1 (exchange selection) and go directly to Step 2 (credentials form) pre-populated with existing values.

2. **Pre-population in edit mode**: When `editExchange` is provided:
   - Set `selectedExchange` to a synthetic ExchangeInfo (only `name` and `displayName` needed for the header)
   - Pre-fill `apiKeyEnvVar`, `apiSecretEnvVar` from `editExchange`
   - Add a `displayName` input field (new) above the env var fields
   - Add a "Set as Default" switch (using `@/components/ui/switch` and `@/components/ui/label`) below env vars if `editExchange.isDefault === false`

3. **Save in edit mode**: When saving in edit mode, call `updateExchange` instead of `setupExchange`:
   ```typescript
   await trpcClient.exchangeSymbol.updateExchange.mutate({
     exchangeName: editExchange.exchangeName,
     apiKeyEnvVar,
     apiSecretEnvVar,
     displayName: displayNameValue || undefined,
     isDefault: isDefaultChecked ? true : undefined,
   });
   ```

4. **Dialog title/description for edit mode**:
   - Title: "Edit Exchange" (instead of "Configure Exchange")
   - Description: "Update credentials for {exchangeName}"

5. **Save button text**: "Update Exchange" in edit mode, "Save Exchange" in create mode

6. **Dismissable in edit mode**: Edit mode should be dismissable (user can close the dialog). Only the initial first-login create mode is non-dismissable. Add `onOpenChange` handler that calls `onComplete` when in edit mode. Keep the existing non-dismissable behavior for create mode (when `!editExchange`).

Note: The ExchangeSetupModal is NOT called from the Network page directly in this plan. The Network page integration (an "Edit" or "Settings" button on InstanceCard) would be a natural extension but is not required by ADM-03/ADM-04. The modal can be invoked from any context that provides the `editExchange` prop. The existing ExchangeGuard flow continues to work for first-time setup.
  </action>
  <verify>
Run `npx tsc --noEmit --project apps/admin/tsconfig.json` -- zero type errors.
Read ExchangeSetupModal.tsx and verify:
- editExchange prop is defined in interface
- Edit mode skips exchange selection step
- updateExchange mutation is called in edit mode
- displayName input field exists
- is_default switch exists
  </verify>
  <done>ExchangeSetupModal supports both create (existing flow) and edit mode (pre-populated, calls updateExchange). is_default switch available in edit mode. Dialog dismissable in edit mode.</done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes for both API and admin apps
2. updateExchange mutation exists in exchange-symbol.router.ts with is_default orchestration
3. setupExchange mutation now also orchestrates is_default before insert
4. ExchangeSetupModal accepts editExchange prop
5. Edit mode pre-populates fields and calls updateExchange
6. Create mode continues to work as before (non-dismissable, calls setupExchange)
</verification>

<success_criteria>
- ADM-03: Exchange Setup Modal allows creating and updating user_exchanges records
- ADM-04: Setting a new default exchange automatically unsets previous default
- No TypeScript compilation errors
- Existing ExchangeGuard first-login flow unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/37-admin-ui-connect-setup-warmup/37-02-SUMMARY.md`
</output>
