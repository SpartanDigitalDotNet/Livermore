---
phase: 37-admin-ui-connect-setup-warmup
plan: 03
type: execute
wave: 2
depends_on: ["37-01"]
files_modified:
  - apps/api/src/routers/network.router.ts
  - apps/admin/src/components/network/WarmupProgressPanel.tsx
  - apps/admin/src/components/network/InstanceCard.tsx
  - apps/admin/src/components/network/index.ts
autonomous: true
must_haves:
  truths:
    - "During warmup, the Admin UI displays real-time percent complete, ETA, current symbol, and failures"
    - "Warmup progress is visible on the Network page near the warming exchange's instance card"
    - "Progress polling is active only while the exchange is in warming state"
    - "After warmup completes, the final stats (complete/error) are still visible until the card refreshes to active state"
  artifacts:
    - path: "apps/admin/src/components/network/WarmupProgressPanel.tsx"
      provides: "Real-time warmup progress display with percent, ETA, symbol, failures"
      min_lines: 60
    - path: "apps/api/src/routers/network.router.ts"
      provides: "getWarmupStats endpoint reading from Redis"
      contains: "getWarmupStats"
  key_links:
    - from: "apps/admin/src/components/network/WarmupProgressPanel.tsx"
      to: "network.getWarmupStats"
      via: "tRPC query with refetchInterval during warming"
      pattern: "trpc\\.network\\.getWarmupStats"
    - from: "apps/api/src/routers/network.router.ts"
      to: "warmupStatsKey"
      via: "Redis GET for warmup stats JSON"
      pattern: "warmupStatsKey"
---

<objective>
Add a warmup progress panel to the Network page that displays real-time warmup stats (percent complete, ETA, current symbol, failures) during the warmup phase. The panel polls a new tRPC endpoint that reads from the warmup stats Redis key.

Purpose: WARM-06 -- admins can monitor warmup progress in real time from the Admin UI.
Output: getWarmupStats tRPC endpoint and WarmupProgressPanel component integrated into InstanceCard.
</objective>

<execution_context>
@C:/Users/Mike McWilliams/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Mike McWilliams/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-admin-ui-connect-setup-warmup/37-01-SUMMARY.md
@apps/api/src/routers/network.router.ts
@apps/admin/src/components/network/InstanceCard.tsx
@apps/admin/src/components/network/index.ts
@packages/exchange-core/src/warmup/types.ts
@packages/cache/src/keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getWarmupStats endpoint to network router</name>
  <files>apps/api/src/routers/network.router.ts</files>
  <action>
Add a new `getWarmupStats` query to the `networkRouter` in `apps/api/src/routers/network.router.ts`.

**Input:** `z.object({ exchangeId: z.number() })`

**Implementation:**
1. Import `warmupStatsKey` from `@livermore/cache`
2. Read the Redis key: `const data = await redis.get(warmupStatsKey(input.exchangeId))`
3. If no data, return `{ stats: null }`
4. Parse JSON and return: `{ stats: JSON.parse(data) as WarmupStats }`
5. Import the `WarmupStats` type from `@livermore/exchange-core` for type annotation. If the type is not directly importable from exchange-core's barrel, use `import type { WarmupStats } from '@livermore/exchange-core'`. If that fails, define the type inline matching the shape in `packages/exchange-core/src/warmup/types.ts`.
6. Wrap in try/catch -- on Redis failure return `{ stats: null }`

The endpoint is read-only and does not modify any Redis keys. Stats are written by the SmartWarmupService during warmup execution (Phase 35).

**Note on type import:** The WarmupStats type is defined in `packages/exchange-core/src/warmup/types.ts` and exported from `packages/exchange-core/src/warmup/index.ts`. Check if `@livermore/exchange-core` re-exports it from the package barrel. If not, add the re-export from `packages/exchange-core/src/index.ts`. The type should be available as `import type { WarmupStats } from '@livermore/exchange-core'`.
  </action>
  <verify>
Run `npx tsc --noEmit --project apps/api/tsconfig.json` -- zero type errors.
Grep for `getWarmupStats` in network.router.ts to confirm the endpoint exists.
Grep for `warmupStatsKey` in network.router.ts to confirm it reads from the correct Redis key.
  </verify>
  <done>getWarmupStats endpoint reads warmup stats from Redis and returns parsed WarmupStats or null. Type-safe with proper error handling.</done>
</task>

<task type="auto">
  <name>Task 2: WarmupProgressPanel component integrated into InstanceCard</name>
  <files>
    apps/admin/src/components/network/WarmupProgressPanel.tsx
    apps/admin/src/components/network/InstanceCard.tsx
    apps/admin/src/components/network/index.ts
  </files>
  <action>
**Create WarmupProgressPanel.tsx** (apps/admin/src/components/network/WarmupProgressPanel.tsx):

Props: `{ exchangeId: number }`

The component:
1. Uses `useQuery` with `trpc.network.getWarmupStats.queryOptions({ exchangeId })` and `refetchInterval: 2000` (2s polling for real-time feel during warmup)
2. If `!data?.stats` or stats is null, render nothing (return null)
3. Renders a compact progress display inside a bordered container with `rounded-md border p-3 bg-blue-50/50`:

**Layout:**
```
Warmup Progress
[=========>        ] 45%  ~2m 15s remaining
Currently warming: BTC-USD 1h
Completed: 12/27 pairs | Skipped: 8 | Failed: 0
```

- **Header row**: "Warmup Progress" label + status badge (scanning/executing/complete/error)
  - Status badges: scanning = `outline` "Scanning", executing = `warning` "Executing", complete = `success` "Complete", error = `destructive` "Error"
- **Progress bar**: Use `Progress` component from `@/components/ui/progress` with `value={stats.percentComplete}`
- **Percent + ETA**: Show `{stats.percentComplete}%` and if `stats.etaMs` is not null, format as human-readable (e.g., "~2m 15s remaining"). Helper: `const formatEta = (ms: number) => { const s = Math.ceil(ms / 1000); const m = Math.floor(s / 60); const sec = s % 60; return m > 0 ? \`~${m}m ${sec}s remaining\` : \`~${sec}s remaining\`; }`
- **Current item**: If `stats.currentSymbol`, show "Currently warming: {stats.currentSymbol} {stats.currentTimeframe}"
- **Summary line**: "Completed: {stats.completedPairs}/{stats.totalPairs} pairs | Skipped: {stats.skippedPairs} | Failed: {stats.failedPairs}"
- **Failures section** (only if `stats.failures.length > 0`): Show a collapsible list of failures with red text:
  - Each failure: `{failure.symbol} {failure.timeframe}: {failure.error}`
  - Use a simple `details` / `summary` HTML element for collapse: `<details><summary className="text-red-600 text-xs cursor-pointer">{N} failures</summary>...list...</details>`

4. Stop polling optimization: If `stats.status === 'complete'` or `stats.status === 'error'`, set `refetchInterval: false` (stop polling). Use a conditional refetchInterval:
   ```typescript
   const isActive = data?.stats?.status === 'scanning' || data?.stats?.status === 'executing';
   // ... useQuery with refetchInterval: isActive ? 2000 : false
   ```
   Note: Since we can't conditionally change refetchInterval in the same query easily, use `refetchInterval: data?.stats && (data.stats.status === 'scanning' || data.stats.status === 'executing') ? 2000 : 30000` (slow poll when complete, fast poll when active). This ensures stale data doesn't linger but doesn't hammer Redis when idle.

**Modify InstanceCard.tsx:**
- Import `WarmupProgressPanel` from the barrel or directly
- After the existing card content (status grid or "No active connection" text), conditionally render WarmupProgressPanel when:
  - `online === true` AND `status?.connectionState === 'warming'`
  - OR `online === true` AND `status?.connectionState === 'starting'` (warmup happens during starting phase too based on the handleStart flow)
- Place the panel inside CardContent (append to existing content), with `mt-3 pt-3 border-t` for visual separation from the status grid
- Also show the panel when connectionState is 'active' BUT warmup stats exist and are not yet complete (this handles the brief transition from warming to active where stats may still be readable). Actually, to keep it simple: show WarmupProgressPanel when connectionState is 'starting' or 'warming'. The panel itself returns null if no stats exist.

**Update barrel file** (apps/admin/src/components/network/index.ts):
- Add: `export { WarmupProgressPanel } from './WarmupProgressPanel';`
  </action>
  <verify>
Run `npx tsc --noEmit --project apps/admin/tsconfig.json` -- zero type errors.
Read WarmupProgressPanel.tsx and verify:
- Uses trpc.network.getWarmupStats.queryOptions
- Uses Progress component from ui
- Shows percent, ETA, current symbol, failures
- Conditional refetchInterval based on stats status
Read InstanceCard.tsx and verify WarmupProgressPanel renders for warming/starting states.
  </verify>
  <done>WarmupProgressPanel displays real-time warmup stats with progress bar, ETA, current symbol, and failure list. Integrated into InstanceCard for warming/starting states. Polling stops when warmup completes.</done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes for both API and admin apps
2. getWarmupStats endpoint exists in network.router.ts, reads from warmupStatsKey
3. WarmupProgressPanel component shows percent, ETA, current symbol, completed/skipped/failed counts
4. Progress bar uses the existing Progress UI component
5. Failures are displayed when present
6. Polling is fast (2s) during active warmup, slows down when complete
7. Panel only renders on InstanceCard when connectionState is starting or warming
</verification>

<success_criteria>
- WARM-06: Admin UI subscribes to warmup stats for the lifetime of the warmup process, displaying real-time progress
- Progress bar shows percent complete with ETA
- Current symbol being warmed is visible
- Failure list is displayed if any failures occur
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/37-admin-ui-connect-setup-warmup/37-03-SUMMARY.md`
</output>
