---
phase: 41-authentication-rate-limiting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/schema.sql
  - packages/database/src/schema/api-keys.ts
  - packages/database/src/schema/index.ts
  - apps/api/src/routers/api-key.router.ts
  - apps/api/src/routers/index.ts
  - packages/public-api/src/middleware/auth.ts
  - packages/public-api/src/middleware/rate-limit.ts
  - packages/public-api/src/plugin.ts
  - packages/public-api/src/index.ts
  - packages/public-api/package.json
  - apps/api/src/server.ts
autonomous: true

must_haves:
  truths:
    - "Unauthenticated requests to /public/v1/* data endpoints return 401 with error envelope"
    - "Requests with valid X-API-Key header return data as before"
    - "Requests exceeding 300 req/min per API key return 429 with retry-after header"
    - "Admin tRPC routes at /trpc/* are not rate limited and do not require API key"
    - "Swagger UI at /public/v1/docs is accessible without API key"
    - "Admin can create, list, regenerate, and deactivate API keys via tRPC mutations"
    - "CORS is permissive for /public/v1/* and restrictive for /trpc/*"
    - "OpenAPI spec includes X-API-Key security scheme"
  artifacts:
    - path: "packages/database/src/schema/api-keys.ts"
      provides: "Drizzle schema for api_keys table"
      contains: "apiKeys"
    - path: "packages/public-api/src/middleware/auth.ts"
      provides: "API key validation hook with in-memory cache"
      exports: ["validateApiKey", "clearKeyCache"]
    - path: "packages/public-api/src/middleware/rate-limit.ts"
      provides: "Rate limit configuration factory"
      exports: ["getRateLimitConfig"]
    - path: "apps/api/src/routers/api-key.router.ts"
      provides: "tRPC CRUD router for API keys"
      exports: ["apiKeyRouter"]
  key_links:
    - from: "packages/public-api/src/plugin.ts"
      to: "packages/public-api/src/middleware/auth.ts"
      via: "onRequest hook registration"
      pattern: "addHook.*onRequest"
    - from: "packages/public-api/src/plugin.ts"
      to: "@fastify/rate-limit"
      via: "plugin registration with Redis"
      pattern: "register.*rateLimit"
    - from: "apps/api/src/server.ts"
      to: "packages/public-api/src/plugin.ts"
      via: "Redis client passed as plugin option"
      pattern: "publicApiPlugin.*redis"
    - from: "apps/api/src/routers/index.ts"
      to: "apps/api/src/routers/api-key.router.ts"
      via: "appRouter composition"
      pattern: "apiKey.*apiKeyRouter"
---

<objective>
Implement API key authentication, rate limiting, route-scoped CORS, and API key management for the public API.

Purpose: Secure all /public/v1/* data endpoints with X-API-Key header authentication and 300 req/min rate limiting, while keeping admin tRPC routes and Swagger UI accessible without API keys.

Output: api_keys database table, Drizzle schema, auth middleware with in-memory cache, rate-limit configuration with Redis backing, tRPC CRUD router for key management, plugin wiring, route-scoped CORS, and OpenAPI security scheme.
</objective>

<execution_context>
@C:/Users/Mike McWilliams/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Mike McWilliams/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-authentication-rate-limiting/41-RESEARCH.md

@packages/public-api/src/plugin.ts
@packages/public-api/src/index.ts
@packages/public-api/package.json
@packages/database/schema.sql
@packages/database/src/schema/index.ts
@packages/database/src/schema/users.ts
@apps/api/src/server.ts
@apps/api/src/routers/index.ts
@apps/api/src/routers/settings.router.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema, Drizzle model, and API key tRPC router</name>
  <files>
    packages/database/schema.sql
    packages/database/src/schema/api-keys.ts
    packages/database/src/schema/index.ts
    apps/api/src/routers/api-key.router.ts
    apps/api/src/routers/index.ts
  </files>
  <action>
1. **schema.sql** -- Add `api_keys` table at the end of the file (before any closing comments):
   ```sql
   CREATE TABLE "api_keys" (
     "id" serial NOT NULL,
     "name" character varying(100) NOT NULL,
     "key" uuid NOT NULL DEFAULT gen_random_uuid(),
     "is_active" boolean NOT NULL DEFAULT true,
     "created_by" character varying(255) NOT NULL,
     "last_used_at" timestamp NULL,
     "created_at" timestamp NOT NULL DEFAULT now(),
     "updated_at" timestamp NOT NULL DEFAULT now(),
     PRIMARY KEY ("id"),
     CONSTRAINT "api_keys_key_unique" UNIQUE ("key")
   );
   CREATE INDEX "api_keys_key_active_idx" ON "api_keys" ("key") WHERE is_active = true;
   ```

2. **packages/database/src/schema/api-keys.ts** -- Create Drizzle schema matching schema.sql exactly. Use `pgTable`, `serial`, `varchar`, `uuid`, `boolean`, `timestamp`. Export `apiKeys` table, `ApiKey` (select type), `NewApiKey` (insert type). Use `{ mode: 'string' }` for timestamps (matches existing pattern in users.ts). Use `sql` template literal from drizzle-orm for the partial index WHERE clause.

3. **packages/database/src/schema/index.ts** -- Add `export * from './api-keys';` line.

4. **apps/api/src/routers/api-key.router.ts** -- Create tRPC router with `protectedProcedure` (from @livermore/trpc-config) for all mutations/queries:
   - `list` query: Select id, name, keyPreview (last 8 chars via SQL substring or post-processing -- mask the key as `'••••••••-' + key.slice(-8)`), isActive, lastUsedAt, createdAt from api_keys ordered by createdAt desc.
   - `create` mutation: Input `{ name: z.string().min(1).max(100) }`. Generate key via `randomUUID()` from `node:crypto`. Insert row with `createdBy: ctx.auth.userId`. Return full key (shown only once to user).
   - `regenerate` mutation: Input `{ id: z.number() }`. Generate new key via `randomUUID()`. Update row's key and updatedAt. Return the new full key. Also import and call `clearKeyCache()` from `@livermore/public-api` to invalidate the in-memory auth cache for the old key.
   - `deactivate` mutation: Input `{ id: z.number() }`. Set `isActive: false` and update `updatedAt`. Call `clearKeyCache()` to invalidate cache.

5. **apps/api/src/routers/index.ts** -- Import `apiKeyRouter` and add `apiKey: apiKeyRouter` to the appRouter. Add re-export line.
  </action>
  <verify>
Run `npx tsc --noEmit` from apps/api to verify TypeScript compiles without errors. Verify api-keys.ts exports are accessible from @livermore/database.
  </verify>
  <done>
api_keys table defined in schema.sql, Drizzle schema matches, tRPC router provides list/create/regenerate/deactivate operations behind protectedProcedure, router wired into appRouter.
  </done>
</task>

<task type="auto">
  <name>Task 2: Auth middleware, rate limiting, plugin wiring, and route-scoped CORS</name>
  <files>
    packages/public-api/src/middleware/auth.ts
    packages/public-api/src/middleware/rate-limit.ts
    packages/public-api/src/plugin.ts
    packages/public-api/src/index.ts
    packages/public-api/package.json
    apps/api/src/server.ts
  </files>
  <action>
1. **Install @fastify/rate-limit** in the public-api package:
   ```bash
   cd packages/public-api && pnpm add @fastify/rate-limit
   ```

2. **packages/public-api/src/middleware/auth.ts** -- Create API key validation module:
   - In-memory `Map<string, { id: number; isActive: boolean; cachedAt: number }>` cache with 60s TTL.
   - `validateApiKey(apiKey: string): Promise<number | null>` -- checks cache first, falls back to DB lookup via `getDbClient()` + `apiKeys` schema from `@livermore/database`. On cache miss, query `SELECT id, is_active FROM api_keys WHERE key = $1 LIMIT 1`. Cache the result. Fire-and-forget update `last_used_at` (no await, `.catch(() => {})` to swallow errors). Return `id` if active, `null` otherwise.
   - `clearKeyCache(): void` -- clears the entire in-memory Map (called from tRPC mutations on regenerate/deactivate).
   - `buildAuthHook()` -- returns an `onRequest` hook function that:
     - Skips if `request.method === 'OPTIONS'` (CORS preflight)
     - Skips if URL path matches `/docs` or `/openapi.json` or starts with `/docs/` (Swagger UI and spec)
     - Reads `x-api-key` header. If missing, sends 401 `{ success: false, error: { code: 'UNAUTHORIZED', message: 'API key required. Set X-API-Key header.' } }`.
     - Validates via `validateApiKey()`. If null, sends 401 `{ success: false, error: { code: 'UNAUTHORIZED', message: 'Invalid or inactive API key.' } }`.
     - Stores key ID: `(request as any).apiKeyId = keyId`.
   - Export `validateApiKey`, `clearKeyCache`, `buildAuthHook`.

3. **packages/public-api/src/middleware/rate-limit.ts** -- Create rate limit configuration factory:
   - `getRateLimitConfig(redis: any)` returns the options object for `@fastify/rate-limit`:
     ```typescript
     {
       max: 300,
       timeWindow: '1 minute',
       keyGenerator: (request: any) => String((request as any).apiKeyId ?? request.ip),
       redis,
       nameSpace: '{rl}:public:',  // Hash tag for Redis Cluster compatibility
       skipOnError: true,
       errorResponseBuilder: (_request: any, context: any) => ({
         success: false,
         error: {
           code: 'RATE_LIMITED',
           message: `Rate limit exceeded. Retry after ${context.after}.`,
         },
       }),
       addHeadersOnExceeding: { 'x-ratelimit-limit': true, 'x-ratelimit-remaining': true, 'x-ratelimit-reset': true },
       addHeaders: { 'x-ratelimit-limit': true, 'x-ratelimit-remaining': true, 'x-ratelimit-reset': true, 'retry-after': true },
     }
     ```
   - Export `getRateLimitConfig`.

4. **packages/public-api/src/plugin.ts** -- Modify `publicApiPlugin`:
   - Change the plugin signature to accept options: `{ redis?: any }` (optional to avoid breaking if not passed, but warn if missing).
   - BEFORE registering swagger, add the auth hook: `instance.addHook('onRequest', buildAuthHook())`.
   - AFTER the auth hook but BEFORE route registration, register rate limiting:
     ```typescript
     if (opts.redis) {
       const rateLimit = (await import('@fastify/rate-limit')).default;
       await instance.register(rateLimit, getRateLimitConfig(opts.redis));
     }
     ```
   - Update the OpenAPI config to include security scheme:
     ```typescript
     components: {
       securitySchemes: {
         apiKey: {
           type: 'apiKey',
           name: 'X-API-Key',
           in: 'header',
           description: 'API key for authentication. Obtain from the admin dashboard.',
         },
       },
     },
     security: [{ apiKey: [] }],
     ```
   - Update the description string: replace the "Rate limits" and "Authentication" placeholder lines with actual descriptions mentioning X-API-Key header and 300 req/min limit.

5. **packages/public-api/src/index.ts** -- Add export for `clearKeyCache`:
   ```typescript
   export { clearKeyCache } from './middleware/auth.js';
   ```
   (This is needed by the tRPC router in apps/api to invalidate cache on regenerate/deactivate.)

6. **apps/api/src/server.ts** -- Two changes:
   a. **Pass Redis to public API plugin:** Change the publicApiPlugin registration to pass the redis client:
      ```typescript
      await fastify.register(publicApiPlugin, { prefix: '/public/v1', redis });
      ```
      Note: This line currently runs BEFORE `getRedisClient()` is called. Move the public API registration to AFTER the Redis client is initialized (after the pre-flight checks section), or initialize Redis earlier. The cleanest approach: move the `publicApiPlugin` registration to after the pre-flight connection checks block (after `logger.info('Pre-flight checks passed...')`).

   b. **Route-scoped CORS:** Replace the current `await fastify.register(cors, { origin: true })` with a delegator-based CORS:
      ```typescript
      await fastify.register(cors, {
        delegator: (request: any, callback: any) => {
          const url = request.url as string;
          if (url.startsWith('/public/v1')) {
            callback(null, { origin: true });
            return;
          }
          const adminOrigin = process.env.ADMIN_ORIGIN ?? 'http://localhost:4001';
          callback(null, { origin: adminOrigin, credentials: true });
        },
      });
      ```
  </action>
  <verify>
1. Run `pnpm install` from project root to resolve new @fastify/rate-limit dependency.
2. Run `npx tsc --noEmit` from packages/public-api to verify middleware compiles.
3. Run `npx tsc --noEmit` from apps/api to verify server.ts changes compile.
4. Verify the OpenAPI spec at /public/v1/openapi.json includes `securitySchemes.apiKey` definition.
  </verify>
  <done>
Auth middleware validates X-API-Key header with 60s in-memory cache. Rate limiting enforces 300 req/min per API key via Redis. Plugin wiring registers auth hook before rate-limit, both scoped to public API only. CORS uses delegator for route-scoped policies. OpenAPI spec documents X-API-Key security requirement. Swagger UI accessible without auth.
  </done>
</task>

</tasks>

<verification>
1. `curl http://localhost:3000/public/v1/exchanges` returns 401 with `{ success: false, error: { code: 'UNAUTHORIZED', message: 'API key required...' } }`
2. `curl -H "X-API-Key: invalid-uuid" http://localhost:3000/public/v1/exchanges` returns 401 with `{ success: false, error: { code: 'UNAUTHORIZED', message: 'Invalid or inactive...' } }`
3. `curl -H "X-API-Key: {valid-key}" http://localhost:3000/public/v1/exchanges` returns 200 with exchange data
4. Response headers include `x-ratelimit-limit: 300` and `x-ratelimit-remaining: 299`
5. `curl http://localhost:3000/public/v1/docs` returns Swagger UI HTML (no auth required)
6. `curl http://localhost:3000/trpc/indicator.list` is NOT rate limited (admin route exempt)
7. OpenAPI spec at /public/v1/openapi.json contains `securitySchemes` with `apiKey` type
</verification>

<success_criteria>
- Unauthenticated requests to data endpoints return 401
- Valid API key requests return data with rate limit headers
- Swagger UI and OpenAPI spec accessible without auth
- tRPC admin routes exempt from auth and rate limiting
- API key CRUD operations available via tRPC mutations
- Route-scoped CORS in effect (permissive for public, restrictive for admin)
</success_criteria>

<output>
After completion, create `.planning/phases/41-authentication-rate-limiting/41-01-SUMMARY.md`
</output>
