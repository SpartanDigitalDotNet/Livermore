---
phase: 42-websocket-bridge-backpressure
plan: 02
type: execute
wave: 2
depends_on: ["42-01"]
files_modified:
  - packages/public-api/src/ws/index.ts
  - packages/public-api/src/plugin.ts
  - apps/api/src/server.ts
  - packages/public-api/docs/asyncapi.yaml
autonomous: true

must_haves:
  truths:
    - "External client can connect to /public/v1/stream?apiKey=xxx and receive a WebSocket connection"
    - "Client sending subscribe message receives subscribed confirmation and then receives real-time candle/signal events"
    - "Connection is rejected with close code 4001 if API key is missing or invalid"
    - "Connection is rejected with close code 4008 if per-key connection limit (5) exceeded"
    - "AsyncAPI 3.1 spec documents all message schemas, channels, and authentication details"
  artifacts:
    - path: "packages/public-api/src/ws/index.ts"
      provides: "Barrel export for ws module"
      exports: ["WebSocketBridge", "ClientConnection", "handleClientMessage"]
    - path: "packages/public-api/src/plugin.ts"
      provides: "Updated plugin with /stream WebSocket route"
      contains: "stream"
    - path: "apps/api/src/server.ts"
      provides: "Bridge lifecycle integration (start on server ready, stop on close)"
      contains: "WebSocketBridge"
    - path: "packages/public-api/docs/asyncapi.yaml"
      provides: "AsyncAPI 3.1 spec for WebSocket streaming API"
      contains: "asyncapi: 3.1.0"
  key_links:
    - from: "packages/public-api/src/plugin.ts"
      to: "packages/public-api/src/ws/bridge.ts"
      via: "Creates bridge instance, registers /stream route that calls bridge.addClient()"
      pattern: "bridge\\.addClient"
    - from: "apps/api/src/server.ts"
      to: "packages/public-api/src/plugin.ts"
      via: "Passes redis and exchangeId to plugin opts for bridge construction"
      pattern: "publicApiPlugin.*redis"
    - from: "packages/public-api/src/plugin.ts"
      to: "packages/public-api/src/middleware/auth.ts"
      via: "validateApiKey() for WS query param auth"
      pattern: "validateApiKey"
---

<objective>
Wire the WebSocket bridge into Fastify, register the /stream route with API key auth, integrate bridge lifecycle with server startup/shutdown, and create the AsyncAPI 3.1 specification.

Purpose: Connect the bridge engine (Plan 01) to the running server so external clients can actually connect and receive real-time data. Document the WebSocket protocol with AsyncAPI spec for developer consumption.

Output: Working /public/v1/stream WebSocket endpoint + AsyncAPI 3.1 YAML spec.
</objective>

<execution_context>
@C:/Users/Mike McWilliams/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Mike McWilliams/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-websocket-bridge-backpressure/42-RESEARCH.md
@.planning/phases/42-websocket-bridge-backpressure/42-01-SUMMARY.md

@packages/public-api/src/plugin.ts
@packages/public-api/src/middleware/auth.ts
@packages/public-api/src/index.ts
@apps/api/src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire /stream route into plugin and integrate bridge lifecycle in server.ts</name>
  <files>
    packages/public-api/src/ws/index.ts
    packages/public-api/src/plugin.ts
    apps/api/src/server.ts
  </files>
  <action>
**ws/index.ts** — Barrel export:
- Export `WebSocketBridge` from './bridge.js'
- Export `ClientConnection` from './connection.js'
- Export `handleClientMessage` from './handlers.js'
- Export types and schemas as needed

**plugin.ts** — Add WebSocket /stream route:

Update the `publicApiPlugin` function. The plugin already receives `opts.redis`. Add `opts.exchangeId?: number` and `opts.exchangeName?: string` to the options type.

After registering REST routes (after the `alertsRoute` registration), add the WebSocket stream route:

```typescript
// WebSocket streaming endpoint (Phase 42)
if (opts.redis && opts.exchangeId && opts.exchangeName) {
  const bridge = new WebSocketBridge({
    redis: opts.redis,
    exchangeId: opts.exchangeId,
    exchangeName: opts.exchangeName,
  });
  await bridge.start();

  // Store bridge on instance for lifecycle management
  instance.decorate('wsBridge', bridge);

  // Register cleanup on server close
  instance.addHook('onClose', async () => {
    await bridge.stop();
  });

  instance.get('/stream', { websocket: true }, async (socket, request) => {
    // WS-01: API key auth via query parameter
    const apiKey = (request.query as any).apiKey as string | undefined;
    if (!apiKey) {
      socket.close(4001, 'API key required');
      return;
    }

    const keyId = await validateApiKey(apiKey);
    if (keyId === null) {
      socket.close(4001, 'Invalid API key');
      return;
    }

    // WS-06: Per-key connection limit
    if (bridge.getConnectionCount(keyId) >= 5) {
      socket.close(4008, 'Connection limit exceeded');
      return;
    }

    // Register connection with bridge
    const connection = bridge.addClient(socket, keyId);
    if (!connection) {
      socket.close(4008, 'Connection limit exceeded');
      return;
    }

    // CRITICAL: Attach message handler synchronously per @fastify/websocket requirement
    socket.on('message', (data) => {
      handleClientMessage(bridge, connection, data);
    });

    socket.on('close', () => {
      bridge.removeClient(connection.connectionId);
    });

    socket.on('error', () => {
      bridge.removeClient(connection.connectionId);
    });
  });
}
```

IMPORTANT: The auth hook (`buildAuthHook`) checks for `X-API-Key` header and skips docs/openapi paths. For the `/stream` WebSocket route, the auth hook will fire but WS clients can't set headers. Two approaches:
1. Add `/stream` to the skip list in `buildAuthHook()` (since WS auth is handled in-route via query param)
2. OR check if the route is `/stream` and skip

Go with option 1: In `buildAuthHook()` in auth.ts, add a check for the `/stream` path (same pattern as `/docs` skip). The WS handler itself validates the API key via query param, so the header-based hook should be bypassed.

Update auth.ts to skip `/stream` path:
```typescript
if (routerPath === '/stream') {
  return; // WS auth handled in-route via query param
}
```

Also update the auth hook's full URL check to include `/stream`.

**server.ts** — Pass exchangeId and exchangeName to public API plugin:

Find the line `await fastify.register(publicApiPlugin, { prefix: '/public/v1', redis });` and update to:
```typescript
await fastify.register(publicApiPlugin, {
  prefix: '/public/v1',
  redis,
  exchangeId: activeExchangeId ?? undefined,
  exchangeName: activeExchangeName ?? undefined,
});
```

The `activeExchangeId` and `activeExchangeName` variables already exist in server.ts (line 295-296). They are set to `1`/`'coinbase'` for autostart, or `null`/`null` for idle mode. The plugin will only create the bridge if both are provided (the `if` guard in plugin.ts handles this).

NOTE: In idle mode (no exchange), the WebSocket bridge simply won't be created. This is correct — there's nothing to stream if no exchange is connected. When Phase 43 adds `pw-host` mode, it can revisit this.

Do NOT modify the existing `@fastify/websocket` registration in server.ts — it's already registered globally at line 254 and covers all WS routes including the new `/stream` route.
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/public-api/tsconfig.json && npx tsc --noEmit -p apps/api/tsconfig.json` — no type errors. Verify the /stream route exists by searching: `grep -n "stream.*websocket\|websocket.*stream" packages/public-api/src/plugin.ts`. Verify auth.ts skips /stream: `grep -n "stream" packages/public-api/src/middleware/auth.ts`.
  </verify>
  <done>
/public/v1/stream WebSocket endpoint is registered with query param API key auth, per-key connection limit enforcement, and bridge lifecycle (start on plugin init, stop on server close). The header-based auth hook skips the /stream path. server.ts passes exchangeId and exchangeName to the plugin.
  </done>
</task>

<task type="auto">
  <name>Task 2: AsyncAPI 3.1 specification</name>
  <files>
    packages/public-api/docs/asyncapi.yaml
  </files>
  <action>
Create `packages/public-api/docs/asyncapi.yaml` — a static AsyncAPI 3.1.0 specification documenting the WebSocket streaming API.

The spec must cover all AAS-01 through AAS-04 requirements:

**Header:**
```yaml
asyncapi: 3.1.0
info:
  title: Livermore Streaming API
  version: 1.0.0
  description: |
    Real-time cryptocurrency market data streaming via WebSocket.
    Provides candle close events and trade signals with generic labels.

    **Authentication:** Connect with API key via query parameter: ws://host/public/v1/stream?apiKey=YOUR_KEY

    **Protocol:** Send JSON messages to subscribe/unsubscribe to channels.
    Channel format: candles:{symbol}:{timeframe} or signals:{symbol}:{timeframe}

    **Connection limits:** Maximum 5 concurrent WebSocket connections per API key.

    **Heartbeat:** Server sends WebSocket ping frames every 30 seconds.
    Clients that fail to respond with pong are automatically disconnected.

    **Backpressure:** Slow clients with high send buffer are automatically disconnected.
```

**Servers:**
```yaml
servers:
  production:
    host: "{host}"
    pathname: /public/v1/stream
    protocol: wss
    description: WebSocket streaming endpoint
    bindings:
      ws:
        query:
          type: object
          properties:
            apiKey:
              type: string
              description: API key for authentication
          required:
            - apiKey
```

**Channels (AAS-03):**
Define channels for the subscription patterns:
- `candles`: Channel for candle close events. Address: `candles:{symbol}:{timeframe}`. Parameters: symbol (string, e.g. BTC-USD), timeframe (enum: 1m, 5m, 15m, 1h, 4h, 1d).
- `signals`: Channel for trade signal events. Address: `signals:{symbol}:{timeframe}`. Same parameters.

**Operations:**
- `subscribe`: Client sends subscribe message (receive binding). References the subscribe message schema.
- `unsubscribe`: Client sends unsubscribe message.
- `receiveCandle`: Client receives candle_close messages from candles channel.
- `receiveSignal`: Client receives trade_signal messages from signals channel.

**Messages (AAS-02):** Define message schemas with concrete JSON examples:

1. `subscribe` (client -> server):
```json
{ "action": "subscribe", "channels": ["candles:BTC-USD:1h", "signals:ETH-USD:15m"] }
```

2. `unsubscribe` (client -> server):
```json
{ "action": "unsubscribe", "channels": ["candles:BTC-USD:1h"] }
```

3. `subscribed` (server -> client):
```json
{ "type": "subscribed", "channels": ["candles:BTC-USD:1h", "signals:ETH-USD:15m"] }
```

4. `candle_close` (server -> client):
```json
{
  "type": "candle_close",
  "channel": "candles:BTC-USD:1h",
  "data": {
    "timestamp": "2026-02-19T12:00:00.000Z",
    "open": "42350.5",
    "high": "42450.75",
    "low": "42300.25",
    "close": "42400",
    "volume": "123.456"
  }
}
```

5. `trade_signal` (server -> client):
```json
{
  "type": "trade_signal",
  "channel": "signals:BTC-USD:15m",
  "data": {
    "symbol": "BTC-USD",
    "exchange": "coinbase",
    "timeframe": "15m",
    "signal_type": "momentum_signal",
    "direction": "bullish",
    "strength": "strong",
    "price": "42350.5",
    "timestamp": "2026-02-19T12:00:00.000Z"
  }
}
```

6. `error` (server -> client):
```json
{ "type": "error", "code": "INVALID_CHANNEL", "message": "Unknown channel format: foo:bar" }
```

**Components/schemas:** Define reusable schemas for:
- CandleData (timestamp, open, high, low, close, volume — all strings)
- SignalData (symbol, exchange, timeframe, signal_type, direction enum, strength enum, price, timestamp)
- Direction enum: bullish, bearish, neutral
- Strength enum: weak, moderate, strong, extreme
- Error codes: INVALID_MESSAGE, INVALID_CHANNEL, RATE_LIMITED

CRITICAL: The AsyncAPI spec must NOT contain any proprietary indicator names (MACD-V, macdV, fastEMA, slowEMA, etc.). Use only generic labels (momentum_signal, trade_signal, direction, strength).
  </action>
  <verify>
Verify the file exists and is valid YAML: `node -e "const yaml = require('yaml'); const fs = require('fs'); yaml.parse(fs.readFileSync('packages/public-api/docs/asyncapi.yaml', 'utf8')); console.log('Valid YAML')"`. Grep for proprietary terms: `grep -i "macdv\|macd-v\|fastEMA\|slowEMA\|atr\|informativeATR" packages/public-api/docs/asyncapi.yaml` should return no matches.
  </verify>
  <done>
AsyncAPI 3.1 spec documents all WebSocket message schemas (candle_close, trade_signal, subscribe, unsubscribe, subscribed, error) with concrete JSON examples, channel subscription patterns, authentication details, and connection parameters. Zero proprietary indicator names in the spec.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/public-api/tsconfig.json && npx tsc --noEmit -p apps/api/tsconfig.json` — zero errors
2. `grep -n "/stream" packages/public-api/src/plugin.ts` shows the WebSocket route registration
3. `grep -n "exchangeId\|exchangeName" apps/api/src/server.ts` shows the updated plugin registration
4. `packages/public-api/docs/asyncapi.yaml` exists and parses as valid YAML
5. `grep -ri "macdv\|macd-v\|fastEMA\|slowEMA" packages/public-api/src/ws/ packages/public-api/docs/` returns no matches (IP protection verified)
6. Auth hook in auth.ts skips `/stream` path
</verification>

<success_criteria>
- /public/v1/stream WebSocket endpoint accepts connections with ?apiKey=xxx query parameter
- Missing/invalid API key returns close code 4001
- Exceeding 5 connections per key returns close code 4008
- Bridge starts when plugin initializes (with exchangeId) and stops on server close
- AsyncAPI 3.1 spec is complete with all message types, channels, auth details, and concrete examples
- Zero proprietary field names in any public-facing code or documentation
</success_criteria>

<output>
After completion, create `.planning/phases/42-websocket-bridge-backpressure/42-02-SUMMARY.md`
</output>
