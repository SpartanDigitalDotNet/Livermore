---
phase: 42-websocket-bridge-backpressure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/public-api/src/ws/types.ts
  - packages/public-api/src/ws/schemas.ts
  - packages/public-api/src/ws/connection.ts
  - packages/public-api/src/ws/bridge.ts
  - packages/public-api/src/ws/handlers.ts
autonomous: true

must_haves:
  truths:
    - "WebSocketBridge creates a dedicated Redis subscriber via redis.duplicate() and psubscribes to candle close and alert patterns"
    - "ClientConnection tracks per-client subscriptions, heartbeat liveness, and bufferedAmount backpressure"
    - "Incoming Redis pub/sub messages are transformed through IP-protective transformers before fan-out"
    - "Per-API-key connection count is tracked and enforceable at connection time"
    - "Slow clients exceeding buffer threshold are terminated"
  artifacts:
    - path: "packages/public-api/src/ws/types.ts"
      provides: "TypeScript types for WS message envelopes, client state, channel mapping"
      contains: "WsMessage"
    - path: "packages/public-api/src/ws/schemas.ts"
      provides: "Zod schemas for client-to-server messages (subscribe, unsubscribe)"
      contains: "subscribeSchema"
    - path: "packages/public-api/src/ws/connection.ts"
      provides: "ClientConnection class with heartbeat, subscriptions, backpressure"
      contains: "class ClientConnection"
    - path: "packages/public-api/src/ws/bridge.ts"
      provides: "WebSocketBridge class managing shared Redis subscriber and client fan-out"
      contains: "class WebSocketBridge"
    - path: "packages/public-api/src/ws/handlers.ts"
      provides: "Message handler functions for subscribe/unsubscribe actions"
      contains: "handleClientMessage"
  key_links:
    - from: "packages/public-api/src/ws/bridge.ts"
      to: "packages/public-api/src/transformers/candle.transformer.ts"
      via: "transformCandle() call in relay path"
      pattern: "transformCandle"
    - from: "packages/public-api/src/ws/bridge.ts"
      to: "packages/public-api/src/transformers/alert.transformer.ts"
      via: "deriveAlertDirection() and deriveAlertStrength() in relay path"
      pattern: "deriveAlert"
    - from: "packages/public-api/src/ws/connection.ts"
      to: "ws socket"
      via: "bufferedAmount check before send, ping/pong heartbeat"
      pattern: "bufferedAmount"
---

<objective>
Build the WebSocket bridge engine: types, schemas, ClientConnection class, WebSocketBridge class, and message handlers.

Purpose: Create the core streaming infrastructure that bridges Redis pub/sub events to external WebSocket clients with IP protection, backpressure, and connection management. This is the self-contained engine that Plan 02 will wire into the Fastify route.

Output: Five files in `packages/public-api/src/ws/` implementing the full bridge logic.
</objective>

<execution_context>
@C:/Users/Mike McWilliams/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Mike McWilliams/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-websocket-bridge-backpressure/42-RESEARCH.md

@packages/public-api/src/transformers/candle.transformer.ts
@packages/public-api/src/transformers/signal.transformer.ts
@packages/public-api/src/transformers/alert.transformer.ts
@packages/public-api/src/middleware/auth.ts
@packages/cache/src/keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: WS types, schemas, and ClientConnection class</name>
  <files>
    packages/public-api/src/ws/types.ts
    packages/public-api/src/ws/schemas.ts
    packages/public-api/src/ws/connection.ts
  </files>
  <action>
Create three files in `packages/public-api/src/ws/`:

**types.ts** — TypeScript types for the WS protocol:
- `WsMessageType`: union of `'candle_close' | 'trade_signal' | 'subscribed' | 'unsubscribed' | 'error'`
- `WsEnvelope`: `{ type: WsMessageType; channel?: string; data?: unknown; channels?: string[]; code?: string; message?: string }`
- `ClientAction`: `'subscribe' | 'unsubscribe'`
- `ClientMessage`: `{ action: ClientAction; channels: string[] }`
- `ChannelType`: `'candle' | 'signal'`
- `ParsedChannel`: `{ type: ChannelType; symbol: string; timeframe: string }`
- `mapExternalChannel(external: string): ParsedChannel | null` — parses `candles:BTC-USD:1h` or `signals:ETH-USD:15m`. Returns null for invalid formats. Validate symbol has format `XXX-YYY` (letters/digits + hyphen), timeframe is one of `1m|5m|15m|1h|4h|1d`.
- Export a `VALID_TIMEFRAMES` const array: `['1m', '5m', '15m', '1h', '4h', '1d']`

**schemas.ts** — Zod schemas for client-to-server messages:
- `subscribeSchema`: z.object with `action: z.literal('subscribe')`, `channels: z.array(z.string()).min(1).max(20)`
- `unsubscribeSchema`: z.object with `action: z.literal('unsubscribe')`, `channels: z.array(z.string()).min(1).max(20)`
- `clientMessageSchema`: z.discriminatedUnion on `action` field combining both above
- Use `@livermore/public-api` Zod style (`.describe()` on fields)

**connection.ts** — ClientConnection class managing per-client state:
- Constructor takes `{ socket: WebSocket, apiKeyId: number, connectionId: string }`
- Properties: `subscriptions: Set<string>` (external channel names like `candles:BTC-USD:1h`), `alive: boolean`, `apiKeyId: number`, `connectionId: string`
- `startHeartbeat()`: setInterval every 30 seconds. If `!this.alive`, call `socket.terminate()` and return. Set `alive = false`, call `socket.ping()`. Attach `socket.on('pong', () => { this.alive = true })` — attach pong handler ONCE in constructor, not in interval.
- `stopHeartbeat()`: clearInterval
- `send(data: string): boolean`: Check `socket.readyState !== WebSocket.OPEN` → return false. Check `socket.bufferedAmount > 256 * 1024` → call `socket.terminate()`, return false. Check `socket.bufferedAmount > 64 * 1024` → skip (return false, do not send). Otherwise `socket.send(data)`, return true.
- `addSubscription(channel: string)` / `removeSubscription(channel: string)` / `hasSubscription(channel: string): boolean`
- `destroy()`: stopHeartbeat, close socket if open
- Import WebSocket from 'ws' (the underlying library used by @fastify/websocket)

IMPORTANT: The `send()` method implements WS-07 backpressure. The thresholds are: 64KB warning (skip message), 256KB disconnect (terminate). These are heuristic thresholds per the research — bufferedAmount is not perfectly accurate but good enough.
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/public-api/tsconfig.json` — no type errors in the three new files.
  </verify>
  <done>
types.ts exports WS message types and channel parser, schemas.ts exports Zod validation for client messages, connection.ts exports ClientConnection class with heartbeat, backpressure send, and subscription tracking.
  </done>
</task>

<task type="auto">
  <name>Task 2: WebSocketBridge class and message handlers</name>
  <files>
    packages/public-api/src/ws/bridge.ts
    packages/public-api/src/ws/handlers.ts
  </files>
  <action>
Create two files:

**bridge.ts** — WebSocketBridge class (the core engine):

Constructor takes `{ redis: any, exchangeId: number, exchangeName: string }`. Store these.
- `clients: Map<string, ClientConnection>` — keyed by connectionId (use crypto.randomUUID())
- `keyConnectionCounts: Map<number, number>` — tracks per-API-key connection count for WS-06
- `subscriber: Redis | null` — the dedicated Redis subscriber
- `MAX_CONNECTIONS_PER_KEY = 5`

**start()**:
- `this.subscriber = this.redis.duplicate()`
- `await this.subscriber.psubscribe('channel:exchange:' + this.exchangeId + ':candle:close:*:*')`
- `await this.subscriber.psubscribe('channel:alerts:exchange:' + this.exchangeId)`
- Attach `this.subscriber.on('pmessage', (pattern, channel, message) => this.handleRedisMessage(channel, message))`

**stop()**:
- Unsubscribe, disconnect subscriber, destroy all clients, clear maps.

**addClient(socket: WebSocket, apiKeyId: number): ClientConnection | null**:
- Check keyConnectionCounts — if >= MAX_CONNECTIONS_PER_KEY, return null (caller should close with 4008)
- Create connectionId via crypto.randomUUID()
- Create ClientConnection, start heartbeat
- Add to clients map, increment keyConnectionCounts
- Return the connection

**removeClient(connectionId: string)**:
- Get connection from map, destroy it, remove from map
- Decrement keyConnectionCounts (delete entry if 0)

**getConnectionCount(apiKeyId: number): number** — read from keyConnectionCounts map

**handleRedisMessage(channel: string, rawMessage: string)** — THE CRITICAL RELAY PATH:
- Parse the Redis channel to determine if it's a candle close or alert event.
  - Candle: channel matches `channel:exchange:{id}:candle:close:{symbol}:{timeframe}` — extract symbol and timeframe. Build external channel name `candles:{symbol}:{timeframe}`.
  - Alert: channel matches `channel:alerts:exchange:{id}` — parse the JSON payload to extract `symbol` and `timeframe`. Build external channel name `signals:{symbol}:{timeframe}`.
- For candle events:
  - Parse rawMessage as JSON (it's a serialized candle object)
  - Transform through `transformCandle()` from candle.transformer.ts
  - Build envelope: `{ type: 'candle_close', channel: externalChannel, data: transformedCandle }`
- For alert events:
  - Parse rawMessage as JSON (it's a serialized alert payload)
  - Build a signal envelope using deriveAlertDirection(payload.triggerLabel) and deriveAlertStrength(payload.triggerValue):
    ```
    { type: 'trade_signal', channel: externalChannel, data: {
      symbol: payload.symbol,
      exchange: this.exchangeName,
      timeframe: payload.timeframe,
      signal_type: 'momentum_signal',
      direction: deriveAlertDirection(payload.triggerLabel),
      strength: deriveAlertStrength(payload.triggerValue),
      price: String(payload.price),
      timestamp: payload.triggeredAt
    }}
    ```
  - CRITICAL: Do NOT forward `alertType`, `triggerValue`, `signalDelta`, `triggerLabel`, `sourceExchangeId`. These are proprietary/internal fields.
- Stringify the envelope ONCE, then iterate over all clients. For each client that `hasSubscription(externalChannel)`, call `client.send(stringified)`.
- Wrap in try/catch — log errors but never throw (relay failures must not crash the bridge).

**handlers.ts** — Message handler functions:
- `handleClientMessage(bridge: WebSocketBridge, connection: ClientConnection, raw: Buffer | string)`:
  - Parse as JSON (catch parse errors → send error envelope)
  - Validate through `clientMessageSchema` from schemas.ts (validation failure → send error envelope with code `INVALID_MESSAGE`)
  - If action is `subscribe`: for each channel, call `mapExternalChannel()`. If invalid → send error with code `INVALID_CHANNEL` and skip that channel. If valid → `connection.addSubscription(channel)`. After processing all, send `{ type: 'subscribed', channels: [...validChannels] }`.
  - If action is `unsubscribe`: for each channel, `connection.removeSubscription(channel)`. Send `{ type: 'unsubscribed', channels: [...removedChannels] }`.
- Helper `sendError(connection, code, message)`: builds error envelope and calls `connection.send()`.

Import transformCandle from '../transformers/candle.transformer.js'. Import deriveAlertDirection, deriveAlertStrength from '../transformers/alert.transformer.js'. Import mapExternalChannel from './types.js'. Import clientMessageSchema from './schemas.js'.

Use a local interface for the alert Redis payload (same pattern as alert.transformer.ts — local copy, not imported from internal packages). The interface should have: `symbol: string, timeframe: string, triggerLabel: string, triggerValue: string | null, price: number | string, triggeredAt: string, alertType?: string, signalDelta?: number, sourceExchangeId?: number`.
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/public-api/tsconfig.json` — no type errors. Verify no imports from `@livermore/indicators` or `@livermore/cache` (except the key utility types if needed — but actually we hardcode channel parsing, no need to import key builders). Grep for proprietary field names: `grep -rn "macdV\|macdv\|fastEMA\|slowEMA\|isSynthetic\|sequenceNum\|signalDelta" packages/public-api/src/ws/` should return zero matches (except in the local interface definition for signalDelta which is intentionally NOT forwarded).
  </verify>
  <done>
WebSocketBridge class manages a shared Redis subscriber with fan-out to subscribed clients. Alert and candle events are transformed through IP-protective transformers before relay. handleClientMessage processes subscribe/unsubscribe with channel validation. No proprietary field names leak through the relay path.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/public-api/tsconfig.json` passes with zero errors
2. `grep -rn "macdV\|fastEMA\|slowEMA\|isSynthetic\|sequenceNum" packages/public-api/src/ws/` returns no matches
3. All five files exist in `packages/public-api/src/ws/`
4. WebSocketBridge.handleRedisMessage uses transformCandle() for candles and deriveAlertDirection()/deriveAlertStrength() for signals — no raw forwarding
</verification>

<success_criteria>
- WebSocketBridge class can start/stop, manage client connections, and relay Redis pub/sub messages through IP-protective transformers
- ClientConnection handles heartbeat ping/pong every 30s, backpressure detection at 64KB/256KB thresholds, and subscription tracking
- Per-API-key connection counting is functional (addClient/removeClient maintain accurate counts)
- Zod schemas validate incoming subscribe/unsubscribe messages with channel format validation
- Zero proprietary field names in any outbound envelope
</success_criteria>

<output>
After completion, create `.planning/phases/42-websocket-bridge-backpressure/42-01-SUMMARY.md`
</output>
