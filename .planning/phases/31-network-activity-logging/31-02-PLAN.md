---
phase: 31-network-activity-logging
plan: 02
type: execute
wave: 2
depends_on: ["31-01"]
files_modified:
  - apps/api/src/services/types/service-registry.ts
  - apps/api/src/services/state-machine.service.ts
  - apps/api/src/services/control-channel.service.ts
  - apps/api/src/server.ts
autonomous: true

must_haves:
  truths:
    - "When StateMachineService.transition() succeeds, a state_transition entry appears in the exchange's Redis Stream"
    - "When an error is recorded via the control channel, an error entry appears in the exchange's Redis Stream"
    - "Heartbeat refreshes do NOT produce stream entries"
    - "Activity logger is optional -- state machine works without it (backward compatible)"
    - "Logger receives IP update when detectPublicIp resolves"
    - "Logger receives admin email when ControlChannelService initializes"
  artifacts:
    - path: "apps/api/src/services/types/service-registry.ts"
      provides: "activityLogger field on ServiceRegistry"
      contains: "activityLogger"
    - path: "apps/api/src/services/state-machine.service.ts"
      provides: "Activity logging after successful transitions"
      contains: "logTransition"
    - path: "apps/api/src/services/control-channel.service.ts"
      provides: "Activity logging on error in handleStart catch block"
      contains: "logError"
    - path: "apps/api/src/server.ts"
      provides: "NetworkActivityLogger creation and wiring into ServiceRegistry"
      contains: "NetworkActivityLogger"
  key_links:
    - from: "apps/api/src/services/state-machine.service.ts"
      to: "apps/api/src/services/network-activity-logger.ts"
      via: "optional constructor injection"
      pattern: "activityLogger\\?"
    - from: "apps/api/src/services/state-machine.service.ts"
      to: "logTransition"
      via: "fire-and-forget call after state update"
      pattern: "logTransition.*catch"
    - from: "apps/api/src/services/control-channel.service.ts"
      to: "logError"
      via: "call in handleStart catch block"
      pattern: "logError.*catch"
    - from: "apps/api/src/server.ts"
      to: "apps/api/src/services/network-activity-logger.ts"
      via: "instantiation and registry assignment"
      pattern: "new NetworkActivityLogger"
---

<objective>
Wire the NetworkActivityLogger into the state machine and error paths so that state transitions and errors are recorded to Redis Streams in production.

Purpose: Plan 01 created the logger as a standalone service. This plan connects it to the actual hook points -- StateMachineService.transition() for LOG-02 and error recording for LOG-03. After this plan, every state change and error across all instances is durably logged.
Output: 4 modified files -- ServiceRegistry type, StateMachineService, ControlChannelService, and server.ts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-network-activity-logging/31-RESEARCH.md
@.planning/phases/31-network-activity-logging/31-01-SUMMARY.md

Key source files:
@apps/api/src/services/types/service-registry.ts
@apps/api/src/services/state-machine.service.ts
@apps/api/src/services/control-channel.service.ts
@apps/api/src/server.ts
@apps/api/src/services/network-activity-logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add activityLogger to ServiceRegistry and wire into StateMachineService</name>
  <files>
    apps/api/src/services/types/service-registry.ts
    apps/api/src/services/state-machine.service.ts
  </files>
  <action>
    **Part A: Update ServiceRegistry type**

    In `apps/api/src/services/types/service-registry.ts`:

    1. Add import: `import type { NetworkActivityLogger } from '../network-activity-logger';`
    2. Add field to ServiceRegistry interface:
       ```typescript
       /** Phase 31: Network activity logger for Redis Streams event recording */
       activityLogger?: NetworkActivityLogger;
       ```
       Use optional (`?`) because the logger may not exist in all code paths (e.g., tests, idle mode placeholder).

    **Part B: Wire logger into StateMachineService**

    In `apps/api/src/services/state-machine.service.ts`:

    1. Add import: `import type { NetworkActivityLogger } from './network-activity-logger';`

    2. Add private field to the class:
       ```typescript
       private activityLogger: NetworkActivityLogger | null;
       ```

    3. Update constructor to accept optional logger:
       ```typescript
       constructor(registry: InstanceRegistryService, activityLogger?: NetworkActivityLogger) {
         this.registry = registry;
         this.activityLogger = activityLogger ?? null;
       }
       ```

    4. In the `transition()` method, add activity logging AFTER the existing `logger.info({ from, to }, 'State transition')` line (at the very end of the method, after all existing logic succeeds):
       ```typescript
       // Phase 31: Log transition to Redis Stream (fire-and-forget)
       if (this.activityLogger) {
         this.activityLogger.logTransition(from, to).catch(() => {
           // Already logged inside logTransition; swallow here
         });
       }
       ```

       CRITICAL: The `logTransition` call must be AFTER the state update succeeds (after `updateStatus`, `updateRuntimeState`, and `logger.info`). If the state update fails, we must NOT log a transition that didn't happen.

       CRITICAL: Use `.catch(() => {})` to swallow the promise rejection at the call site too. The logger itself catches internally, but the `.catch` here is a safety net. A stream write failure must NEVER crash the state machine.

    5. Do NOT add any logging to `resetToIdle()`. That method is for error recovery and is not a normal transition -- logging it could create misleading audit trail entries.

    6. Do NOT modify `heartbeatTick()` or any heartbeat-related code. LOG-06 explicitly forbids heartbeat logging.
  </action>
  <verify>
    Run `npx tsc --noEmit -p apps/api/tsconfig.json` -- no type errors.
    Grep state-machine.service.ts for `logTransition` to confirm it is called in transition().
    Grep state-machine.service.ts for `activityLogger` to confirm constructor accepts it.
    Grep service-registry.ts for `activityLogger` to confirm the field exists.
    Verify that `heartbeatTick` does NOT contain `logTransition` or `logError`.
    Verify that `resetToIdle` does NOT contain `logTransition` or `logError`.
  </verify>
  <done>
    ServiceRegistry has activityLogger field. StateMachineService accepts optional NetworkActivityLogger in constructor. transition() calls logTransition fire-and-forget after successful state update. heartbeatTick and resetToIdle have NO logging calls.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire logger into error paths and server.ts lifecycle</name>
  <files>
    apps/api/src/services/control-channel.service.ts
    apps/api/src/server.ts
  </files>
  <action>
    **Part A: Add error logging to ControlChannelService**

    In `apps/api/src/services/control-channel.service.ts`:

    1. In the `handleStart()` method's catch block (around line 603-615), add activity logging AFTER the existing `recordError` call:
       ```typescript
       // Existing code:
       await this.services.instanceRegistry.recordError(errorMessage);

       // Phase 31: Log error to Redis Stream (fire-and-forget)
       if (this.services.activityLogger) {
         this.services.activityLogger.logError(
           errorMessage,
           this.services.stateMachine.getCurrentState()
         ).catch(() => {});
       }
       ```

       This logs the error event to the stream with the current state at time of error, matching LOG-03.

    2. In the `handleStop()` method, add a shutdown transition log. Right AFTER `await this.services.stateMachine.transition('stopping')` (around line 637), add:
       ```typescript
       // Note: The transition itself is already logged by StateMachineService.
       // No additional logging needed here.
       ```
       Actually, do NOT add any extra logging here. The StateMachineService.transition() call already triggers logTransition via Plan 02 Task 1. Adding another log here would create duplicate entries.

    **Part B: Create and wire NetworkActivityLogger in server.ts**

    In `apps/api/src/server.ts`:

    1. Add import at the top (with other service imports):
       ```typescript
       import { NetworkActivityLogger } from './services/network-activity-logger';
       ```

    2. After creating `instanceRegistry` and `stateMachine` (around line 255-260), create the activity logger:
       ```typescript
       // Phase 31: Create activity logger for Redis Streams event recording
       const activityLogger = new NetworkActivityLogger({
         redis,
         exchangeId: activeExchangeId ?? 0,
         exchangeName: activeExchangeName ?? 'unknown',
         hostname: instanceRegistry['host'],  // Access hostname from registry (same os.hostname() call)
       });
       ```

       WAIT -- `instanceRegistry['host']` is private. Instead, use `hostname()` from `node:os` which is already imported by instance-registry.service.ts. Add the import:
       ```typescript
       import { hostname } from 'node:os';
       ```
       Then use:
       ```typescript
       const activityLogger = new NetworkActivityLogger({
         redis,
         exchangeId: activeExchangeId ?? 0,
         exchangeName: activeExchangeName ?? 'unknown',
         hostname: hostname(),
       });
       ```

    3. Update `StateMachineService` construction to pass the logger:
       ```typescript
       const stateMachine = new StateMachineService(instanceRegistry, activityLogger);
       ```

    4. In the `detectPublicIp` callback inside `register()` (around line 118-124 of instance-registry.service.ts) -- WAIT, we cannot modify instance-registry.service.ts in this task. Instead, add the IP update in server.ts.

       After the `instanceRegistry.register()` call in autostart mode (around line 264), the IP detection already happens inside `register()`. We need the logger to get the IP too. Add a parallel IP detection call:
       ```typescript
       // Phase 31: Update activity logger with IP when detected
       import { detectPublicIp } from './utils/detect-public-ip';
       ```
       (Add this import at the top with other imports.)

       Then after creating the activityLogger, start an async IP update:
       ```typescript
       // Phase 31: Update activity logger IP asynchronously
       detectPublicIp().then((ip) => {
         if (ip) {
           activityLogger.setIp(ip);
         }
       });
       ```

       NOTE: `detectPublicIp` is already imported in instance-registry.service.ts but NOT in server.ts. Check first -- if it is already imported, skip. If not, add the import.

    5. In the `initControlChannelService` function (around line 113-127), after the existing `instanceRegistry.setAdminInfo(clerkUserId, clerkUserId)` call, add:
       ```typescript
       // Phase 31: Set admin email on activity logger
       if (globalServiceRegistry?.activityLogger) {
         globalServiceRegistry.activityLogger.setAdminEmail(clerkUserId);
       }
       ```

    6. Add `activityLogger` to the ServiceRegistry object construction (around line 470-489):
       ```typescript
       // Phase 31: Network activity logger for Redis Streams
       activityLogger,
       ```

    7. In the `handleStart` path of control-channel.service.ts (around line 508-514), where a NEW StateMachineService is created for the resolved exchange, we need to also create a new activity logger. In `handleStart` after creating the new registry and state machine:

       WAIT -- this is in control-channel.service.ts, not server.ts. Let me handle this properly.

       In `control-channel.service.ts` `handleStart()`, after the lines:
       ```typescript
       this.services.instanceRegistry = registry;
       this.services.stateMachine = new StateMachineService(registry);
       ```
       Change to:
       ```typescript
       // Phase 31: Create activity logger for this exchange
       const { NetworkActivityLogger } = await import('./network-activity-logger');
       const { hostname } = await import('node:os');
       const { detectPublicIp } = await import('../utils/detect-public-ip');
       const activityLogger = new NetworkActivityLogger({
         redis: this.services.redis,
         exchangeId: this.services.exchangeId!,
         exchangeName: exchangeName,
         hostname: hostname(),
         adminEmail: this.identitySub,
       });
       this.services.activityLogger = activityLogger;
       this.services.stateMachine = new StateMachineService(registry, activityLogger);

       // Update logger IP asynchronously
       detectPublicIp().then((ip) => {
         if (ip) activityLogger.setIp(ip);
       });
       ```

       ACTUALLY -- do NOT use dynamic imports. Use static imports at the top of the file instead. Add at the top of control-channel.service.ts:
       ```typescript
       import { hostname } from 'node:os';
       import { NetworkActivityLogger } from './network-activity-logger';
       import { detectPublicIp } from '../utils/detect-public-ip';
       ```

       Then in handleStart (after creating registry, BEFORE creating state machine):
       ```typescript
       // Phase 31: Create activity logger for this exchange
       const activityLogger = new NetworkActivityLogger({
         redis: this.services.redis,
         exchangeId: this.services.exchangeId!,
         exchangeName: exchangeName,
         hostname: hostname(),
         adminEmail: this.identitySub,
       });
       this.services.activityLogger = activityLogger;
       this.services.stateMachine = new StateMachineService(registry, activityLogger);

       // Update logger IP asynchronously
       detectPublicIp().then((ip) => {
         if (ip) activityLogger.setIp(ip);
       });
       ```

    CRITICAL CONSTRAINTS:
    - The activity logger is fire-and-forget. It must NEVER block startup, transitions, or shutdown.
    - The autostart path in server.ts and the handleStart path in control-channel.service.ts BOTH need their own logger creation, because handleStart creates a fresh registry and state machine.
    - `hostname()` from `node:os` is synchronous -- safe to call inline.
    - `detectPublicIp()` is async -- call it fire-and-forget with `.then()`.
  </action>
  <verify>
    Run `npx tsc --noEmit -p apps/api/tsconfig.json` -- no type errors.
    Grep server.ts for `NetworkActivityLogger` to confirm creation.
    Grep server.ts for `activityLogger` to confirm it is in ServiceRegistry.
    Grep control-channel.service.ts for `NetworkActivityLogger` to confirm handleStart creates one.
    Grep control-channel.service.ts for `logError` to confirm error logging in catch block.
    Grep server.ts for `setAdminEmail` to confirm admin identity propagation.
    Verify that instance-registry.service.ts is NOT modified (heartbeat must not log).
  </verify>
  <done>
    NetworkActivityLogger created in both autostart (server.ts) and handleStart (control-channel.service.ts) paths. StateMachineService receives logger in constructor. Error events logged in handleStart catch block. Admin email set on logger when ControlChannelService initializes. IP set asynchronously via detectPublicIp. instance-registry.service.ts is unchanged (no heartbeat logging). All stream writes are fire-and-forget.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit -p apps/api/tsconfig.json` passes with no errors
- State transition logging: Manually trace `StateMachineService.transition()` -> `this.activityLogger.logTransition(from, to)` -> `redis.xadd('logs:network:...')`
- Error logging: Trace `handleStart catch` -> `this.services.activityLogger.logError(errorMessage, currentState)` -> `redis.xadd('logs:network:...')`
- Heartbeat exclusion: `instance-registry.service.ts` has NO references to `activityLogger`, `logTransition`, or `logError`
- Fire-and-forget: Every `logTransition` and `logError` call has `.catch(() => {})` at the call site
- Admin identity: `initControlChannelService` calls `activityLogger.setAdminEmail`
- IP identity: Both server.ts and control-channel.service.ts call `detectPublicIp` -> `activityLogger.setIp`
</verification>

<success_criteria>
- LOG-01: Stream key `logs:network:{exchange_name}` used via networkActivityStreamKey (from Plan 01)
- LOG-02: State transitions logged by StateMachineService.transition() -> logTransition()
- LOG-03: Errors logged by handleStart catch -> logError() with current state
- LOG-04: MINID trimming on every XADD (from Plan 01 logger)
- LOG-05: Consistent field names (from Plan 01 schemas)
- LOG-06: Heartbeat NEVER logged -- instance-registry.service.ts is not modified, no logging in heartbeatTick
</success_criteria>

<output>
After completion, create `.planning/phases/31-network-activity-logging/31-02-SUMMARY.md`
</output>
