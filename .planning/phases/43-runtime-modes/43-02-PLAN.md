---
phase: 43-runtime-modes
plan: 02
type: execute
wave: 2
depends_on: ["43-01"]
files_modified:
  - apps/api/src/server.ts
autonomous: true

must_haves:
  truths:
    - "Server starts in pw-host mode when LIVERMORE_MODE=pw-host without Coinbase/Clerk/Discord env vars"
    - "In pw-host mode, no exchange adapter, indicator service, alert service, tRPC, Clerk, or Discord is initialized"
    - "In pw-host mode, public API routes serve data from Redis cache and database"
    - "In pw-host mode, /health returns mode: 'pw-host' with database and redis status (no exchange status)"
    - "In exchange mode, server starts exactly as before (zero behavioral change)"
    - "In pw-host mode, WebSocket bridge is created when LIVERMORE_EXCHANGE_ID and LIVERMORE_EXCHANGE_NAME env vars are provided"
    - "Graceful shutdown in pw-host mode only shuts down Redis, DB, and Fastify (no exchange services)"
  artifacts:
    - path: "apps/api/src/server.ts"
      provides: "Mode-gated startup sequence"
      contains: "resolveMode"
  key_links:
    - from: "apps/api/src/server.ts"
      to: "packages/utils/src/validation/env-validator.ts"
      via: "validateEnv(mode) call"
      pattern: "validateEnv\\(mode\\)"
    - from: "apps/api/src/server.ts"
      to: "packages/schemas/src/env/config.schema.ts"
      via: "resolveMode() import"
      pattern: "resolveMode"
---

<objective>
Refactor server.ts to branch on RuntimeMode, skipping all exchange-specific service initialization in pw-host mode while preserving the full data pipeline in exchange mode.

Purpose: MODE-02 and MODE-03 require pw-host mode to skip exchange adapters, warmup, indicators, alerts, Clerk, tRPC, and Discord -- only serving the public API from Redis cache and database. MODE-04 requires the health endpoint to report mode-appropriate status.

Output: server.ts with mode-gated initialization that enables headless public API instances.
</objective>

<execution_context>
@C:/Users/Mike McWilliams/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Mike McWilliams/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-runtime-modes/43-RESEARCH.md
@.planning/phases/43-runtime-modes/43-01-SUMMARY.md

@apps/api/src/server.ts
@packages/public-api/src/plugin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor server.ts startup for mode-gated initialization</name>
  <files>apps/api/src/server.ts</files>
  <action>
  Refactor the `start()` function in `server.ts` to branch on runtime mode. The key principle: in pw-host mode, skip SERVICE CREATION entirely (not just skip starting them).

  **Step 1: Early mode resolution (top of start())**

  Add before the existing `validateEnv()` call:
  ```typescript
  import { resolveMode } from '@livermore/schemas';
  // ... inside start():
  const mode = resolveMode();
  const isPwHost = mode === 'pw-host';
  ```

  Pass mode to validateEnv:
  ```typescript
  const config = validateEnv(mode);
  ```

  Update the startup log to include mode:
  ```typescript
  logger.info(
    { mode, autostart: isAutostart, exchange: cliArgs.autostart },
    'Starting Livermore API server...'
  );
  ```

  **Step 2: pw-host early exit path**

  After the pre-flight connection checks (DB + Redis), add a pw-host branch that registers ONLY what's needed and then starts the listener. The pw-host path should:

  1. Keep: Fastify creation, CORS registration, WebSocket plugin registration
  2. Keep: DB connection + test, Redis connection + test
  3. Keep: publicApiPlugin registration at /public/v1 (with optional WS bridge via env vars)
  4. Skip: Clerk webhook, clerkPlugin, tRPC, Discord, all exchange services, instance registry, state machine, network activity logger, control channel
  5. Add: pw-host-specific health endpoint
  6. Start: Fastify listener + simplified shutdown handler

  For the WebSocket bridge in pw-host mode, read exchange identity from env vars:
  ```typescript
  const exchangeIdStr = process.env.LIVERMORE_EXCHANGE_ID;
  const exchangeNameStr = process.env.LIVERMORE_EXCHANGE_NAME;
  const pwHostExchangeId = exchangeIdStr ? parseInt(exchangeIdStr, 10) : undefined;
  const pwHostExchangeName = exchangeNameStr || undefined;
  ```
  Pass these to publicApiPlugin opts so the WS bridge can be created if both are provided.

  **Step 3: Structure the branching**

  The cleanest approach: after pre-flight checks, use an `if (isPwHost) { ... return; }` block for the entire pw-host path. This avoids wrapping the large existing exchange-mode code in an else block. The structure:

  ```typescript
  async function start() {
    const mode = resolveMode();
    const isPwHost = mode === 'pw-host';
    const cliArgs = parseCliArgs();
    const isAutostart = cliArgs.autostart !== null;

    logger.info({ mode, autostart: isAutostart }, 'Starting Livermore API server...');

    const config = validateEnv(mode);

    // Create Fastify, CORS, WebSocket (shared)
    // ...

    if (!isPwHost) {
      // Clerk webhook + Clerk plugin (exchange mode only)
      fastify.post('/webhooks/clerk', clerkWebhookHandler);
      await fastify.register(clerkPlugin);
    }

    // Pre-flight: DB + Redis (shared)
    // ...

    if (isPwHost) {
      // === PW-HOST MODE ===
      // Register public API with optional WS bridge
      const exchangeIdStr = process.env.LIVERMORE_EXCHANGE_ID;
      const exchangeNameStr = process.env.LIVERMORE_EXCHANGE_NAME;
      await fastify.register(publicApiPlugin, {
        prefix: '/public/v1',
        redis,
        exchangeId: exchangeIdStr ? parseInt(exchangeIdStr, 10) : undefined,
        exchangeName: exchangeNameStr || undefined,
      });

      // Health endpoint (pw-host version)
      fastify.get('/health', async () => ({
        status: 'ok',
        mode: 'pw-host',
        timestamp: new Date().toISOString(),
        services: {
          database: 'connected',
          redis: 'connected',
        },
      }));

      // Start listener
      const port = config.API_PORT;
      const host = config.API_HOST;
      await fastify.listen({ port, host });
      logger.info({ mode: 'pw-host', host, port }, 'pw-host server listening');

      // Simplified shutdown
      const shutdown = async () => {
        logger.info('Shutting down pw-host server...');
        await redis.quit();
        await fastify.close();
        logger.info('pw-host server shut down');
        process.exit(0);
      };
      process.on('SIGINT', shutdown);
      process.on('SIGTERM', shutdown);
      return; // Exit start() -- don't run exchange-mode code below
    }

    // === EXCHANGE MODE (everything below is unchanged) ===
    // ... existing code from activeExchangeId through end of function
  }
  ```

  **Step 4: Exchange mode health endpoint update**

  Update the existing health endpoint in exchange mode to also include `mode: 'exchange'`:
  ```typescript
  fastify.get('/health', async () => {
    const runtimeState = getRuntimeState();
    return {
      status: 'ok',
      mode: 'exchange',
      timestamp: new Date().toISOString(),
      // ... rest unchanged
    };
  });
  ```

  **Step 5: pw-host mode does NOT need subscriber Redis**

  The subscriber Redis duplicate is only needed for exchange-mode services (BoundaryRestService uses psubscribe). In pw-host mode, the publicApiPlugin creates its own subscriber internally for the WebSocket bridge. Do not create `subscriberRedis` in pw-host mode.

  **CRITICAL: Do not modify any existing exchange-mode behavior.** The entire exchange code path must remain identical to the current code. The only exchange-mode change is adding `mode: 'exchange'` to the health response.

  **CRITICAL: Cast config appropriately.** In pw-host mode, `validateEnv(mode)` returns `PwHostEnvConfig` which doesn't have Coinbase/Clerk fields. Since pw-host early-returns before accessing those fields, no runtime issue. But for TypeScript, the config variable after the if/return block is always exchange mode, so you can safely use `config as EnvConfig` in the exchange-mode code, OR use a single const assignment like:
  ```typescript
  const config = validateEnv(mode);
  // ... pw-host block uses config.API_PORT, config.API_HOST (both modes have these)
  // ... after pw-host return, only exchange mode runs:
  const exchangeConfig = config as EnvConfig; // safe: pw-host returned above
  ```
  </action>
  <verify>
  1. `npx tsc --noEmit -p apps/api/tsconfig.json` compiles without errors
  2. Read through the final server.ts and verify:
     - resolveMode() is called before validateEnv()
     - pw-host path registers ONLY: CORS, WebSocket, publicApiPlugin, /health, listener
     - pw-host path does NOT import or reference: clerkPlugin, tRPC, Discord, exchange services
     - Exchange mode code is unchanged except for adding `mode: 'exchange'` to health response
     - pw-host shutdown only cleans up Redis + Fastify
  </verify>
  <done>
  server.ts branches on LIVERMORE_MODE:
  - pw-host: Only Fastify + CORS + WS + DB + Redis + publicApiPlugin + /health. No Clerk, tRPC, Discord, exchange services.
  - exchange: Identical to current behavior plus `mode: 'exchange'` in health response.
  - Health endpoint reports mode and mode-appropriate services in both modes.
  - WebSocket bridge available in pw-host when LIVERMORE_EXCHANGE_ID/NAME env vars are set.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p apps/api/tsconfig.json` passes
2. `npx tsc --noEmit -p packages/schemas/tsconfig.json` passes
3. `npx tsc --noEmit -p packages/utils/tsconfig.json` passes
4. In pw-host mode path: zero references to Coinbase, Clerk, Discord, ExchangeAdapterFactory, IndicatorCalculationService, AlertEvaluationService, ControlChannelService, InstanceRegistryService, StateMachineService, NetworkActivityLogger, SymbolSourceService, StartupBackfillService, BoundaryRestService, tRPC
5. Exchange mode code path is unchanged (diff should only show: mode resolution at top, Clerk/webhook wrapped in `if (!isPwHost)`, `mode: 'exchange'` in health response)
6. pw-host health returns `{ status: 'ok', mode: 'pw-host', services: { database, redis } }`
7. Exchange health returns `{ status: 'ok', mode: 'exchange', services: { database, redis, discord, controlChannel }, exchange: { connectionState, connected } }`
</verification>

<success_criteria>
- Server compiles and can start in pw-host mode without Coinbase/Clerk/Discord env vars
- In pw-host mode, only public API, health, DB, and Redis are initialized
- In exchange mode, all services start exactly as before
- Health endpoint reports runtime mode and mode-appropriate status
- WebSocket bridge optionally available in pw-host via LIVERMORE_EXCHANGE_ID/NAME env vars
- Zero behavioral change to exchange mode
</success_criteria>

<output>
After completion, create `.planning/phases/43-runtime-modes/43-02-SUMMARY.md`
</output>
