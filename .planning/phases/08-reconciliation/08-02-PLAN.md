---
phase: 08-reconciliation
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - packages/coinbase-client/src/reconciliation/gap-detector.ts
  - packages/coinbase-client/src/reconciliation/types.ts
  - packages/coinbase-client/src/reconciliation/index.ts
autonomous: true

must_haves:
  truths:
    - "Gap detection identifies missing 5m candle timestamps in cache"
    - "Gaps are detected by comparing cached timestamps to expected sequence"
    - "Gap info includes start timestamp, end timestamp, and count"
    - "getTimestampsOnly efficiently retrieves only scores (not full candle data)"
  artifacts:
    - path: "packages/coinbase-client/src/reconciliation/gap-detector.ts"
      provides: "Pure functions for detecting gaps in cached candle sequences"
      exports: ["detectGaps", "getTimestampsOnly"]
    - path: "packages/coinbase-client/src/reconciliation/types.ts"
      provides: "GapInfo interface added"
      contains: "interface GapInfo"
  key_links:
    - from: "gap-detector.ts"
      to: "@livermore/utils"
      via: "import getCandleTimestamps"
      pattern: "getCandleTimestamps\\("
    - from: "gap-detector.ts"
      to: "ioredis"
      via: "zrangebyscore with WITHSCORES"
      pattern: "redis\\.zrangebyscore\\("
---

<objective>
Create gap detection utilities for identifying missing candles in cache.

Purpose: Enable future gap-filling by providing pure functions to detect gaps in cached candle sequences. This separates gap detection logic from service orchestration.

Output: detectGaps function that compares cached timestamps against expected sequence and returns GapInfo array.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-reconciliation/08-01-SUMMARY.md

# Reference existing patterns
@packages/cache/src/strategies/candle-cache.ts
@packages/utils/src/time/timeframe.ts
@packages/cache/src/keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GapInfo type to types.ts</name>
  <files>
    packages/coinbase-client/src/reconciliation/types.ts
  </files>
  <action>
Add GapInfo interface to the existing types.ts file:

```typescript
/**
 * Information about a detected gap in candle sequence
 */
export interface GapInfo {
  /** Symbol with the gap */
  symbol: string;
  /** Timeframe with the gap */
  timeframe: Timeframe;
  /** First missing candle timestamp */
  start: number;
  /** Last missing candle timestamp */
  end: number;
  /** Number of missing candles */
  count: number;
}
```

Import Timeframe from @livermore/schemas if not already imported.
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/coinbase-client/tsconfig.json` - no errors.
  </verify>
  <done>
GapInfo interface added to types.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create gap-detector.ts with detection logic</name>
  <files>
    packages/coinbase-client/src/reconciliation/gap-detector.ts
  </files>
  <action>
Create gap-detector.ts:

```typescript
import type { Redis } from 'ioredis';
import type { Timeframe } from '@livermore/schemas';
import { getCandleTimestamps, timeframeToMs, getCandleTimestamp } from '@livermore/utils';
import { candleKey } from '@livermore/cache';
import type { GapInfo } from './types';

/**
 * Get only timestamps (scores) from a Redis sorted set
 * More efficient than deserializing full candle data for gap detection
 *
 * @param redis - Redis client
 * @param key - Sorted set key
 * @param start - Start timestamp (inclusive)
 * @param end - End timestamp (inclusive)
 * @returns Array of timestamps
 */
export async function getTimestampsOnly(
  redis: Redis,
  key: string,
  start: number,
  end: number
): Promise<number[]> {
  // ZRANGEBYSCORE key min max WITHSCORES returns [member, score, member, score, ...]
  const results = await redis.zrangebyscore(key, start, end, 'WITHSCORES');

  // Extract every other element (scores are at odd indices)
  const timestamps: number[] = [];
  for (let i = 1; i < results.length; i += 2) {
    timestamps.push(parseInt(results[i], 10));
  }
  return timestamps;
}

/**
 * Detect gaps in a cached candle sequence
 *
 * Compares actual cached timestamps against expected timestamps based on
 * timeframe interval. Returns array of gap ranges.
 *
 * @param cachedTimestamps - Array of timestamps found in cache
 * @param expectedStart - Expected start of range (floored to candle boundary)
 * @param expectedEnd - Expected end of range (floored to candle boundary)
 * @param timeframe - Timeframe for interval calculation
 * @param symbol - Symbol for GapInfo result
 * @returns Array of detected gaps
 */
export function detectGaps(
  cachedTimestamps: number[],
  expectedStart: number,
  expectedEnd: number,
  timeframe: Timeframe,
  symbol: string
): GapInfo[] {
  const intervalMs = timeframeToMs(timeframe);
  const cachedSet = new Set(cachedTimestamps);
  const gaps: GapInfo[] = [];

  let gapStart: number | null = null;
  let gapCount = 0;

  // Generate expected timestamps and check each one
  for (let ts = expectedStart; ts <= expectedEnd; ts += intervalMs) {
    if (!cachedSet.has(ts)) {
      // Missing timestamp - start or continue gap
      if (gapStart === null) {
        gapStart = ts;
      }
      gapCount++;
    } else if (gapStart !== null) {
      // Found cached timestamp after a gap - record the gap
      gaps.push({
        symbol,
        timeframe,
        start: gapStart,
        end: ts - intervalMs,
        count: gapCount,
      });
      gapStart = null;
      gapCount = 0;
    }
  }

  // Handle trailing gap (gap extends to end of range)
  if (gapStart !== null) {
    gaps.push({
      symbol,
      timeframe,
      start: gapStart,
      end: expectedEnd,
      count: gapCount,
    });
  }

  return gaps;
}

/**
 * Detect gaps for a symbol/timeframe by querying cache
 *
 * Convenience function that handles Redis query and gap detection
 *
 * @param redis - Redis client
 * @param userId - User ID for cache key
 * @param exchangeId - Exchange ID for cache key
 * @param symbol - Trading symbol
 * @param timeframe - Candle timeframe
 * @param lookbackMs - How far back to scan (e.g., 30 * 60 * 1000 for 30 minutes)
 * @returns Array of detected gaps
 */
export async function detectGapsForSymbol(
  redis: Redis,
  userId: number,
  exchangeId: number,
  symbol: string,
  timeframe: Timeframe,
  lookbackMs: number
): Promise<GapInfo[]> {
  const now = Date.now();
  const intervalMs = timeframeToMs(timeframe);

  // Floor to candle boundaries
  const end = getCandleTimestamp(now, timeframe);
  const start = getCandleTimestamp(now - lookbackMs, timeframe);

  // Get cached timestamps
  const key = candleKey(userId, exchangeId, symbol, timeframe);
  const cachedTimestamps = await getTimestampsOnly(redis, key, start, end);

  // Detect gaps
  return detectGaps(cachedTimestamps, start, end, timeframe, symbol);
}
```
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/coinbase-client/tsconfig.json` - no errors.
Verify detectGaps handles empty arrays, single elements, and trailing gaps correctly.
  </verify>
  <done>
gap-detector.ts created with getTimestampsOnly, detectGaps, and detectGapsForSymbol functions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update index.ts with gap detector exports</name>
  <files>
    packages/coinbase-client/src/reconciliation/index.ts
  </files>
  <action>
Update index.ts to add gap detector exports:

```typescript
export { BoundaryRestService } from './boundary-rest-service';
export { detectBoundaries, isTimeframeBoundary } from './boundary-detector';
export { detectGaps, detectGapsForSymbol, getTimestampsOnly } from './gap-detector';
export type { BoundaryRestConfig, TimeframeBoundary, GapInfo } from './types';
export { DEFAULT_BOUNDARY_CONFIG } from './types';
```
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/coinbase-client/tsconfig.json` - no errors.
Verify all exports are accessible via the index.
  </verify>
  <done>
Gap detector functions exported from reconciliation module.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit -p packages/coinbase-client/tsconfig.json`
2. GapInfo type exported from types.ts
3. detectGaps returns correct gaps for various scenarios (no gaps, single gap, multiple gaps, trailing gap)
4. getTimestampsOnly efficiently parses WITHSCORES output
5. No references to node-cron, setInterval, or scheduled jobs
</verification>

<success_criteria>
- detectGaps([1,2,4,5], 1, 6, '5m', 'BTC-USD') identifies gap at timestamp 3
- detectGapsForSymbol queries cache and returns GapInfo array
- getTimestampsOnly extracts scores from WITHSCORES response
- All functions are pure (no side effects except Redis reads)
</success_criteria>

<output>
After completion, create `.planning/phases/08-reconciliation/08-02-SUMMARY.md`
</output>
