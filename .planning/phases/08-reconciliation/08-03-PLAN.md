---
phase: 08-reconciliation
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - packages/coinbase-client/src/index.ts
  - apps/api/src/server.ts
autonomous: true

must_haves:
  truths:
    - "BoundaryRestService exported from @livermore/coinbase-client"
    - "BoundaryRestService starts after backfill and indicators in server.ts"
    - "Separate Redis subscriber connection created for psubscribe"
    - "Service stops gracefully on server shutdown"
  artifacts:
    - path: "packages/coinbase-client/src/index.ts"
      provides: "BoundaryRestService and related exports"
      exports: ["BoundaryRestService", "DEFAULT_BOUNDARY_CONFIG"]
    - path: "apps/api/src/server.ts"
      provides: "BoundaryRestService integration"
      contains: "boundaryRestService.start"
  key_links:
    - from: "server.ts"
      to: "BoundaryRestService"
      via: "import from @livermore/coinbase-client"
      pattern: "import.*BoundaryRestService"
    - from: "server.ts"
      to: "boundaryRestService.start()"
      via: "startup sequence"
      pattern: "boundaryRestService\\.start\\("
    - from: "server.ts"
      to: "subscriberRedis"
      via: "separate connection for psubscribe"
      pattern: "subscriberRedis.*=.*Redis"
---

<objective>
Integrate BoundaryRestService into server startup sequence.

Purpose: Wire the event-driven boundary REST service into the application, ensuring it starts after backfill and indicators and receives 5m candle:close events.

Output: Server starts BoundaryRestService as part of its startup sequence; service subscribes to 5m candle:close and fires REST at boundaries.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-reconciliation/08-01-SUMMARY.md

# Reference existing integration
@packages/coinbase-client/src/index.ts
@apps/api/src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Export reconciliation module from coinbase-client</name>
  <files>
    packages/coinbase-client/src/index.ts
  </files>
  <action>
Add exports to packages/coinbase-client/src/index.ts:

```typescript
// Reconciliation (event-driven boundary REST)
export { BoundaryRestService, detectBoundaries, isTimeframeBoundary, detectGaps, detectGapsForSymbol, getTimestampsOnly } from './reconciliation';
export type { BoundaryRestConfig, TimeframeBoundary, GapInfo } from './reconciliation';
export { DEFAULT_BOUNDARY_CONFIG } from './reconciliation';
```

Place these exports after the existing backfill exports.

NOTE: Use `export type` for type-only exports due to isolatedModules (same pattern as BackfillConfig in existing file).
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/coinbase-client/tsconfig.json` - no errors.
Check that BoundaryRestService is exported.
  </verify>
  <done>
Reconciliation module exported from @livermore/coinbase-client package.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate BoundaryRestService into server.ts</name>
  <files>
    apps/api/src/server.ts
  </files>
  <action>
Update apps/api/src/server.ts:

1. Add import at top (near other coinbase-client imports):
```typescript
import { BoundaryRestService, DEFAULT_BOUNDARY_CONFIG } from '@livermore/coinbase-client';
```

2. Create separate Redis subscriber connection (required for psubscribe - cannot share with main client):
```typescript
// Near the existing Redis client creation
const subscriberRedis = redisClient.duplicate();
```

3. Instantiate BoundaryRestService (after StartupBackfillService instantiation):
```typescript
const boundaryRestService = new BoundaryRestService(
  apiKeyId,
  privateKeyPem,
  redisClient,
  subscriberRedis,
  {
    userId: DEFAULT_BOUNDARY_CONFIG.userId,
    exchangeId: DEFAULT_BOUNDARY_CONFIG.exchangeId,
    higherTimeframes: ['15m', '1h', '4h', '1d'],
  }
);
```

4. Start BoundaryRestService in startup sequence (AFTER backfill AND indicators, BEFORE WebSocket):
```typescript
// Step 4: Start boundary REST service (event-driven higher timeframe fetching)
logger.info('Starting BoundaryRestService...');
await boundaryRestService.start(symbols);
logger.info('BoundaryRestService started');
```

The startup order should be:
1. Backfill (populate cache)
2. Indicators (start listening for candle:close)
3. BoundaryRestService (start listening for 5m boundaries)
4. WebSocket/CoinbaseAdapter (start producing candle:close events)

This ensures BoundaryRestService is subscribed before any candle:close events fire.

5. Add graceful shutdown (in shutdown handler):
```typescript
await boundaryRestService.stop();
await subscriberRedis.quit();
```
  </action>
  <verify>
Run `npx tsc --noEmit -p apps/api/tsconfig.json` - no errors.
Check startup sequence: backfill -> indicators -> boundaryRestService -> WebSocket.
  </verify>
  <done>
BoundaryRestService integrated into server startup. Service starts after indicators and before WebSocket.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors for both packages
2. BoundaryRestService importable from @livermore/coinbase-client
3. Server startup includes BoundaryRestService.start() call
4. Separate Redis subscriber connection used for psubscribe
5. Graceful shutdown calls boundaryRestService.stop()
6. No references to node-cron, setInterval, or scheduled jobs
</verification>

<success_criteria>
- Server starts successfully with BoundaryRestService
- BoundaryRestService subscribed to 5m candle:close pattern before WebSocket starts
- When 5m candle closes at 15m/1h/4h/1d boundary, REST calls fire for higher timeframes
- Shutdown sequence properly stops BoundaryRestService
</success_criteria>

<output>
After completion, create `.planning/phases/08-reconciliation/08-03-SUMMARY.md`
</output>
