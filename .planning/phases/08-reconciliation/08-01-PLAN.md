---
phase: 08-reconciliation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/coinbase-client/src/reconciliation/types.ts
  - packages/coinbase-client/src/reconciliation/boundary-detector.ts
  - packages/coinbase-client/src/reconciliation/boundary-rest-service.ts
  - packages/coinbase-client/src/reconciliation/index.ts
autonomous: true

must_haves:
  truths:
    - "5m candle close triggers higher timeframe REST calls at boundaries"
    - "15m boundary detected every 3rd 5m candle (00, 15, 30, 45 minutes)"
    - "1h boundary detected every 12th 5m candle (00 minutes)"
    - "4h boundary detected every 48th 5m candle (00, 04, 08, 12, 16, 20 hours)"
    - "1d boundary detected every 288th 5m candle (00:00 UTC)"
    - "REST calls are rate-limited (5 req/batch, 1s delay)"
  artifacts:
    - path: "packages/coinbase-client/src/reconciliation/types.ts"
      provides: "BoundaryRestConfig, TimeframeBoundary interfaces"
      exports: ["BoundaryRestConfig", "DEFAULT_BOUNDARY_CONFIG", "TimeframeBoundary"]
    - path: "packages/coinbase-client/src/reconciliation/boundary-detector.ts"
      provides: "Pure function to detect which timeframe boundaries a 5m close aligns with"
      exports: ["detectBoundaries", "isTimeframeBoundary"]
    - path: "packages/coinbase-client/src/reconciliation/boundary-rest-service.ts"
      provides: "Service that listens to 5m candle:close and fires REST at boundaries"
      exports: ["BoundaryRestService"]
    - path: "packages/coinbase-client/src/reconciliation/index.ts"
      provides: "Module re-exports"
  key_links:
    - from: "boundary-rest-service.ts"
      to: "boundary-detector.ts"
      via: "import detectBoundaries"
      pattern: "detectBoundaries\\(timestamp\\)"
    - from: "boundary-rest-service.ts"
      to: "CoinbaseRestClient"
      via: "getCandles()"
      pattern: "restClient\\.getCandles\\("
    - from: "boundary-rest-service.ts"
      to: "CandleCacheStrategy"
      via: "addCandleIfNewer()"
      pattern: "candleCache\\.addCandleIfNewer\\("
---

<objective>
Create event-driven boundary detection and REST fetching for higher timeframes.

Purpose: Enable real-time indicator calculations for 15m, 1h, 4h, 1d timeframes by fetching fresh candles from REST API at timeframe boundaries, triggered by 5m WebSocket candle close events.

Output: BoundaryRestService that subscribes to 5m candle:close events and fires rate-limited REST calls at timeframe boundaries.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/CANDLES-CHANNEL-FINDINGS.md

# Reference existing patterns
@packages/coinbase-client/src/backfill/types.ts
@packages/coinbase-client/src/backfill/startup-backfill-service.ts
@packages/utils/src/time/timeframe.ts
@packages/cache/src/keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reconciliation types and boundary detector</name>
  <files>
    packages/coinbase-client/src/reconciliation/types.ts
    packages/coinbase-client/src/reconciliation/boundary-detector.ts
  </files>
  <action>
Create types.ts with:
- `BoundaryRestConfig` interface: userId, exchangeId, batchSize (default 5), batchDelayMs (default 1000), higherTimeframes (default ['15m', '1h', '4h', '1d'])
- `DEFAULT_BOUNDARY_CONFIG` constant with defaults matching StartupBackfillService
- `TimeframeBoundary` interface: timeframe, triggered (boolean)

Create boundary-detector.ts with:
- `isTimeframeBoundary(timestamp: number, timeframe: Timeframe): boolean` - checks if timestamp aligns with timeframe boundary
  - Use timeframeToMs from @livermore/utils
  - Return `timestamp % timeframeToMs(timeframe) === 0`
- `detectBoundaries(timestamp: number, timeframes: Timeframe[]): TimeframeBoundary[]` - returns array of boundaries with triggered flag
  - For each timeframe, call isTimeframeBoundary
  - Return all timeframes with triggered=true for those that match

Boundary alignment logic (all times UTC):
- 15m: 00, 15, 30, 45 minutes (every 15 * 60 * 1000 = 900000ms)
- 1h: 00 minutes (every 60 * 60 * 1000 = 3600000ms)
- 4h: 00:00, 04:00, 08:00, 12:00, 16:00, 20:00 (every 4 * 3600000 = 14400000ms)
- 1d: 00:00 UTC (every 24 * 3600000 = 86400000ms)

Example: timestamp 1737619200000 (2025-01-23 12:00:00 UTC)
- 15m: true (12:00 is 0 mod 15)
- 1h: true (12:00 is 0 mod 60)
- 4h: true (12:00 is 0 mod 4h = 12 is divisible by 4)
- 1d: false (12:00 is not 00:00)

Import Timeframe from @livermore/schemas, timeframeToMs from @livermore/utils.
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/coinbase-client/tsconfig.json` - no errors.
Verify types are exported correctly by checking file contents.
  </verify>
  <done>
Types defined. detectBoundaries returns correct boundary flags for any 5m timestamp.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BoundaryRestService</name>
  <files>
    packages/coinbase-client/src/reconciliation/boundary-rest-service.ts
    packages/coinbase-client/src/reconciliation/index.ts
  </files>
  <action>
Create boundary-rest-service.ts:

```typescript
import type { Redis } from 'ioredis';
import type { Timeframe, UnifiedCandle } from '@livermore/schemas';
import { CandleCacheStrategy, candleClosePattern } from '@livermore/cache';
import { logger } from '@livermore/utils';
import { CoinbaseRestClient } from '../rest/client';
import { BoundaryRestConfig, DEFAULT_BOUNDARY_CONFIG } from './types';
import { detectBoundaries } from './boundary-detector';

export class BoundaryRestService {
  private restClient: CoinbaseRestClient;
  private candleCache: CandleCacheStrategy;
  private subscriber: Redis;
  private config: BoundaryRestConfig;
  private symbols: string[] = [];
  private isRunning = false;

  constructor(
    apiKeyId: string,
    privateKeyPem: string,
    redis: Redis,
    subscriberRedis: Redis, // Separate connection for psubscribe
    config: Partial<BoundaryRestConfig> = {}
  ) {
    this.restClient = new CoinbaseRestClient(apiKeyId, privateKeyPem);
    this.candleCache = new CandleCacheStrategy(redis);
    this.subscriber = subscriberRedis;
    this.config = { ...DEFAULT_BOUNDARY_CONFIG, ...config };
  }

  async start(symbols: string[]): Promise<void> {
    this.symbols = symbols;
    this.isRunning = true;

    // Subscribe to 5m candle:close events for all symbols
    const pattern = candleClosePattern(
      this.config.userId,
      this.config.exchangeId,
      '*', // All symbols
      '5m'
    );

    this.subscriber.on('pmessage', this.handleCandleClose.bind(this));
    await this.subscriber.psubscribe(pattern);

    logger.info({
      event: 'boundary_rest_service_started',
      symbols: symbols.length,
      higherTimeframes: this.config.higherTimeframes,
    }, 'BoundaryRestService started');
  }

  async stop(): Promise<void> {
    this.isRunning = false;
    await this.subscriber.punsubscribe();
    logger.info('BoundaryRestService stopped');
  }

  private async handleCandleClose(
    _pattern: string,
    _channel: string,
    message: string
  ): Promise<void> {
    if (!this.isRunning) return;

    try {
      const candle = JSON.parse(message) as UnifiedCandle;
      const timestamp = candle.timestamp;

      // Detect which higher timeframe boundaries this 5m close aligns with
      const boundaries = detectBoundaries(timestamp, this.config.higherTimeframes);
      const triggeredBoundaries = boundaries.filter(b => b.triggered);

      if (triggeredBoundaries.length === 0) {
        return; // No boundaries triggered, nothing to do
      }

      logger.info({
        event: 'boundary_triggered',
        timestamp: new Date(timestamp).toISOString(),
        timeframes: triggeredBoundaries.map(b => b.timeframe),
      }, `Boundary triggered for ${triggeredBoundaries.length} timeframe(s)`);

      // Fetch higher timeframe candles for ALL symbols at this boundary
      await this.fetchHigherTimeframes(triggeredBoundaries.map(b => b.timeframe));
    } catch (error) {
      logger.error({ error }, 'Error handling candle close in BoundaryRestService');
    }
  }

  private async fetchHigherTimeframes(timeframes: Timeframe[]): Promise<void> {
    // Build task list: all symbol/timeframe combinations
    const tasks: Array<{ symbol: string; timeframe: Timeframe }> = [];
    for (const timeframe of timeframes) {
      for (const symbol of this.symbols) {
        tasks.push({ symbol, timeframe });
      }
    }

    logger.info({
      event: 'boundary_fetch_start',
      taskCount: tasks.length,
      timeframes,
    }, `Fetching ${tasks.length} candles at boundary`);

    let completed = 0;
    let errors = 0;

    // Process in batches with rate limiting (same pattern as StartupBackfillService)
    for (let i = 0; i < tasks.length; i += this.config.batchSize) {
      const batch = tasks.slice(i, i + this.config.batchSize);

      const results = await Promise.allSettled(
        batch.map(task => this.fetchAndCache(task.symbol, task.timeframe))
      );

      for (const result of results) {
        if (result.status === 'fulfilled') {
          completed++;
        } else {
          errors++;
          logger.warn({ error: result.reason }, 'Boundary fetch failed');
        }
      }

      // Sleep before next batch (skip on last batch)
      if (i + this.config.batchSize < tasks.length) {
        await this.sleep(this.config.batchDelayMs);
      }
    }

    logger.info({
      event: 'boundary_fetch_complete',
      completed,
      errors,
      total: tasks.length,
    }, `Boundary fetch complete: ${completed}/${tasks.length}`);
  }

  private async fetchAndCache(symbol: string, timeframe: Timeframe): Promise<void> {
    // Fetch most recent candle for this timeframe
    const candles = await this.restClient.getCandles(symbol, timeframe);

    if (candles.length === 0) {
      logger.warn({ symbol, timeframe }, 'No candles returned from REST');
      return;
    }

    // Get the most recent candle (last in array)
    const latestCandle = candles[candles.length - 1];

    // Write to cache using versioned writes
    const unified: UnifiedCandle = {
      ...latestCandle,
      exchange: 'coinbase',
    };

    await this.candleCache.addCandleIfNewer(
      this.config.userId,
      this.config.exchangeId,
      unified
    );

    logger.debug({
      symbol,
      timeframe,
      timestamp: new Date(latestCandle.timestamp).toISOString(),
    }, 'Cached higher timeframe candle');
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

Create index.ts with re-exports:
```typescript
export { BoundaryRestService } from './boundary-rest-service';
export { detectBoundaries, isTimeframeBoundary } from './boundary-detector';
export type { BoundaryRestConfig, TimeframeBoundary } from './types';
export { DEFAULT_BOUNDARY_CONFIG } from './types';
```
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/coinbase-client/tsconfig.json` - no errors.
Verify BoundaryRestService uses psubscribe pattern from @livermore/cache.
  </verify>
  <done>
BoundaryRestService created. Subscribes to 5m candle:close, detects boundaries, fires rate-limited REST calls at timeframe boundaries.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit -p packages/coinbase-client/tsconfig.json`
2. boundary-detector.ts exports detectBoundaries and isTimeframeBoundary
3. BoundaryRestService handles pmessage events and rate-limits REST calls
4. No references to node-cron, setInterval, or scheduled jobs in any file
</verification>

<success_criteria>
- detectBoundaries(timestamp, ['15m', '1h', '4h', '1d']) returns correct triggered flags
- BoundaryRestService subscribes to 5m candle:close pattern
- REST calls batched at 5 req/batch with 1s delay (same as StartupBackfillService)
- Higher timeframe candles written to cache via addCandleIfNewer
</success_criteria>

<output>
After completion, create `.planning/phases/08-reconciliation/08-01-SUMMARY.md`
</output>
