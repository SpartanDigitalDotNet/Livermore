---
phase: 35-smart-warmup-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/exchange-core/src/warmup/candle-status-scanner.ts
  - packages/exchange-core/src/warmup/warmup-schedule-builder.ts
  - packages/exchange-core/src/warmup/types.ts
  - packages/exchange-core/src/warmup/index.ts
  - packages/cache/src/keys.ts
autonomous: true
must_haves:
  truths:
    - "Scanner checks candle count for each symbol/timeframe pair from largest to smallest timeframe"
    - "Pairs with 60+ cached candles are marked as sufficient and excluded from the schedule"
    - "Schedule is a structured list of symbol/timeframe pairs that need fetching"
    - "Schedule is persisted to Redis at exchange:<exchange_id>:warm-up-schedule:symbols"
    - "An external reader can parse the schedule key to see what warmup will do before it starts"
  artifacts:
    - path: "packages/exchange-core/src/warmup/types.ts"
      provides: "CandleStatusResult, WarmupSchedule, WarmupScheduleEntry types"
    - path: "packages/exchange-core/src/warmup/candle-status-scanner.ts"
      provides: "CandleStatusScanner class with scanExchange() method"
      exports: ["CandleStatusScanner"]
    - path: "packages/exchange-core/src/warmup/warmup-schedule-builder.ts"
      provides: "WarmupScheduleBuilder class that creates schedule from scan results and writes to Redis"
      exports: ["WarmupScheduleBuilder"]
    - path: "packages/cache/src/keys.ts"
      provides: "warmupScheduleKey and warmupStatsKey functions"
      contains: "warmupScheduleKey"
    - path: "packages/exchange-core/src/warmup/index.ts"
      provides: "Re-exports for warmup module"
  key_links:
    - from: "packages/exchange-core/src/warmup/candle-status-scanner.ts"
      to: "Redis sorted sets"
      via: "zcard on exchangeCandleKey for each symbol/timeframe"
      pattern: "redis\\.zcard.*exchangeCandleKey"
    - from: "packages/exchange-core/src/warmup/warmup-schedule-builder.ts"
      to: "Redis"
      via: "redis.set on warmupScheduleKey"
      pattern: "redis\\.set.*warmupScheduleKey"
---

<objective>
Create the Exchange Candle Status Scanner and Warmup Schedule Builder -- the scan-and-plan half of smart warmup.

Purpose: Before any REST calls are made, the system needs to know what data is already cached and what is missing. This plan builds the scanner that checks each symbol/timeframe pair's candle count in Redis (largest to smallest timeframe: 1d, 4h, 1h, 15m, 5m, 1m), and the schedule builder that compiles scan results into a warmup schedule persisted to Redis for external observability.

Output: CandleStatusScanner, WarmupScheduleBuilder, and supporting types in a new `packages/exchange-core/src/warmup/` module. New key builder functions in `@livermore/cache`.
</objective>

<execution_context>
@C:/Users/Mike McWilliams/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Mike McWilliams/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@packages/cache/src/keys.ts
@packages/cache/src/strategies/candle-cache.ts
@packages/exchange-core/src/backfill/types.ts
@packages/exchange-core/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Warmup types and Redis key builders</name>
  <files>
    packages/exchange-core/src/warmup/types.ts
    packages/cache/src/keys.ts
  </files>
  <action>
**1. Create `packages/exchange-core/src/warmup/types.ts`:**

Define the following types:

```typescript
import type { Timeframe } from '@livermore/schemas';

/** Result of scanning one symbol/timeframe pair's cached candle count */
export interface CandleStatusResult {
  symbol: string;
  timeframe: Timeframe;
  cachedCount: number;
  sufficient: boolean;  // true if cachedCount >= MIN_CANDLE_THRESHOLD
}

/** A single entry in the warmup schedule -- one symbol/timeframe pair that needs fetching */
export interface WarmupScheduleEntry {
  symbol: string;
  timeframe: Timeframe;
  cachedCount: number;       // how many candles currently cached
  targetCount: number;       // how many we want (e.g. 100)
}

/** The complete warmup schedule for an exchange */
export interface WarmupSchedule {
  exchangeId: number;
  createdAt: number;         // Unix timestamp ms
  totalPairs: number;        // total symbol/timeframe pairs scanned
  sufficientPairs: number;   // pairs that already have enough data (skipped)
  needsFetching: number;     // pairs that need REST calls
  entries: WarmupScheduleEntry[];
}

/** Scan order: largest to smallest timeframe per WARM-01 requirement */
export const SCAN_TIMEFRAME_ORDER: Timeframe[] = ['1d', '4h', '1h', '15m', '5m', '1m'];

/** Minimum candle count to consider a symbol/timeframe pair "sufficient" */
export const MIN_CANDLE_THRESHOLD = 60;

/** Default candle target count for backfill */
export const DEFAULT_CANDLE_TARGET = 100;
```

**2. Add key builder functions to `packages/cache/src/keys.ts`:**

Add these two functions in a new section AFTER the "INSTANCE REGISTRY" section and BEFORE the "TIER 1" section. Add a section comment `// ============================================` / `// WARMUP SCHEDULE: Smart Warmup Keys` / `// ============================================`.

```typescript
/**
 * Build Redis key for exchange warmup schedule (list of symbol/timeframe pairs needing data).
 * Written by WarmupScheduleBuilder, read by Admin UI and warmup executor.
 *
 * @example warmupScheduleKey(1) // 'exchange:1:warm-up-schedule:symbols'
 */
export function warmupScheduleKey(exchangeId: number): string {
  return `exchange:${exchangeId}:warm-up-schedule:symbols`;
}

/**
 * Build Redis key for exchange warmup progress stats.
 * Written by warmup executor, read by Admin UI for real-time progress.
 *
 * @example warmupStatsKey(1) // 'exchange:1:warm-up-schedule:stats'
 */
export function warmupStatsKey(exchangeId: number): string {
  return `exchange:${exchangeId}:warm-up-schedule:stats`;
}
```

These key patterns match the exact Redis key format specified in the roadmap requirements (WARM-03, WARM-05).
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/exchange-core/tsconfig.json` and `npx tsc --noEmit -p packages/cache/tsconfig.json` -- both must pass with no errors. Verify the two new functions are exported from `@livermore/cache` by checking `packages/cache/src/index.ts` re-exports `keys.ts` (it already does via `export * from './keys'`).
  </verify>
  <done>
Types file exists with CandleStatusResult, WarmupScheduleEntry, WarmupSchedule, SCAN_TIMEFRAME_ORDER, MIN_CANDLE_THRESHOLD, DEFAULT_CANDLE_TARGET. Key builder functions warmupScheduleKey and warmupStatsKey exist in keys.ts and are accessible from @livermore/cache.
  </done>
</task>

<task type="auto">
  <name>Task 2: CandleStatusScanner and WarmupScheduleBuilder</name>
  <files>
    packages/exchange-core/src/warmup/candle-status-scanner.ts
    packages/exchange-core/src/warmup/warmup-schedule-builder.ts
    packages/exchange-core/src/warmup/index.ts
    packages/exchange-core/src/index.ts
  </files>
  <action>
**1. Create `packages/exchange-core/src/warmup/candle-status-scanner.ts`:**

```typescript
import { exchangeCandleKey, type RedisClient } from '@livermore/cache';
import type { Timeframe } from '@livermore/schemas';
import { logger } from '@livermore/utils';
import { CandleStatusResult, SCAN_TIMEFRAME_ORDER, MIN_CANDLE_THRESHOLD } from './types';
```

Class `CandleStatusScanner`:
- Constructor takes `{ redis: RedisClient, exchangeId: number }`.
- Method `async scanExchange(symbols: string[], timeframes?: Timeframe[]): Promise<CandleStatusResult[]>`:
  - Uses `timeframes` param if provided, otherwise defaults to `SCAN_TIMEFRAME_ORDER`.
  - For each symbol, iterates timeframes in the order given (largest to smallest per WARM-01).
  - For each pair, calls `redis.zcard(exchangeCandleKey(exchangeId, symbol, timeframe))` to get cached count.
  - Creates a `CandleStatusResult` with `sufficient: cachedCount >= MIN_CANDLE_THRESHOLD`.
  - Logs scan start and completion with counts: `{ event: 'candle_scan_start', symbols: N, timeframes: [...] }` and `{ event: 'candle_scan_complete', total, sufficient, needsFetching }`.
  - Returns the full array of results (both sufficient and insufficient -- the schedule builder filters).

Use `import { logger } from '@livermore/utils'` for the logger (same pattern as startup-backfill-service.ts).

**2. Create `packages/exchange-core/src/warmup/warmup-schedule-builder.ts`:**

```typescript
import { warmupScheduleKey, type RedisClient } from '@livermore/cache';
import { logger } from '@livermore/utils';
import { CandleStatusResult, WarmupSchedule, WarmupScheduleEntry, DEFAULT_CANDLE_TARGET } from './types';
```

Class `WarmupScheduleBuilder`:
- Constructor takes `{ redis: RedisClient, exchangeId: number }`.
- Method `async buildAndPersist(scanResults: CandleStatusResult[]): Promise<WarmupSchedule>`:
  - Filters scanResults to only those where `sufficient === false`.
  - Maps each insufficient result to a `WarmupScheduleEntry` with `targetCount: DEFAULT_CANDLE_TARGET`.
  - Builds a `WarmupSchedule` object with metadata (createdAt, counts).
  - Writes the schedule to Redis: `redis.set(warmupScheduleKey(exchangeId), JSON.stringify(schedule))`.
  - Logs: `{ event: 'warmup_schedule_persisted', key, totalPairs, sufficientPairs, needsFetching }`.
  - Returns the schedule object.

**3. Create `packages/exchange-core/src/warmup/index.ts`:**

Re-export everything:
```typescript
export { CandleStatusScanner } from './candle-status-scanner';
export { WarmupScheduleBuilder } from './warmup-schedule-builder';
export * from './types';
```

**4. Update `packages/exchange-core/src/index.ts`:**

Add a new section at the bottom:
```typescript
// Smart warmup (Phase 35)
export * from './warmup';
```

This makes CandleStatusScanner, WarmupScheduleBuilder, and all warmup types available from `@livermore/exchange-core`.
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/exchange-core/tsconfig.json` -- must pass with no errors. Verify exports by checking that `CandleStatusScanner`, `WarmupScheduleBuilder`, `WarmupSchedule`, `SCAN_TIMEFRAME_ORDER`, and `MIN_CANDLE_THRESHOLD` are all accessible from `@livermore/exchange-core` (grep the index.ts chain).
  </verify>
  <done>
CandleStatusScanner.scanExchange() scans symbols from largest to smallest timeframe using zcard, returns CandleStatusResult array. WarmupScheduleBuilder.buildAndPersist() filters insufficient pairs, persists schedule to `exchange:<id>:warm-up-schedule:symbols` in Redis as JSON. Both classes and all types are exported from @livermore/exchange-core. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/exchange-core/tsconfig.json` passes
2. `npx tsc --noEmit -p packages/cache/tsconfig.json` passes
3. `warmupScheduleKey(1)` returns `'exchange:1:warm-up-schedule:symbols'`
4. `warmupStatsKey(1)` returns `'exchange:1:warm-up-schedule:stats'`
5. SCAN_TIMEFRAME_ORDER is `['1d', '4h', '1h', '15m', '5m', '1m']` (largest to smallest)
6. MIN_CANDLE_THRESHOLD is 60
7. All new exports accessible from @livermore/exchange-core
</verification>

<success_criteria>
- Scanner checks cached candle counts via zcard for each symbol/timeframe in largest-to-smallest order
- Schedule builder filters to only insufficient pairs and persists to the exact Redis key from the roadmap
- Types are well-defined and shared between scanner, builder, and the executor (Plan 02)
- No changes to existing backfill code -- this is additive only
</success_criteria>

<output>
After completion, create `.planning/phases/35-smart-warmup-engine/35-01-SUMMARY.md`
</output>
