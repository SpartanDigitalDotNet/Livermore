---
phase: 35-smart-warmup-engine
plan: 02
type: execute
wave: 2
depends_on: ["35-01"]
files_modified:
  - packages/exchange-core/src/warmup/smart-warmup-service.ts
  - packages/exchange-core/src/warmup/types.ts
  - packages/exchange-core/src/warmup/index.ts
  - packages/exchange-core/src/index.ts
  - apps/api/src/services/control-channel.service.ts
autonomous: true
must_haves:
  truths:
    - "Warmup execution only makes REST calls for symbol/timeframe pairs listed in the schedule"
    - "A warm restart with fully cached data results in zero REST backfill calls"
    - "Warmup progress stats (percent complete, ETA, symbols remaining, failures) are written to Redis during execution"
    - "Stats are updated at exchange:<exchange_id>:warm-up-schedule:stats in real time as each pair completes"
    - "handleStart() uses SmartWarmupService instead of StartupBackfillService for candle backfill"
  artifacts:
    - path: "packages/exchange-core/src/warmup/smart-warmup-service.ts"
      provides: "SmartWarmupService orchestrating scan -> schedule -> execute with progress stats"
      exports: ["SmartWarmupService"]
    - path: "apps/api/src/services/control-channel.service.ts"
      provides: "handleStart() calls SmartWarmupService instead of StartupBackfillService"
      contains: "SmartWarmupService"
  key_links:
    - from: "packages/exchange-core/src/warmup/smart-warmup-service.ts"
      to: "candle-status-scanner.ts"
      via: "scanner.scanExchange()"
      pattern: "scanner\\.scanExchange"
    - from: "packages/exchange-core/src/warmup/smart-warmup-service.ts"
      to: "warmup-schedule-builder.ts"
      via: "builder.buildAndPersist()"
      pattern: "builder\\.buildAndPersist"
    - from: "packages/exchange-core/src/warmup/smart-warmup-service.ts"
      to: "Redis stats key"
      via: "redis.set on warmupStatsKey for progress updates"
      pattern: "warmupStatsKey"
    - from: "apps/api/src/services/control-channel.service.ts"
      to: "packages/exchange-core/src/warmup/smart-warmup-service.ts"
      via: "SmartWarmupService.warmup() called from handleStart()"
      pattern: "SmartWarmupService"
---

<objective>
Build the SmartWarmupService that orchestrates scan-schedule-execute and wire it into handleStart(), replacing the brute-force StartupBackfillService.

Purpose: This is the core innovation of Phase 35 -- warmup that only fetches what is missing. The service coordinates the scanner and schedule builder from Plan 01, then executes the schedule with rate-limited REST calls, continuously publishing progress stats to Redis for external observability. The integration into handleStart() replaces the existing brute-force backfill call.

Output: SmartWarmupService in the warmup module, updated handleStart() in control-channel.service.ts.
</objective>

<execution_context>
@C:/Users/Mike McWilliams/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Mike McWilliams/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/35-smart-warmup-engine/35-01-SUMMARY.md

@packages/exchange-core/src/backfill/startup-backfill-service.ts
@packages/exchange-core/src/backfill/types.ts
@apps/api/src/services/control-channel.service.ts
@packages/cache/src/keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: SmartWarmupService with progress stats</name>
  <files>
    packages/exchange-core/src/warmup/smart-warmup-service.ts
    packages/exchange-core/src/warmup/types.ts
    packages/exchange-core/src/warmup/index.ts
    packages/exchange-core/src/index.ts
  </files>
  <action>
**1. Add WarmupStats type to `packages/exchange-core/src/warmup/types.ts`:**

Add this interface (append to existing file, do NOT remove existing types):

```typescript
/** Real-time warmup progress stats, persisted to Redis */
export interface WarmupStats {
  exchangeId: number;
  status: 'scanning' | 'executing' | 'complete' | 'error';
  startedAt: number;            // Unix timestamp ms
  updatedAt: number;            // Unix timestamp ms
  totalPairs: number;           // total pairs in schedule
  completedPairs: number;       // pairs finished fetching
  skippedPairs: number;         // pairs that had sufficient data (not in schedule)
  failedPairs: number;          // pairs that failed to fetch
  percentComplete: number;      // 0-100
  etaMs: number | null;         // estimated ms remaining, null if can't calculate
  currentSymbol: string | null; // symbol currently being fetched
  currentTimeframe: string | null; // timeframe currently being fetched
  failures: Array<{ symbol: string; timeframe: string; error: string }>;
}
```

**2. Create `packages/exchange-core/src/warmup/smart-warmup-service.ts`:**

```typescript
import type { Timeframe, IRestClient } from '@livermore/schemas';
import { warmupStatsKey, type RedisClient } from '@livermore/cache';
import { CandleCacheStrategy } from '@livermore/cache';
import { logger } from '@livermore/utils';
import { CandleStatusScanner } from './candle-status-scanner';
import { WarmupScheduleBuilder } from './warmup-schedule-builder';
import type { WarmupSchedule, WarmupStats } from './types';
import { DEFAULT_CANDLE_TARGET, SCAN_TIMEFRAME_ORDER } from './types';
```

Class `SmartWarmupService`:
- Constructor takes `{ redis: RedisClient, exchangeId: number, restClient: IRestClient }`.
- Stores `candleCache = new CandleCacheStrategy(redis)`, `scanner = new CandleStatusScanner({ redis, exchangeId })`, `builder = new WarmupScheduleBuilder({ redis, exchangeId })`.

- **Main method** `async warmup(symbols: string[], timeframes?: Timeframe[]): Promise<WarmupSchedule>`:
  1. Initialize stats with status `'scanning'`, write to Redis via `publishStats()`.
  2. Call `scanner.scanExchange(symbols, timeframes ?? SCAN_TIMEFRAME_ORDER)`.
  3. Call `builder.buildAndPersist(scanResults)` to get the schedule.
  4. Update stats: `status: 'executing'`, `totalPairs: schedule.needsFetching`, `skippedPairs: schedule.sufficientPairs`.
  5. If `schedule.needsFetching === 0`: log `{ event: 'warmup_skip', message: 'All pairs have sufficient data, zero REST calls needed' }`. Set stats to `'complete'` with `percentComplete: 100`. Return schedule.
  6. Otherwise, call `executeSchedule(schedule)`.
  7. Set stats to `'complete'`, `percentComplete: 100`.
  8. Return schedule.

- **Private method** `async executeSchedule(schedule: WarmupSchedule): Promise<void>`:
  - Uses the same batching pattern as StartupBackfillService: `batchSize = 5`, `batchDelayMs = 1000`.
  - Iterates through `schedule.entries` in batches.
  - For each batch, uses `Promise.allSettled` to fetch candles in parallel:
    - For each entry: `restClient.getCandles(entry.symbol, entry.timeframe)`, then take first `entry.targetCount` candles, then `candleCache.addCandles(1, exchangeId, toCache)` (userId=1 is legacy, same as existing backfill).
  - After each batch settles:
    - Count fulfilled (increment `completedPairs`) and rejected (increment `failedPairs`, record error in `failures` array).
    - Update stats: compute `percentComplete = Math.round((completedPairs / totalPairs) * 100)`, compute `etaMs` from elapsed time and rate (same formula as StartupBackfillService.logProgress), set `currentSymbol`/`currentTimeframe` from next batch's first entry.
    - Call `publishStats()` to write to Redis.
  - Sleep `batchDelayMs` between batches (skip on last batch).
  - Log progress similarly to StartupBackfillService: `{ event: 'warmup_progress', completed, total, etaSec, errors }`.

- **Private method** `async publishStats(): Promise<void>`:
  - `stats.updatedAt = Date.now()`.
  - `redis.set(warmupStatsKey(exchangeId), JSON.stringify(stats))`.
  - The key does NOT get a TTL -- it persists until the next warmup run overwrites it (Admin UI needs to read it even after warmup completes).

- Log at info level: warmup_start (with symbol count, timeframe count), warmup_skip (zero calls needed), warmup_progress (per batch), warmup_complete (total time, errors).

**3. Update `packages/exchange-core/src/warmup/index.ts`:**

Add: `export { SmartWarmupService } from './smart-warmup-service';`

Also re-export the new WarmupStats type from types.ts (already covered by `export * from './types'` if that exists; verify and add explicit export if needed).

**4. Verify `packages/exchange-core/src/index.ts`** already has `export * from './warmup'` from Plan 01. If not, add it. SmartWarmupService must be importable from `@livermore/exchange-core`.
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/exchange-core/tsconfig.json` -- must pass with no errors. Verify SmartWarmupService is exported from @livermore/exchange-core by checking the index chain.
  </verify>
  <done>
SmartWarmupService exists with warmup() method that orchestrates scan -> schedule -> execute. Progress stats are written to `exchange:<id>:warm-up-schedule:stats` after every batch. When all pairs have sufficient data, zero REST calls are made and stats show complete immediately. Batching uses 5 requests per batch with 1s delay (matching existing rate limiting).
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire SmartWarmupService into handleStart()</name>
  <files>
    apps/api/src/services/control-channel.service.ts
  </files>
  <action>
**Modify `apps/api/src/services/control-channel.service.ts` to use SmartWarmupService instead of StartupBackfillService.**

1. **Update import** at top of file:
   - Change: `import { StartupBackfillService } from '@livermore/exchange-core';`
   - To: `import { SmartWarmupService } from '@livermore/exchange-core';`
   - Note: StartupBackfillService is still used by `handleForceBackfill` and `handleAddSymbol` and `handleBulkAddSymbols`. Keep that import if those methods still need it. Actually, check -- if handleForceBackfill/handleAddSymbol/handleBulkAddSymbols still use StartupBackfillService for their ad-hoc backfill needs, keep BOTH imports. The smart warmup is for startup only.
   - **Decision: Keep BOTH imports.** `StartupBackfillService` stays for force-backfill, add-symbol, bulk-add-symbols (those are ad-hoc, not startup). `SmartWarmupService` replaces the startup backfill in handleStart().

2. **Modify `handleStart()` method** -- replace the backfill section (approximately lines 544-558 in current code):

   BEFORE (current code, approximately):
   ```typescript
   // Backfill cache with historical candles (MUST complete before indicators)
   setProgress({ phase: 'indicators', phaseLabel: 'Backfilling historical candles', percent: 10 });
   const backfillTimeframes: Timeframe[] = ['1m', '5m', '15m', '1h', '4h', '1d'];
   // ... error checks ...
   const backfillService = new StartupBackfillService(this.services.restClient, this.services.redis, {
     userId: 1, // legacy
     exchangeId: this.services.exchangeId,
   });
   await backfillService.backfill(this.services.monitoredSymbols, backfillTimeframes);
   logger.info('Cache backfill complete');
   ```

   AFTER (replace with):
   ```typescript
   // Smart warmup: scan cached data, build schedule, fetch only what's missing (Phase 35)
   setProgress({ phase: 'indicators', phaseLabel: 'Scanning cached candle data', percent: 10 });
   const warmupTimeframes: Timeframe[] = ['1d', '4h', '1h', '15m', '5m', '1m'];
   if (!this.services.restClient) {
     throw new Error('No REST client available. Exchange setup may be incomplete.');
   }
   if (!this.services.exchangeId) {
     throw new Error('No exchange ID resolved. Exchange setup may be incomplete.');
   }
   const smartWarmup = new SmartWarmupService({
     redis: this.services.redis,
     exchangeId: this.services.exchangeId,
     restClient: this.services.restClient,
   });
   const warmupSchedule = await smartWarmup.warmup(this.services.monitoredSymbols, warmupTimeframes);
   logger.info({
     event: 'smart_warmup_complete',
     totalPairs: warmupSchedule.totalPairs,
     skipped: warmupSchedule.sufficientPairs,
     fetched: warmupSchedule.needsFetching,
   }, `Smart warmup complete: ${warmupSchedule.sufficientPairs} skipped, ${warmupSchedule.needsFetching} fetched`);
   ```

   Note the timeframe order is now `['1d', '4h', '1h', '15m', '5m', '1m']` (largest first for scanning per WARM-01). The SmartWarmupService internally handles the scan order. The progress label changes from "Backfilling" to "Scanning cached candle data" to reflect the new behavior.

3. **Update the progress label** after warmup completes. The line `logger.info('Cache backfill complete');` is replaced by the logging above. Keep the state machine transition `await this.services.stateMachine.transition('warming');` -- this happens AFTER warmup (the warming state refers to indicator warmup, which is next).

4. **Do NOT change**: handleForceBackfill, handleAddSymbol, handleBulkAddSymbols -- those still use StartupBackfillService for their ad-hoc single-symbol backfill operations. Smart warmup is startup-only.
  </action>
  <verify>
Run `npx tsc --noEmit -p apps/api/tsconfig.json` -- must pass with no errors. Grep for `StartupBackfillService` in control-channel.service.ts to confirm it still exists (for force-backfill etc.) but is NOT used in handleStart(). Grep for `SmartWarmupService` to confirm it IS used in handleStart().
  </verify>
  <done>
handleStart() creates SmartWarmupService and calls warmup() instead of StartupBackfillService.backfill(). On warm restart with fully cached data, zero REST calls are made (scanner finds all pairs sufficient, schedule is empty). handleForceBackfill/handleAddSymbol/handleBulkAddSymbols still use StartupBackfillService for ad-hoc operations. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/exchange-core/tsconfig.json` passes
2. `npx tsc --noEmit -p apps/api/tsconfig.json` passes
3. handleStart() no longer calls StartupBackfillService for startup
4. handleStart() calls SmartWarmupService.warmup() which scans, builds schedule, and executes
5. Progress stats are written to `exchange:<id>:warm-up-schedule:stats` in Redis
6. Schedule is written to `exchange:<id>:warm-up-schedule:symbols` in Redis
7. handleForceBackfill, handleAddSymbol, handleBulkAddSymbols still work with StartupBackfillService
8. Zero REST calls scenario: all pairs have 60+ candles, schedule.needsFetching === 0, no getCandles() calls made
</verification>

<success_criteria>
- SmartWarmupService orchestrates the full scan -> schedule -> execute pipeline
- Progress stats (percent, ETA, current symbol, failures) are published to Redis after every batch
- handleStart() uses SmartWarmupService, not StartupBackfillService, for startup candle population
- Warm restart with cached data produces zero REST calls
- Existing ad-hoc backfill operations (force-backfill, add-symbol) are unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/35-smart-warmup-engine/35-02-SUMMARY.md`
</output>
