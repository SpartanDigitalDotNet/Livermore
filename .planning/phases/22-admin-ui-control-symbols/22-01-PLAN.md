---
phase: 22-admin-ui-control-symbols
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/admin/src/components/ui/badge.tsx
  - apps/admin/src/components/ui/dialog.tsx
  - apps/admin/src/components/ui/tooltip.tsx
  - apps/admin/src/components/ui/button.tsx
  - apps/api/src/routers/control.router.ts
  - apps/api/src/routers/index.ts
  - apps/admin/src/pages/ControlPanel.tsx
  - apps/admin/src/pages/Symbols.tsx
  - apps/admin/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Control and Symbols pages are accessible via navigation"
    - "controlRouter endpoints are callable from Admin UI"
    - "shadcn Badge, Dialog, Tooltip, Button components render correctly"
  artifacts:
    - path: "apps/admin/src/components/ui/badge.tsx"
      provides: "Status badge component"
      contains: "Badge"
    - path: "apps/admin/src/components/ui/dialog.tsx"
      provides: "Modal dialog component"
      contains: "Dialog"
    - path: "apps/admin/src/components/ui/tooltip.tsx"
      provides: "Tooltip component"
      contains: "Tooltip"
    - path: "apps/admin/src/components/ui/button.tsx"
      provides: "Button component"
      contains: "Button"
    - path: "apps/api/src/routers/control.router.ts"
      provides: "Control panel tRPC endpoints"
      exports: ["controlRouter"]
    - path: "apps/admin/src/pages/ControlPanel.tsx"
      provides: "Control panel page shell"
      exports: ["ControlPanel"]
    - path: "apps/admin/src/pages/Symbols.tsx"
      provides: "Symbols page shell"
      exports: ["Symbols"]
  key_links:
    - from: "apps/admin/src/App.tsx"
      to: "pages/ControlPanel.tsx, pages/Symbols.tsx"
      via: "hash router routes"
      pattern: "#/control|#/symbols"
    - from: "apps/api/src/routers/index.ts"
      to: "control.router.ts"
      via: "appRouter composition"
      pattern: "control: controlRouter"
---

<objective>
Set up foundation for Phase 22 Admin UI pages.

Purpose: Install required shadcn components, create controlRouter for API status/command execution, and add page shells with navigation routes.

Output: Badge, Dialog, Tooltip, Button components; controlRouter with getStatus and executeCommand endpoints; ControlPanel.tsx and Symbols.tsx page shells; App.tsx navigation updated.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-admin-ui-control-symbols/22-RESEARCH.md
@apps/admin/src/App.tsx
@apps/api/src/routers/index.ts
@apps/api/src/services/control-channel.service.ts
@packages/schemas/src/control/command.schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install shadcn components</name>
  <files>
    apps/admin/src/components/ui/badge.tsx
    apps/admin/src/components/ui/dialog.tsx
    apps/admin/src/components/ui/tooltip.tsx
    apps/admin/src/components/ui/button.tsx
  </files>
  <action>
Run from apps/admin directory:

```bash
cd apps/admin
pnpm dlx shadcn@latest add badge dialog tooltip button --yes
```

This installs the four shadcn components needed for Phase 22:
- Badge: Status indicators (Running/Paused, Connected/Disconnected)
- Dialog: Confirmation modals, bulk import modal
- Tooltip: Symbol metrics on hover
- Button: Control buttons (already may exist, ensure installed)

After installation, verify components export correctly.
  </action>
  <verify>
All four component files exist in apps/admin/src/components/ui/:
- badge.tsx exports Badge, badgeVariants
- dialog.tsx exports Dialog, DialogTrigger, DialogContent, etc.
- tooltip.tsx exports Tooltip, TooltipTrigger, TooltipContent, etc.
- button.tsx exports Button, buttonVariants
  </verify>
  <done>shadcn Badge, Dialog, Tooltip, Button components installed and exported</done>
</task>

<task type="auto">
  <name>Task 2: Create controlRouter with status and command endpoints</name>
  <files>
    apps/api/src/routers/control.router.ts
    apps/api/src/routers/index.ts
  </files>
  <action>
Create apps/api/src/routers/control.router.ts:

```typescript
import { z } from 'zod';
import { TRPCError } from '@trpc/server';
import { router, protectedProcedure } from '@livermore/trpc-config';
import { getRedisClient, commandChannel, responseChannel } from '@livermore/cache';
import { CommandTypeSchema, type CommandResponse } from '@livermore/schemas';
import crypto from 'crypto';

/**
 * Priority levels for command ordering (matches control-channel.service.ts)
 */
const PRIORITY: Record<string, number> = {
  pause: 1,
  resume: 1,
  'reload-settings': 10,
  'switch-mode': 10,
  'force-backfill': 20,
  'clear-cache': 20,
  'add-symbol': 15,
  'remove-symbol': 15,
  'bulk-add-symbols': 15,
};

/**
 * Control Router
 *
 * Provides endpoints for Admin UI to:
 * - Poll API runtime status
 * - Execute control commands via Redis pub/sub
 *
 * Commands are published to Redis and processed by ControlChannelService.
 * Admin UI receives ACK immediately, then final result when complete.
 */
export const controlRouter = router({
  /**
   * GET /control.getStatus
   *
   * Returns current API runtime status for dashboard display.
   * Called via polling (5s interval) from Admin UI.
   *
   * Note: This is a placeholder that returns mock status.
   * Full implementation requires exposing ControlChannelService state,
   * which will be done when we integrate with server.ts context.
   */
  getStatus: protectedProcedure.query(async ({ ctx }) => {
    ctx.logger.debug('Fetching API status');

    // Return mock status for now - will be wired to actual service state
    // when ControlChannelService is accessible from tRPC context
    return {
      isPaused: false,
      mode: 'position-monitor',
      uptime: Math.floor(process.uptime()),
      startTime: Date.now() - Math.floor(process.uptime()) * 1000,
      exchangeConnected: true,
      queueDepth: 0,
    };
  }),

  /**
   * POST /control.executeCommand
   *
   * Execute a control command via Redis pub/sub.
   * Publishes command to Redis channel, subscribes to response channel,
   * waits for success/error response (with 30s timeout).
   *
   * Flow:
   * 1. Create command with correlationId
   * 2. Subscribe to response channel
   * 3. Publish command to command channel
   * 4. Wait for response matching correlationId
   * 5. Return response data or throw error
   */
  executeCommand: protectedProcedure
    .input(
      z.object({
        type: CommandTypeSchema,
        payload: z.record(z.unknown()).optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const correlationId = crypto.randomUUID();
      const redis = getRedisClient();
      const clerkId = ctx.auth.userId;

      const command = {
        correlationId,
        type: input.type,
        payload: input.payload,
        timestamp: Date.now(),
        priority: PRIORITY[input.type] ?? 50,
      };

      ctx.logger.info(
        { correlationId, type: input.type },
        'Executing control command'
      );

      // Create subscriber for response
      const subscriber = redis.duplicate();
      const responseChannelKey = responseChannel(clerkId);
      const commandChannelKey = commandChannel(clerkId);

      return new Promise<{ success: boolean; data?: unknown; message?: string }>(
        async (resolve, reject) => {
          // 30 second timeout
          const timeout = setTimeout(() => {
            subscriber.unsubscribe();
            subscriber.quit();
            reject(
              new TRPCError({
                code: 'TIMEOUT',
                message: 'Command timed out after 30 seconds',
              })
            );
          }, 30_000);

          subscriber.on('message', (_channel: string, message: string) => {
            try {
              const response = JSON.parse(message) as CommandResponse;

              // Only process responses for our command
              if (response.correlationId !== correlationId) {
                return;
              }

              if (response.status === 'success') {
                clearTimeout(timeout);
                subscriber.unsubscribe();
                subscriber.quit();
                resolve({ success: true, data: response.data });
              } else if (response.status === 'error') {
                clearTimeout(timeout);
                subscriber.unsubscribe();
                subscriber.quit();
                resolve({
                  success: false,
                  message: response.message ?? 'Command failed',
                });
              }
              // 'ack' status is ignored - wait for final status
            } catch (err) {
              ctx.logger.error({ err, message }, 'Failed to parse response');
            }
          });

          // Subscribe before publishing to avoid race condition
          await subscriber.subscribe(responseChannelKey);

          // Publish command
          await redis.publish(commandChannelKey, JSON.stringify(command));

          ctx.logger.debug(
            { correlationId, channel: commandChannelKey },
            'Command published'
          );
        }
      );
    }),
});

export type ControlRouter = typeof controlRouter;
```

Then update apps/api/src/routers/index.ts to include controlRouter:

```typescript
import { router } from '@livermore/trpc-config';
import { indicatorRouter } from './indicator.router';
import { alertRouter } from './alert.router';
import { positionRouter } from './position.router';
import { logsRouter } from './logs.router';
import { userRouter } from './user.router';
import { settingsRouter } from './settings.router';
import { symbolRouter } from './symbol.router';
import { controlRouter } from './control.router';

export const appRouter = router({
  indicator: indicatorRouter,
  alert: alertRouter,
  position: positionRouter,
  logs: logsRouter,
  user: userRouter,
  settings: settingsRouter,
  symbol: symbolRouter,
  control: controlRouter,
});

export type AppRouter = typeof appRouter;

// Re-export sub-routers
export { indicatorRouter } from './indicator.router';
export { alertRouter } from './alert.router';
export { positionRouter } from './position.router';
export { logsRouter } from './logs.router';
export { userRouter } from './user.router';
export { settingsRouter } from './settings.router';
export { symbolRouter } from './symbol.router';
export { controlRouter } from './control.router';
```
  </action>
  <verify>
TypeScript compiles without errors:
```bash
cd apps/api && pnpm tsc --noEmit
```
  </verify>
  <done>controlRouter created with getStatus and executeCommand endpoints, registered in appRouter</done>
</task>

<task type="auto">
  <name>Task 3: Create page shells and update navigation</name>
  <files>
    apps/admin/src/pages/ControlPanel.tsx
    apps/admin/src/pages/Symbols.tsx
    apps/admin/src/App.tsx
  </files>
  <action>
Create apps/admin/src/pages/ControlPanel.tsx:

```typescript
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

export function ControlPanel() {
  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Control Panel</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-gray-500">
            Runtime status and controls will be displayed here.
          </p>
        </CardContent>
      </Card>
    </div>
  );
}
```

Create apps/admin/src/pages/Symbols.tsx:

```typescript
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

export function Symbols() {
  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Symbol Watchlist</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-gray-500">
            Symbol management will be displayed here.
          </p>
        </CardContent>
      </Card>
    </div>
  );
}
```

Update apps/admin/src/App.tsx to add navigation links and routes:

1. Add imports for new pages:
```typescript
import { ControlPanel } from './pages/ControlPanel';
import { Symbols } from './pages/Symbols';
```

2. Add navigation links in the header nav (between Logs and Settings):
```tsx
<a
  href="#/control"
  className={`${hash === '#/control' ? 'text-gray-900 font-medium' : 'text-gray-600'} hover:text-gray-900`}
>
  Control
</a>
<a
  href="#/symbols"
  className={`${hash === '#/symbols' ? 'text-gray-900 font-medium' : 'text-gray-600'} hover:text-gray-900`}
>
  Symbols
</a>
```

3. Add routes in HashRouter:
```typescript
case '#/control':
  return <ControlPanel />;
case '#/symbols':
  return <Symbols />;
```
  </action>
  <verify>
1. Run dev server: `cd apps/admin && pnpm dev`
2. Navigate to http://localhost:5173/#/control - page renders with "Control Panel" title
3. Navigate to http://localhost:5173/#/symbols - page renders with "Symbol Watchlist" title
4. Both navigation links appear in header and highlight when active
  </verify>
  <done>ControlPanel and Symbols page shells created with navigation routes</done>
</task>

</tasks>

<verification>
1. shadcn components exist in apps/admin/src/components/ui/
2. controlRouter compiles and is registered in appRouter
3. Both new pages render and are accessible via navigation
4. TypeScript compiles without errors across apps/api and apps/admin
</verification>

<success_criteria>
- Badge, Dialog, Tooltip, Button components installed
- controlRouter with getStatus and executeCommand endpoints
- ControlPanel and Symbols pages accessible via #/control and #/symbols
- Navigation links in header for Control and Symbols
</success_criteria>

<output>
After completion, create `.planning/phases/22-admin-ui-control-symbols/22-01-SUMMARY.md`
</output>
