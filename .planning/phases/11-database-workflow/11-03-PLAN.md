---
phase: 11-database-workflow
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/sync-schema.ps1
autonomous: true

must_haves:
  truths:
    - "Developer can run sync-schema.ps1to apply schema AND regenerate Drizzle types"
    - "Script runs Atlas apply first, then drizzle-kit pull"
    - "Script shows verbose output of each step"
    - "Script exits with code 1 on any failure (Atlas or Drizzle)"
  artifacts:
    - path: "scripts/sync-schema.ps1"
      provides: "Local schema sync script (Atlas + Drizzle)"
      min_lines: 30
  key_links:
    - from: "sync-schema.ps1"
      to: "atlas.exe"
      via: "subprocess invocation with --env local"
      pattern: "atlas.*--env local"
    - from: "sync-schema.ps1"
      to: "drizzle-kit"
      via: "pnpm drizzle-kit pull"
      pattern: "pnpm.*drizzle-kit.*pull"
---

<objective>
Create PowerShell script for local schema sync: Atlas apply + Drizzle pull in one command.

Purpose: Single command workflow for local development - apply schema changes via Atlas, then regenerate Drizzle TypeScript types.
Output: `scripts/sync-schema.ps1` ready for execution.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-database-workflow/11-CONTEXT.md
@scripts/apply-schema.ps1
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync-schema.ps1 script</name>
  <files>scripts/sync-schema.ps1</files>
  <action>
Create PowerShell script that combines Atlas apply and Drizzle pull:

1. Set `$ErrorActionPreference = "Stop"` for fail-fast

2. Load LOCAL environment variables from Windows User scope (same as apply-schema.ps1):
   - DATABASE_HOST
   - DATABASE_PORT
   - DATABASE_LIVERMORE_USERNAME
   - DATABASE_LIVERMORE_PASSWORD
   - LIVERMORE_DATABASE_NAME

3. Validate all variables present (exit 1 with clear error if missing)

4. Build connection URL:
   `postgresql://${username}:${password}@${host}:${port}/${database}?sslmode=disable&search_path=public`

5. Step 1 - Atlas Apply:
   - Print "=== Step 1: Applying Schema via Atlas ==="
   - Print "Target: postgresql://${username}:****@${host}:${port}/${database}"
   - Set $env:DATABASE_URL
   - Set-Location to packages/database
   - Run: `& "$PSScriptRoot\..\atlas.exe" schema apply --env local --auto-approve`
   - Check $LASTEXITCODE - if non-zero, print "Atlas apply FAILED" and exit 1
   - Print "Atlas apply completed"

6. Step 2 - Drizzle Pull:
   - Print "=== Step 2: Regenerating Drizzle Types ==="
   - Stay in packages/database directory
   - Run: `pnpm drizzle-kit pull`
   - Check $LASTEXITCODE - if non-zero, print "Drizzle pull FAILED" and exit 1
   - Print "Drizzle types regenerated"

7. Final output:
   - Print "=== Schema Sync Complete ==="
   - Print "- Schema applied to local PostgreSQL"
   - Print "- Drizzle types regenerated in packages/database/src/schema"
  </action>
  <verify>
Syntax check: `powershell -File scripts/sync-schema.ps1 -?` should not error on parse.
Note: Full test requires local PostgreSQL running.
  </verify>
  <done>
Script exists at scripts/sync-schema.ps1, runs Atlas apply then Drizzle pull with verbose output and proper exit codes.
  </done>
</task>

</tasks>

<verification>
- [ ] Script loads local DATABASE_* variables from Windows User environment
- [ ] Script validates all required variables present
- [ ] Password is masked in output
- [ ] Script runs Atlas apply with --env local first
- [ ] Script runs drizzle-kit pull second
- [ ] Script exits with code 1 if Atlas fails (doesn't continue to Drizzle)
- [ ] Script exits with code 1 if Drizzle fails
- [ ] Final output summarizes what was done
</verification>

<success_criteria>
Developer can run `powershell -File scripts/sync-schema.ps1` to sync schema.sql to local PostgreSQL and regenerate Drizzle TypeScript types in one command.
</success_criteria>

<output>
After completion, create `.planning/phases/11-database-workflow/11-03-SUMMARY.md`
</output>
