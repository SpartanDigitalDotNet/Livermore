---
phase: 21-admin-ui-settings
plan: 04
type: execute
wave: 3
depends_on: ["21-02", "21-03"]
files_modified:
  - apps/admin/src/components/settings/SettingsSplitView.tsx
  - apps/admin/src/components/settings/index.ts
  - apps/admin/src/pages/Settings.tsx
autonomous: true

must_haves:
  truths:
    - "User can see form and JSON editor side by side"
    - "Form changes appear in JSON editor in real-time"
    - "JSON editor changes appear in form fields"
    - "Invalid JSON shows validation error in editor"
  artifacts:
    - path: "apps/admin/src/components/settings/SettingsSplitView.tsx"
      provides: "Side-by-side form + JSON editor with bidirectional sync"
      min_lines: 80
    - path: "apps/admin/src/pages/Settings.tsx"
      provides: "Updated Settings page using SettingsSplitView"
      min_lines: 60
  key_links:
    - from: "apps/admin/src/components/settings/SettingsSplitView.tsx"
      to: "apps/admin/src/components/settings/SettingsForm.tsx"
      via: "component import and form prop"
      pattern: "SettingsForm.*form="
    - from: "apps/admin/src/components/settings/SettingsSplitView.tsx"
      to: "apps/admin/src/components/settings/SettingsJsonEditor.tsx"
      via: "component import and value prop"
      pattern: "SettingsJsonEditor.*value="
    - from: "apps/admin/src/pages/Settings.tsx"
      to: "apps/admin/src/components/settings/SettingsSplitView.tsx"
      via: "component import"
      pattern: "import.*SettingsSplitView"
---

<objective>
Create side-by-side split view with bidirectional sync between form and JSON editor.

Purpose: Allow users to edit settings via either form fields or raw JSON, with changes instantly reflected in the other view. This satisfies users who prefer forms and power users who prefer JSON.

Output: SettingsSplitView component integrating form and JSON editor with real-time sync, integrated into the Settings page.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-admin-ui-settings/21-RESEARCH.md
@.planning/phases/21-admin-ui-settings/21-02-SUMMARY.md
@.planning/phases/21-admin-ui-settings/21-03-SUMMARY.md

@packages/schemas/src/settings/user-settings.schema.ts
@apps/admin/src/pages/Settings.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SettingsSplitView component with bidirectional sync</name>
  <files>apps/admin/src/components/settings/SettingsSplitView.tsx</files>
  <action>
    Create apps/admin/src/components/settings/SettingsSplitView.tsx:

    ```typescript
    import { useState, useCallback, useRef, useEffect } from 'react';
    import { useForm } from 'react-hook-form';
    import { zodResolver } from '@hookform/resolvers/zod';
    import { UserSettingsSchema, type UserSettings } from '@livermore/schemas';
    import { SettingsForm } from './SettingsForm';
    import { SettingsJsonEditor } from './SettingsJsonEditor';

    interface SettingsSplitViewProps {
      /** Initial settings from server */
      initialSettings: UserSettings;
      /** Callback when settings change (for parent to track dirty state) */
      onSettingsChange: (settings: UserSettings, isDirty: boolean) => void;
    }

    /**
     * Side-by-side form + JSON editor with bidirectional sync.
     * Form changes update JSON, JSON changes update form.
     * Satisfies UI-SET-03.
     */
    export function SettingsSplitView({
      initialSettings,
      onSettingsChange,
    }: SettingsSplitViewProps) {
      // JSON string state for the editor
      const [jsonValue, setJsonValue] = useState(() =>
        JSON.stringify(initialSettings, null, 2)
      );

      // Validation error for JSON editor
      const [jsonError, setJsonError] = useState<string | undefined>();

      // Track which side was last edited to prevent sync loops
      const lastEditSource = useRef<'form' | 'json' | null>(null);

      // Debounce timer ref
      const syncTimeoutRef = useRef<NodeJS.Timeout | null>(null);

      // Form instance with Zod validation
      const form = useForm<UserSettings>({
        resolver: zodResolver(UserSettingsSchema),
        defaultValues: initialSettings,
        mode: 'onBlur',
      });

      // Compare current settings to initial to determine dirty state
      const isDirty = useCallback(
        (current: UserSettings) =>
          JSON.stringify(current) !== JSON.stringify(initialSettings),
        [initialSettings]
      );

      // Handle form value changes -> update JSON editor
      useEffect(() => {
        const subscription = form.watch((values) => {
          if (lastEditSource.current === 'json') {
            // Skip if change came from JSON editor
            lastEditSource.current = null;
            return;
          }

          // Debounce form -> JSON sync
          if (syncTimeoutRef.current) {
            clearTimeout(syncTimeoutRef.current);
          }

          syncTimeoutRef.current = setTimeout(() => {
            if (values) {
              const formValues = values as UserSettings;
              setJsonValue(JSON.stringify(formValues, null, 2));
              setJsonError(undefined);
              onSettingsChange(formValues, isDirty(formValues));
            }
          }, 300);
        });

        return () => {
          subscription.unsubscribe();
          if (syncTimeoutRef.current) {
            clearTimeout(syncTimeoutRef.current);
          }
        };
      }, [form, onSettingsChange, isDirty]);

      // Handle JSON editor changes -> update form
      const handleJsonChange = useCallback(
        (newJson: string) => {
          setJsonValue(newJson);

          try {
            const parsed = JSON.parse(newJson);
            const validated = UserSettingsSchema.parse(parsed);

            // Mark that this change came from JSON
            lastEditSource.current = 'json';

            // Reset form with validated values
            form.reset(validated, { keepDirty: false });
            setJsonError(undefined);
            onSettingsChange(validated, isDirty(validated));
          } catch (err) {
            // Show validation error in editor
            if (err instanceof Error) {
              setJsonError(err.message);
            } else {
              setJsonError('Invalid JSON');
            }
          }
        },
        [form, onSettingsChange, isDirty]
      );

      return (
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Form Editor (Left Side) */}
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <h3 className="text-sm font-medium text-gray-700">Form Editor</h3>
              <span className="text-xs text-gray-500">
                Edit fields to update settings
              </span>
            </div>
            <div className="max-h-[600px] overflow-y-auto pr-2">
              <SettingsForm form={form} defaultValues={initialSettings} />
            </div>
          </div>

          {/* JSON Editor (Right Side) */}
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <h3 className="text-sm font-medium text-gray-700">JSON Editor</h3>
              <span className="text-xs text-gray-500">
                Edit raw JSON for advanced changes
              </span>
            </div>
            <SettingsJsonEditor
              value={jsonValue}
              onChange={handleJsonChange}
              validationError={jsonError}
              height="600px"
            />
          </div>
        </div>
      );
    }
    ```

    Key implementation notes:
    - Uses `lastEditSource` ref to prevent infinite sync loops
    - Debounces form->JSON sync by 300ms to avoid excessive updates
    - JSON->form sync happens immediately (validated before update)
    - Zod validation on JSON ensures only valid settings update the form
    - Parent is notified via onSettingsChange with current values and dirty state
  </action>
  <verify>
    - File exists at apps/admin/src/components/settings/SettingsSplitView.tsx
    - Exports SettingsSplitView component
    - Imports and uses both SettingsForm and SettingsJsonEditor
    - Has bidirectional sync logic with debouncing
    - TypeScript compilation passes
  </verify>
  <done>Split view component with form/JSON bidirectional sync implemented</done>
</task>

<task type="auto">
  <name>Task 2: Update Settings page to use SettingsSplitView</name>
  <files>apps/admin/src/pages/Settings.tsx</files>
  <action>
    Update apps/admin/src/pages/Settings.tsx to use the new split view:

    ```typescript
    import { useState, useCallback } from 'react';
    import { useQuery } from '@tanstack/react-query';
    import { trpc } from '@/lib/trpc';
    import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
    import { SettingsSplitView } from '@/components/settings';
    import type { UserSettings } from '@livermore/schemas';

    export function Settings() {
      const { data, isLoading, error, refetch, isFetching } = useQuery(
        trpc.settings.get.queryOptions()
      );

      // Track current settings and dirty state
      const [currentSettings, setCurrentSettings] = useState<UserSettings | null>(null);
      const [isDirty, setIsDirty] = useState(false);

      // Handle settings changes from split view
      const handleSettingsChange = useCallback(
        (settings: UserSettings, dirty: boolean) => {
          setCurrentSettings(settings);
          setIsDirty(dirty);
        },
        []
      );

      if (isLoading) {
        return (
          <Card>
            <CardHeader>
              <CardTitle>Settings</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="flex items-center justify-center py-8">
                <div className="h-8 w-8 animate-spin rounded-full border-4 border-gray-200 border-t-gray-600" />
              </div>
            </CardContent>
          </Card>
        );
      }

      if (error) {
        return (
          <Card>
            <CardHeader>
              <CardTitle>Settings</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="rounded-md bg-red-50 p-4 text-red-700">
                Error loading settings: {error.message}
              </div>
            </CardContent>
          </Card>
        );
      }

      const settings = data as UserSettings;

      return (
        <Card>
          <CardHeader className="flex flex-row items-center justify-between">
            <div className="flex items-center gap-3">
              <CardTitle>Settings</CardTitle>
              {isDirty && (
                <span className="text-xs bg-yellow-100 text-yellow-800 px-2 py-1 rounded">
                  Unsaved changes
                </span>
              )}
            </div>
            <div className="flex items-center gap-2">
              <button
                onClick={() => refetch()}
                disabled={isFetching}
                className="rounded-md bg-gray-100 px-3 py-1 text-sm font-medium text-gray-700 hover:bg-gray-200 disabled:opacity-50"
              >
                {isFetching ? 'Refreshing...' : 'Refresh'}
              </button>
            </div>
          </CardHeader>
          <CardContent>
            <SettingsSplitView
              initialSettings={settings}
              onSettingsChange={handleSettingsChange}
            />
          </CardContent>
        </Card>
      );
    }
    ```

    This version:
    - Tracks current settings and dirty state from SettingsSplitView
    - Shows "Unsaved changes" indicator when settings differ from server
    - Keeps the refresh button for reloading from server
    - Save/discard buttons will be added in Plan 05
  </action>
  <verify>
    - apps/admin/src/pages/Settings.tsx uses SettingsSplitView
    - Passes initialSettings and onSettingsChange props
    - Shows "Unsaved changes" indicator when isDirty is true
    - Loading and error states still work correctly
  </verify>
  <done>Settings page renders split view with form and JSON editor side by side</done>
</task>

<task type="auto">
  <name>Task 3: Update settings components index and verify integration</name>
  <files>apps/admin/src/components/settings/index.ts</files>
  <action>
    Update apps/admin/src/components/settings/index.ts to export SettingsSplitView:

    ```typescript
    export { SettingsJsonEditor } from './SettingsJsonEditor';
    export { SettingsDiffView } from './SettingsDiffView';
    export { SettingsForm, useSettingsForm } from './SettingsForm';
    export { ProfileSection } from './ProfileSection';
    export { RuntimeSection } from './RuntimeSection';
    export { SettingsSplitView } from './SettingsSplitView';
    ```

    Then verify the integration works:
    1. Run `pnpm --filter admin dev`
    2. Navigate to http://localhost:5173/#/settings
    3. Verify form fields display current settings values
    4. Edit a form field (e.g., Display Name) - JSON should update
    5. Edit JSON directly (e.g., change timezone) - form should update
    6. Enter invalid JSON - error should appear in editor
    7. "Unsaved changes" indicator should appear when values differ from original
  </action>
  <verify>
    - Index file exports SettingsSplitView
    - Settings page renders without errors
    - Form->JSON sync works (edit form, see JSON update)
    - JSON->form sync works (edit JSON, see form update)
    - Invalid JSON shows error in editor
    - "Unsaved changes" appears when settings modified
  </verify>
  <done>Split view fully integrated and bidirectional sync working</done>
</task>

</tasks>

<verification>
1. `pnpm --filter admin dev` starts without errors
2. Navigate to http://localhost:5173/#/settings
3. Form displays on left, JSON editor on right
4. Edit Display Name in form -> JSON updates within 300ms
5. Edit timezone in JSON -> form field updates immediately
6. Delete a quote in JSON -> validation error appears
7. Modify any value -> "Unsaved changes" badge appears
8. Refresh page -> changes are lost (save not implemented yet)
</verification>

<success_criteria>
- UI-SET-03 satisfied: Side-by-side view with form + JSON simultaneously
- Bidirectional sync works without infinite loops
- Validation errors display in JSON editor
- Dirty state tracked and displayed to user
- Foundation ready for diff view and save/discard in Plan 05
</success_criteria>

<output>
After completion, create `.planning/phases/21-admin-ui-settings/21-04-SUMMARY.md`
</output>
