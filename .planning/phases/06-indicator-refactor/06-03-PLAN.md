---
phase: 06-indicator-refactor
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - apps/api/src/services/indicator-calculation.service.ts
autonomous: true

must_haves:
  truths:
    - "15m, 1h, 4h, 1d indicators calculated from aggregated 5m candles"
    - "No REST API calls for higher timeframe candle data"
    - "Aggregation happens in memory from cached 5m candles"
    - "Higher timeframe calculations only when timeframe boundary crossed"
  artifacts:
    - path: "apps/api/src/services/indicator-calculation.service.ts"
      provides: "Complete indicator service with aggregation"
      min_lines: 450
  key_links:
    - from: "apps/api/src/services/indicator-calculation.service.ts"
      to: "aggregateCandles utility"
      via: "import from @livermore/utils"
      pattern: "import.*aggregateCandles.*from '@livermore/utils'"
    - from: "apps/api/src/services/indicator-calculation.service.ts"
      to: "CandleCacheStrategy.getRecentCandles"
      via: "fetch 5m candles for aggregation"
      pattern: "getRecentCandles.*5m"
---

<objective>
Integrate candle aggregation for higher timeframe indicator calculation

Purpose: Calculate 15m/1h/4h/1d indicators from cached 5m candles instead of fetching each timeframe separately from REST API
Output: Indicator service calculates all timeframes from single 5m cache source
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-indicator-refactor/06-RESEARCH.md
@.planning/phases/06-indicator-refactor/06-01-SUMMARY.md
@.planning/phases/06-indicator-refactor/06-02-SUMMARY.md
@apps/api/src/services/indicator-calculation.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add aggregation import and calculate aggregated candles method</name>
  <files>apps/api/src/services/indicator-calculation.service.ts</files>
  <action>
**1. Add import for aggregateCandles:**
```typescript
import { aggregateCandles } from '@livermore/utils';
```

**2. Add AGGREGATION_FACTORS constant:**
```typescript
// Number of 5m candles needed per target timeframe candle
private readonly AGGREGATION_FACTORS: Record<Timeframe, number> = {
  '5m': 1,    // No aggregation needed
  '15m': 3,   // 3 x 5m = 15m
  '1h': 12,   // 12 x 5m = 1h
  '4h': 48,   // 48 x 5m = 4h
  '1d': 288,  // 288 x 5m = 1d
};
```

**3. Add getAggregatedCandles() method:**
```typescript
/**
 * Get candles for a target timeframe by aggregating cached 5m candles
 * This eliminates the need for REST API calls for higher timeframes
 *
 * @param symbol - Trading pair
 * @param targetTimeframe - Timeframe to aggregate to
 * @param requiredCount - Number of target timeframe candles needed
 * @returns Aggregated candles at target timeframe
 */
private async getAggregatedCandles(
  symbol: string,
  targetTimeframe: Timeframe,
  requiredCount: number
): Promise<Candle[]> {
  // For 5m, just read directly from cache
  if (targetTimeframe === '5m') {
    return this.candleCache.getRecentCandles(
      this.TEST_USER_ID,
      this.TEST_EXCHANGE_ID,
      symbol,
      '5m',
      requiredCount
    );
  }

  // Calculate how many 5m candles we need
  const factor = this.AGGREGATION_FACTORS[targetTimeframe] || 1;
  // Need extra to ensure we get enough complete periods
  const sourceCount = (requiredCount + 1) * factor;

  // Read 5m candles from cache
  const sourceCandles = await this.candleCache.getRecentCandles(
    this.TEST_USER_ID,
    this.TEST_EXCHANGE_ID,
    symbol,
    '5m',
    sourceCount
  );

  if (sourceCandles.length < factor) {
    // Not enough candles even for one complete period
    return [];
  }

  // Aggregate to target timeframe
  return aggregateCandles(sourceCandles, '5m', targetTimeframe);
}
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit -p apps/api/tsconfig.json`
Import present: `grep "import.*aggregateCandles" apps/api/src/services/indicator-calculation.service.ts`
Method present: `grep "getAggregatedCandles" apps/api/src/services/indicator-calculation.service.ts`
  </verify>
  <done>
getAggregatedCandles() method exists and uses aggregateCandles utility
  </done>
</task>

<task type="auto">
  <name>Task 2: Update checkHigherTimeframes to use aggregation</name>
  <files>apps/api/src/services/indicator-calculation.service.ts</files>
  <action>
**1. Update checkHigherTimeframes() method:**

The method already detects boundary crossings correctly. Update it to use the new aggregation-based recalculation:

```typescript
/**
 * Check if any higher timeframes closed and trigger recalculation
 * Uses aggregated 5m candles instead of REST API calls
 */
private async checkHigherTimeframes(symbol: string, timestamp: number): Promise<void> {
  for (const timeframe of this.HIGHER_TIMEFRAMES) {
    const key = `${symbol}:${timeframe}`;
    const lastBoundary = this.lastProcessedBoundary.get(key) || 0;
    const currentBoundary = getCandleTimestamp(timestamp, timeframe);

    // Check if we've crossed into a new candle period
    if (currentBoundary > lastBoundary) {
      this.lastProcessedBoundary.set(key, currentBoundary);

      logger.info({
        event: 'boundary_crossing_detected',
        symbol,
        timeframe,
        previousBoundary: lastBoundary ? new Date(lastBoundary).toISOString() : 'none',
        newBoundary: new Date(currentBoundary).toISOString(),
      }, `Boundary crossed: ${symbol} ${timeframe}`);

      // Recalculate using aggregated candles (no REST calls)
      await this.recalculateFromAggregated(symbol, timeframe);
    }
  }
}
```

**2. Create recalculateFromAggregated() method:**

```typescript
/**
 * Recalculate indicator for a higher timeframe using aggregated 5m candles
 * This is the cache-only path for all higher timeframes
 */
private async recalculateFromAggregated(symbol: string, timeframe: Timeframe): Promise<void> {
  // Get aggregated candles (builds from cached 5m data)
  const candles = await this.getAggregatedCandles(symbol, timeframe, 200);

  // Readiness gate
  if (candles.length < this.REQUIRED_CANDLES) {
    logger.debug({
      symbol,
      timeframe,
      available: candles.length,
      required: this.REQUIRED_CANDLES,
    }, 'Skipping higher timeframe calculation - insufficient aggregated candles');
    return;
  }

  logger.debug({
    symbol,
    timeframe,
    aggregatedCount: candles.length,
  }, 'Calculating indicator from aggregated candles');

  await this.calculateIndicators(symbol, timeframe, candles);
}
```

**3. Update recalculateFromCache() to call recalculateFromAggregated for non-5m:**

Actually, keep recalculateFromCache() for 5m only, and route everything else through recalculateFromAggregated(). The handleCandleCloseEvent should:
- Call recalculateFromCache() for 5m (direct cache read)
- checkHigherTimeframes() handles 15m/1h/4h/1d via recalculateFromAggregated()

This is already the intended flow from Plan 02, so just ensure recalculateFromAggregated() is called by checkHigherTimeframes().
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit -p apps/api/tsconfig.json`
recalculateFromAggregated exists: `grep "recalculateFromAggregated" apps/api/src/services/indicator-calculation.service.ts`
No REST calls in checkHigherTimeframes: `grep -A20 "checkHigherTimeframes" apps/api/src/services/indicator-calculation.service.ts | grep -c "restClient\|fetchRecentCandles"` should be 0
  </verify>
  <done>
Higher timeframe calculation uses getAggregatedCandles() with no REST API calls
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration logging and final verification</name>
  <files>apps/api/src/services/indicator-calculation.service.ts</files>
  <action>
**1. Add logging to verify aggregation path:**

In calculateIndicators(), add a log entry that shows the source of the candles:

```typescript
// At start of calculateIndicators(), add:
const isAggregated = timeframe !== '5m';
logger.debug({
  event: 'indicator_calculation_start',
  symbol,
  timeframe,
  candleCount: candles.length,
  source: isAggregated ? 'aggregated_5m' : 'cache_direct',
}, `Calculating ${symbol} ${timeframe} from ${isAggregated ? 'aggregated' : 'cached'} candles`);
```

**2. Update the indicator_cached log to include source:**

In the existing "indicator_cached" log entry, add source field:
```typescript
source: timeframe === '5m' ? 'cache_direct' : 'aggregated_5m',
```

**3. Verify no REST client usage in hot path:**

Ensure the restClient is not used anywhere in:
- handleCandleCloseEvent()
- recalculateFromCache()
- recalculateFromAggregated()
- checkHigherTimeframes()
- calculateIndicators()

The restClient should ONLY be used in:
- forceRecalculate() (if kept for manual override)
- Or removed entirely

**4. Update JSDoc for the service class:**

```typescript
/**
 * Indicator Calculation Service
 *
 * Event-driven service that calculates technical indicators from cached candle data.
 *
 * Architecture (v2.0):
 * - Subscribes to candle:close events via Redis psubscribe
 * - Reads 5m candles exclusively from Redis cache (no REST API calls)
 * - Aggregates 5m candles to higher timeframes (15m, 1h, 4h, 1d) in memory
 * - Caches calculated indicators in Redis and publishes updates
 *
 * Readiness: Requires 60+ candles before calculating (IND-03)
 * Warmup: Handled by separate startup backfill service (Phase 07)
 */
```
  </action>
  <verify>
TypeScript compiles: `npm run build -w @livermore/api`
Build succeeds with no errors
Log source field: `grep "source.*aggregated_5m\|source.*cache_direct" apps/api/src/services/indicator-calculation.service.ts`
  </verify>
  <done>
Logging shows aggregation path, no REST in hot path, documentation updated
  </done>
</task>

</tasks>

<verification>
1. Full workspace build: `npm run build`
2. No REST calls in indicator hot path
3. Higher timeframes calculated from aggregated 5m
4. Logs clearly show source (cache_direct vs aggregated_5m)
5. 60-candle readiness gate applies to both 5m and aggregated candles
</verification>

<success_criteria>
- 15m, 1h, 4h, 1d indicators calculated from aggregated 5m cache data (IND-04)
- Zero REST API calls for any timeframe during normal operation (CACHE-03)
- Boundary crossing detection still works correctly
- Readiness gate (60 candles) applies to all timeframes
- Clear logging shows data source for each calculation
</success_criteria>

<output>
After completion, create `.planning/phases/06-indicator-refactor/06-03-SUMMARY.md`
</output>
