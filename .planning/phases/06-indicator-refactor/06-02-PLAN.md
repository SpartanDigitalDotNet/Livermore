---
phase: 06-indicator-refactor
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/services/indicator-calculation.service.ts
  - packages/cache/src/keys.ts
autonomous: true

must_haves:
  truths:
    - "Indicator service subscribes to candle:close Redis pub/sub events"
    - "No REST API calls during normal indicator recalculation"
    - "Symbols with < 60 candles are skipped gracefully"
    - "Service uses dedicated Redis subscriber connection"
  artifacts:
    - path: "apps/api/src/services/indicator-calculation.service.ts"
      provides: "Event-driven indicator calculation"
      min_lines: 400
    - path: "packages/cache/src/keys.ts"
      provides: "candleClosePattern helper"
      exports: ["candleClosePattern"]
  key_links:
    - from: "apps/api/src/services/indicator-calculation.service.ts"
      to: "Redis psubscribe"
      via: "subscriber.psubscribe(pattern)"
      pattern: "psubscribe"
    - from: "apps/api/src/services/indicator-calculation.service.ts"
      to: "CandleCacheStrategy.getRecentCandles"
      via: "cache-only reads"
      pattern: "getRecentCandles"
    - from: "apps/api/src/services/indicator-calculation.service.ts"
      to: "candleClosePattern"
      via: "import from @livermore/cache"
      pattern: "candleClosePattern"
---

<objective>
Refactor indicator service to be event-driven with cache-only reads

Purpose: Eliminate REST API calls from indicator hot path, subscribe to candle:close events instead of WebSocket callback wiring
Output: Refactored IndicatorCalculationService that reads exclusively from Redis cache
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-indicator-refactor/06-RESEARCH.md
@apps/api/src/services/indicator-calculation.service.ts
@packages/cache/src/keys.ts
@apps/api/src/services/alert-evaluation.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add candleClosePattern helper to cache keys</name>
  <files>packages/cache/src/keys.ts</files>
  <action>
Add a new function `candleClosePattern()` that generates a glob pattern for Redis psubscribe.

```typescript
/**
 * Build a Redis psubscribe pattern for candle close events
 * Supports wildcards for symbol to subscribe to all symbols at once
 *
 * @example
 * // Subscribe to all 5m closes for user 1, exchange 1
 * candleClosePattern(1, 1, '*', '5m')
 * // Returns: "channel:candle:close:1:1:*:5m"
 */
export function candleClosePattern(
  userId: number,
  exchangeId: number,
  symbol: string,  // Can be '*' for wildcard
  timeframe: Timeframe
): string {
  return `channel:candle:close:${userId}:${exchangeId}:${symbol}:${timeframe}`;
}
```

Also export from the package's index.ts if not already re-exporting all from keys.ts.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit -p packages/cache/tsconfig.json`
Function exported: `grep "candleClosePattern" packages/cache/src/keys.ts`
  </verify>
  <done>
candleClosePattern() function exists and is exported from @livermore/cache
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor IndicatorCalculationService for event-driven operation</name>
  <files>apps/api/src/services/indicator-calculation.service.ts</files>
  <action>
Major refactor of the service. Key changes:

**1. Add dedicated subscriber and 60-candle constant:**
```typescript
private subscriber: Redis | null = null;
private readonly REQUIRED_CANDLES = 60; // IND-03: Project requirement for TradingView alignment
```

**2. Refactor start() method:**
- Create subscriber connection with `this.redis.duplicate()`
- Use psubscribe with pattern: `candleClosePattern(userId, exchangeId, '*', '5m')`
- Listen on 'pmessage' event (NOT 'message' - this is for pattern subscriptions)
- Call `handleCandleCloseEvent()` for each pmessage
- Do NOT call initializeAllConfigs() - warmup is now Phase 07's responsibility
- Just subscribe and wait for events

```typescript
async start(configs: IndicatorConfig[]): Promise<void> {
  this.configs = configs;
  this.buildConfigIndex();

  // Create dedicated subscriber (required for pub/sub mode)
  this.subscriber = this.redis.duplicate();

  // Subscribe to all 5m candle:close events
  const pattern = candleClosePattern(this.TEST_USER_ID, this.TEST_EXCHANGE_ID, '*', '5m');
  await this.subscriber.psubscribe(pattern);

  // Handle pattern messages
  this.subscriber.on('pmessage', (pattern, channel, message) => {
    this.handleCandleCloseEvent(channel, message).catch(error => {
      logger.error({ error, channel }, 'Error handling candle:close event');
    });
  });

  logger.info({ pattern, symbols: this.monitoredSymbols.size }, 'Indicator service subscribed to candle:close events');
}
```

**3. Add handleCandleCloseEvent() method:**
```typescript
private async handleCandleCloseEvent(channel: string, message: string): Promise<void> {
  // Parse channel to extract symbol: "channel:candle:close:1:1:BTC-USD:5m"
  const parts = channel.split(':');
  const symbol = parts[4];
  const timeframe = parts[5] as Timeframe;

  // Only process monitored symbols
  if (!this.monitoredSymbols.has(symbol)) {
    return;
  }

  const candle = JSON.parse(message) as UnifiedCandle;
  logger.debug({ symbol, timeframe, timestamp: candle.timestamp }, 'Processing candle:close event');

  // Recalculate 5m indicator (cache-only)
  await this.recalculateFromCache(symbol, '5m');

  // Check and recalculate higher timeframes
  await this.checkHigherTimeframes(symbol, candle.timestamp);
}
```

**4. Create recalculateFromCache() method (replaces recalculateForConfig):**
```typescript
private async recalculateFromCache(symbol: string, timeframe: Timeframe): Promise<void> {
  // Read from cache ONLY - no REST API calls
  const candles = await this.candleCache.getRecentCandles(
    this.TEST_USER_ID,
    this.TEST_EXCHANGE_ID,
    symbol,
    timeframe,
    200
  );

  // Readiness gate: skip if insufficient candles (IND-03)
  if (candles.length < this.REQUIRED_CANDLES) {
    logger.debug({
      symbol,
      timeframe,
      available: candles.length,
      required: this.REQUIRED_CANDLES,
    }, 'Skipping indicator calculation - insufficient candles');
    return;
  }

  await this.calculateIndicators(symbol, timeframe, candles);
}
```

**5. Update stop() method:**
```typescript
async stop(): Promise<void> {
  logger.info('Stopping Indicator Calculation Service');

  if (this.subscriber) {
    await this.subscriber.punsubscribe();
    await this.subscriber.quit();
    this.subscriber = null;
  }

  this.lastProcessedBoundary.clear();
  this.configsByTimeframe.clear();
  this.monitoredSymbols.clear();
}
```

**6. Remove/deprecate these methods (mark with @deprecated or delete):**
- `fetchHistoricalCandles()` - warmup is Phase 07
- `fetchRecentCandles()` - no REST in hot path
- `initializeAllConfigs()` - warmup is Phase 07
- `initializeConfig()` - warmup is Phase 07
- `processBatched()` - no REST batching needed
- `onCandleClose()` - replaced by handleCandleCloseEvent

**7. Update checkHigherTimeframes():**
Keep the boundary detection logic, but call `recalculateFromCache()` instead of `recalculateForConfig()`.
Remove the processBatched wrapper - just process directly.

**8. Remove REST client dependency from constructor:**
The `restClient` field is no longer needed for normal operation. Keep it for potential future use but don't use it in recalculation path.

**9. Import changes:**
- Add `import type { Redis } from 'ioredis';`
- Add `import { candleClosePattern } from '@livermore/cache';`
- Add `import type { UnifiedCandle } from '@livermore/schemas';`
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit -p apps/api/tsconfig.json`
No REST calls in recalculate: `grep -c "fetchRecentCandles\|restClient.getCandles" apps/api/src/services/indicator-calculation.service.ts` should be 0 or only in deprecated methods
psubscribe used: `grep "psubscribe" apps/api/src/services/indicator-calculation.service.ts`
REQUIRED_CANDLES = 60: `grep "REQUIRED_CANDLES = 60" apps/api/src/services/indicator-calculation.service.ts`
  </verify>
  <done>
Service subscribes to candle:close via psubscribe, reads only from cache, uses 60-candle readiness gate
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npm run build -w @livermore/api`
2. No REST calls in recalculation path (grep verification)
3. psubscribe pattern used for subscription
4. 60-candle readiness gate in place
5. Dedicated subscriber connection created and cleaned up
</verification>

<success_criteria>
- Zero REST API calls during normal indicator recalculation (CACHE-03)
- Subscribes to candle:close events via Redis psubscribe (IND-01)
- Reads exclusively from cache (IND-02)
- Skips symbols with < 60 candles (IND-03)
- Clean subscriber lifecycle (duplicate on start, quit on stop)
</success_criteria>

<output>
After completion, create `.planning/phases/06-indicator-refactor/06-02-SUMMARY.md`
</output>
