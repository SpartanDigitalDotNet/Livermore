---
phase: 40-trade-signals-generic-labeling
plan: 02
type: execute
wave: 2
depends_on: ["40-01"]
files_modified:
  - packages/public-api/src/routes/signals.route.ts
  - packages/public-api/src/routes/alerts.route.ts
  - packages/public-api/src/routes/index.ts
  - packages/public-api/src/plugin.ts
autonomous: true

must_haves:
  truths:
    - "External client can GET /public/v1/signals/:exchange/:symbol and receive generic signals with direction and strength per timeframe"
    - "External client can GET /public/v1/alerts and receive paginated alert history with generic labels"
    - "Signals endpoint returns momentum_signal entries for each available timeframe (15m, 1h, 4h, 1d) with optional timeframe filter"
    - "Alerts endpoint supports optional exchange, symbol, timeframe filters with cursor pagination"
    - "No indicator names appear in any response body or OpenAPI spec"
    - "OpenAPI spec at /public/v1/openapi.json includes Signals and Alerts tags with documented endpoints"
  artifacts:
    - path: "packages/public-api/src/routes/signals.route.ts"
      provides: "GET /:exchange/:symbol signal endpoint"
      contains: "signalsRoute"
    - path: "packages/public-api/src/routes/alerts.route.ts"
      provides: "GET / alerts endpoint"
      contains: "alertsRoute"
    - path: "packages/public-api/src/plugin.ts"
      provides: "Route registration and OpenAPI tags"
      contains: "Signals"
  key_links:
    - from: "packages/public-api/src/routes/signals.route.ts"
      to: "Redis via exchangeIndicatorKey"
      via: "getRedisClient().get()"
      pattern: "exchangeIndicatorKey"
    - from: "packages/public-api/src/routes/alerts.route.ts"
      to: "PostgreSQL via alertHistory table"
      via: "drizzle select query"
      pattern: "alertHistory"
    - from: "packages/public-api/src/plugin.ts"
      to: "signals.route.ts, alerts.route.ts"
      via: "fastify.register()"
      pattern: "signalsRoute|alertsRoute"
---

<objective>
Create route handlers for signals and alerts endpoints, wire them into the Fastify plugin with OpenAPI documentation.

Purpose: Expose trade signals from Redis indicator cache and alert history from PostgreSQL through the public API, completing the Phase 40 deliverables. Both routes follow Phase 39 patterns exactly (resolveExchangeId, error handling, envelope response, cursor pagination).

Output: Two new route files (signals.route.ts, alerts.route.ts), updated plugin.ts with new route registration and OpenAPI tags.
</objective>

<execution_context>
@C:/Users/Mike McWilliams/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Mike McWilliams/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-trade-signals-generic-labeling/40-RESEARCH.md
@.planning/phases/40-trade-signals-generic-labeling/40-01-SUMMARY.md

# Route patterns to follow exactly
@packages/public-api/src/routes/candles.route.ts
@packages/public-api/src/routes/symbols.route.ts
@packages/public-api/src/plugin.ts
@packages/public-api/src/helpers/pagination.ts

# Data access
@packages/cache/src/keys.ts (exchangeIndicatorKey function)
@packages/database/src/schema/alert-history.ts (alertHistory table)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create signals and alerts route handlers</name>
  <files>
    packages/public-api/src/routes/signals.route.ts
    packages/public-api/src/routes/alerts.route.ts
    packages/public-api/src/routes/index.ts
  </files>
  <action>
Create `signals.route.ts` following candles.route.ts pattern exactly:

```
export const signalsRoute: FastifyPluginAsyncZod = async (fastify) => {
```

**Setup:**
- `const redis = getRedisClient();` and `const db = getDbClient();`
- In-memory `exchangeCache = new Map<string, number>()` for exchange name -> ID resolution
- Copy `resolveExchangeId()` from candles.route.ts (same pattern: check cache, query DB for active exchange, cache result, return null if not found)
- Define `SIGNAL_TIMEFRAMES = ['15m', '1h', '4h', '1d'] as const` -- the timeframes to query for signals

**Route: GET /:exchange/:symbol**

Schema:
- `description`: Rich AI-friendly description explaining this endpoint returns generic trade signals with direction and strength per timeframe. Mention that signals are derived from real-time market analysis. Do NOT mention MACD-V, indicators, or calculation methods.
- `tags: ['Signals']`
- `params: SignalParamsSchema`
- `querystring: SignalQuerySchema`
- `response: { 200: createEnvelopeSchema(z.array(PublicSignalSchema)) }`

Handler logic:
1. Resolve exchange name -> ID via `resolveExchangeId()`. 404 if not found.
2. Determine timeframes to query: if `request.query.timeframe` is set, use `[timeframe]`; otherwise use `SIGNAL_TIMEFRAMES`.
3. For each timeframe, build Redis key using `exchangeIndicatorKey(exchangeId, symbol, timeframe, 'macd-v')` and `redis.get(key)`.
4. Parse each non-null result as JSON (CachedIndicator shape), transform via `transformIndicatorToSignal()`.
5. Only include signals where the indicator data exists AND `params?.seeded === true` (skip unseeded/incomplete indicators).
6. Return envelope: `{ success: true, data: signals, meta: { count: signals.length, next_cursor: null, has_more: false } }`. Signals are not paginated (small fixed set per symbol).

Create `alerts.route.ts` following symbols.route.ts pattern:

```
export const alertsRoute: FastifyPluginAsyncZod = async (fastify) => {
```

**Setup:**
- `const db = getDbClient();`
- In-memory `exchangeIdToName = new Map<number, string>()` for reverse lookup (ID -> name for response)
- In-memory `exchangeNameToId = new Map<string, number>()` for filter resolution

**Helper: resolveExchangeFilter(name)** -- query exchanges table for active exchange matching name, cache both directions (name->id, id->name), return id or null.

**Helper: getExchangeName(id)** -- check `exchangeIdToName` cache; if miss, query exchanges table by id, cache result, return name.

**Route: GET /**

Schema:
- `description`: Rich AI-friendly description explaining this endpoint returns historical trade alert events with generic signal classification. Describe filtering and pagination. Do NOT mention MACD-V or internal alert types.
- `tags: ['Alerts']`
- `querystring: AlertQuerySchema`
- `response: { 200: createEnvelopeSchema(z.array(PublicAlertSchema)) }`

Handler logic:
1. Parse query params: `{ exchange, symbol, timeframe, cursor, limit }`.
2. If `exchange` filter provided, resolve to ID via `resolveExchangeFilter()`. 404 if exchange not found.
3. Build Drizzle conditions array:
   - Always include: filter to only `alertType = 'macdv'` (internal -- maps to 'momentum_signal' publicly). Note: Use `eq(alertHistory.alertType, 'macdv')` but this value NEVER appears in the response.
   - If exchangeId filter: `eq(alertHistory.exchangeId, exchangeId)`
   - If symbol filter: `eq(alertHistory.symbol, symbol)`
   - If timeframe filter: `eq(alertHistory.timeframe, timeframe)`
   - If cursor: decode cursor -> `lt(alertHistory.id, cursorId)` (reverse chronological pagination)
4. Execute Drizzle query with EXPLICIT column selection (whitelist):
   ```typescript
   const rows = await db
     .select({
       id: alertHistory.id,
       symbol: alertHistory.symbol,
       timeframe: alertHistory.timeframe,
       triggeredAt: alertHistory.triggeredAt,
       triggerLabel: alertHistory.triggerLabel,
       triggerValue: alertHistory.triggerValue,
       price: alertHistory.price,
       exchangeId: alertHistory.exchangeId,
     })
     .from(alertHistory)
     .where(and(...conditions))
     .orderBy(desc(alertHistory.id))
     .limit(limit + 1);
   ```
   CRITICAL: Do NOT select `details`, `previousLabel`, `notificationSent`, `notificationError`, `alertType`, `triggeredAtEpoch`.
5. Detect has_more: `rows.length > limit`, slice to limit.
6. For each row, resolve exchangeId to name via `getExchangeName()`, transform via `transformAlertHistory(row, exchangeName)`.
7. Build pagination meta using `buildPaginationMeta()` with `lastRow.id` as cursor value.
8. Return envelope response.

Import from `@livermore/database`: `getDbClient`, `exchanges`, `alertHistory`
Import from `@livermore/cache`: `getRedisClient`, `exchangeIndicatorKey`
Import from `drizzle-orm`: `eq`, `and`, `desc`, `lt`

Update `routes/index.ts` barrel to export `signalsRoute` and `alertsRoute`.
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/public-api/tsconfig.json` -- zero errors. Grep route files for forbidden terms: `grep -iE "histogram|ema|atr|informative|details|notification|previous_label" packages/public-api/src/routes/signals.route.ts packages/public-api/src/routes/alerts.route.ts` should return zero results. Verify alertHistory query uses explicit column selection (not `select()` with no args which would be `SELECT *`).
  </verify>
  <done>
GET /signals/:exchange/:symbol returns array of generic signals per timeframe from Redis. GET /alerts returns paginated alert history from PostgreSQL with cursor pagination. Both use explicit whitelist selection. Both import from correct packages. Barrel index exports both routes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire routes into plugin and update OpenAPI tags</name>
  <files>
    packages/public-api/src/plugin.ts
  </files>
  <action>
Update `plugin.ts` to register the two new routes and add OpenAPI tags:

1. Add imports at top:
   ```typescript
   import { candlesRoute, exchangesRoute, symbolsRoute, signalsRoute, alertsRoute } from './routes/index.js';
   ```

2. Add two new OpenAPI tags to the `tags` array in the swagger config (after existing Symbols tag):
   ```typescript
   {
     name: 'Signals',
     description: 'Trade signal endpoints providing generic market analysis indicators with direction and strength classification',
   },
   {
     name: 'Alerts',
     description: 'Historical trade alert endpoints providing a chronological record of signal events',
   },
   ```

3. Register new routes after existing route registrations:
   ```typescript
   await typedInstance.register(signalsRoute, { prefix: '/signals' });
   await typedInstance.register(alertsRoute, { prefix: '/alerts' });
   ```

4. Update the OpenAPI info description to mention signals and alerts alongside candles and exchanges:
   - Add "trade signals" and "alert history" to the list of data provided
   - Keep the existing description structure, just expand the data description paragraph

Do NOT change error handler, swagger UI config, or openapi.json endpoint.
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/public-api/tsconfig.json` -- zero errors. Verify plugin.ts registers both new routes by checking for `signalsRoute` and `alertsRoute` references. Verify OpenAPI tags include 'Signals' and 'Alerts'. Grep plugin.ts for forbidden terms: `grep -iE "macd|histogram|ema|atr" packages/public-api/src/plugin.ts` should return zero results.
  </verify>
  <done>
Plugin registers /signals and /alerts route prefixes. OpenAPI spec includes Signals and Alerts tags. All 5 route handlers (candles, exchanges, symbols, signals, alerts) are wired. No indicator names in plugin.ts.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/public-api/tsconfig.json` compiles cleanly
2. OpenAPI spec at /public/v1/openapi.json includes Signals and Alerts tags with endpoint schemas
3. `grep -riE "macd|histogram|ema\b|atr\b|informative" packages/public-api/src/` returns ONLY:
   - `exchangeIndicatorKey(...)` calls (key construction, not response data)
   - `value['macdV']` in signal transformer (extraction, not exposure)
   - `alertType.*macdv` in alerts route WHERE clause (filter, not response)
   - Comment blocks documenting excluded fields
4. Signal route reads from Redis via `exchangeIndicatorKey()` -- no IndicatorCacheStrategy, no userId
5. Alert route uses explicit column selection in Drizzle query -- `details` column NEVER selected
6. Both routes use envelope response format with pagination meta
</verification>

<success_criteria>
- GET /public/v1/signals/coinbase/BTC-USD returns generic signals with direction + strength per timeframe
- GET /public/v1/alerts returns paginated alert history with generic labels, filterable by exchange/symbol/timeframe
- OpenAPI spec documents both endpoints with examples and descriptions
- Zero proprietary field names in any response or spec output
- Both routes follow Phase 39 patterns (resolveExchangeId, error handling, envelope, cursor pagination)
</success_criteria>

<output>
After completion, create `.planning/phases/40-trade-signals-generic-labeling/40-02-SUMMARY.md`
</output>
