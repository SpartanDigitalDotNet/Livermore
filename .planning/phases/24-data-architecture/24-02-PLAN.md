---
phase: 24-data-architecture
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - packages/cache/src/strategies/candle-cache.ts
  - packages/cache/src/strategies/indicator-cache.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "CandleCacheStrategy.getRecentCandles reads from exchange-scoped key first, then falls back to legacy user-scoped key"
    - "CandleCacheStrategy.addCandle accepts tier parameter (1=shared, 2=overflow) and writes to appropriate key"
    - "IndicatorCacheStrategy.getIndicator reads from exchange-scoped key first, then falls back to legacy user-scoped key"
    - "TTL is applied only to Tier 2 (user overflow) candle keys, not Tier 1 (shared) keys"
  artifacts:
    - path: "packages/cache/src/strategies/candle-cache.ts"
      provides: "Dual-read candle cache with tier support"
      exports: ["CandleCacheStrategy"]
    - path: "packages/cache/src/strategies/indicator-cache.ts"
      provides: "Dual-read indicator cache with tier support"
      exports: ["IndicatorCacheStrategy"]
  key_links:
    - from: "packages/cache/src/strategies/candle-cache.ts"
      to: "packages/cache/src/keys.ts"
      via: "Import exchangeCandleKey, userCandleKey"
      pattern: "import.*exchangeCandleKey.*from.*keys"
    - from: "packages/cache/src/strategies/indicator-cache.ts"
      to: "packages/cache/src/keys.ts"
      via: "Import exchangeIndicatorKey, userIndicatorKey"
      pattern: "import.*exchangeIndicatorKey.*from.*keys"
---

<objective>
Implement dual-read pattern in cache strategies to read from exchange-scoped keys first, falling back to legacy user-scoped keys for backward compatibility during migration.

Purpose: Enable services to transparently read from shared data when available, with automatic fallback to user-scoped data during the migration period.

Output: Updated `CandleCacheStrategy` and `IndicatorCacheStrategy` with dual-read logic and tier-aware writes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-data-architecture/24-RESEARCH.md

# Key functions created in Plan 01
@packages/cache/src/keys.ts

# Current cache strategies
@packages/cache/src/strategies/candle-cache.ts
@packages/cache/src/strategies/indicator-cache.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dual-read and tiered writes to CandleCacheStrategy</name>
  <files>packages/cache/src/strategies/candle-cache.ts</files>
  <action>
Update `packages/cache/src/strategies/candle-cache.ts`:

**1. Import new key functions:**
```typescript
import { candleKey, candleChannel, exchangeCandleKey, userCandleKey } from '../keys';
```

**2. Update `getRecentCandles` with dual-read:**
```typescript
async getRecentCandles(
  userId: number,
  exchangeId: number,
  symbol: string,
  timeframe: Timeframe,
  count: number = 100
): Promise<Candle[]> {
  // Tier 1: Try exchange-scoped key first (shared data)
  const exchangeKey = exchangeCandleKey(exchangeId, symbol, timeframe);
  let results = await this.redis.zrange(exchangeKey, -count, -1);

  // Fall back to legacy user-scoped key during migration
  if (results.length === 0) {
    const legacyKey = candleKey(userId, exchangeId, symbol, timeframe);
    results = await this.redis.zrange(legacyKey, -count, -1);
  }

  // Tier 2: Check user overflow if still empty (for user-specific symbols)
  if (results.length === 0) {
    const overflowKey = userCandleKey(userId, exchangeId, symbol, timeframe);
    results = await this.redis.zrange(overflowKey, -count, -1);
  }

  return results.map((json) => CandleSchema.parse(JSON.parse(json)));
}
```

**3. Update `getCandlesInRange` with same dual-read pattern.**

**4. Update `getLatestCandle` with same dual-read pattern.**

**5. Add tier parameter to `addCandle`:**
```typescript
async addCandle(
  userId: number,
  exchangeId: number,
  candle: Candle,
  tier: 1 | 2 = 1  // Default to shared (Tier 1)
): Promise<void> {
  const validated = CandleSchema.parse(candle);

  // Select key based on tier
  const key = tier === 1
    ? exchangeCandleKey(exchangeId, validated.symbol, validated.timeframe)
    : userCandleKey(userId, exchangeId, validated.symbol, validated.timeframe);

  await this.redis.zremrangebyscore(key, validated.timestamp, validated.timestamp);
  await this.redis.zadd(key, validated.timestamp, JSON.stringify(validated));

  // TTL only for Tier 2 (user overflow) - Tier 1 shared data has no TTL
  if (tier === 2) {
    const ttlSeconds = HARDCODED_CONFIG.cache.candleTtlHours * 3600;
    await this.redis.expire(key, ttlSeconds);
  }

  await this.redis.zremrangebyrank(key, 0, -1001);
}
```

**6. Add tier parameter to `addCandles` (bulk):**
Same pattern - use exchangeCandleKey for tier 1, userCandleKey for tier 2.
Only apply TTL for tier 2.

**7. Update `addCandleIfNewer` with tier parameter:**
Same pattern as addCandle.

**8. Keep existing method signatures working:**
All methods should work with existing callers (tier defaults to 1).
  </action>
  <verify>
Run: `cd packages/cache && npx tsc --noEmit`
Verify method signatures are backward compatible (tier has default value).
  </verify>
  <done>
- getRecentCandles reads exchange-scoped -> legacy -> user-overflow in order
- getCandlesInRange reads with same dual-read pattern
- getLatestCandle reads with same dual-read pattern
- addCandle accepts tier parameter, defaults to 1 (shared)
- addCandles accepts tier parameter, defaults to 1 (shared)
- addCandleIfNewer accepts tier parameter, defaults to 1 (shared)
- TTL only applied to Tier 2 keys
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add dual-read and tiered writes to IndicatorCacheStrategy</name>
  <files>packages/cache/src/strategies/indicator-cache.ts</files>
  <action>
Update `packages/cache/src/strategies/indicator-cache.ts`:

**1. Import new key functions:**
```typescript
import { indicatorKey, indicatorChannel, exchangeIndicatorKey, userIndicatorKey } from '../keys';
```

**2. Update `getIndicator` with dual-read:**
```typescript
async getIndicator(
  userId: number,
  exchangeId: number,
  symbol: string,
  timeframe: Timeframe,
  type: string,
  params?: Record<string, unknown>
): Promise<CachedIndicatorValue | null> {
  // Tier 1: Try exchange-scoped key first (shared data)
  const exchangeKey = exchangeIndicatorKey(exchangeId, symbol, timeframe, type, params);
  let result = await this.redis.get(exchangeKey);

  // Fall back to legacy user-scoped key during migration
  if (!result) {
    const legacyKey = indicatorKey(userId, exchangeId, symbol, timeframe, type, params);
    result = await this.redis.get(legacyKey);
  }

  // Tier 2: Check user overflow if still empty
  if (!result) {
    const overflowKey = userIndicatorKey(userId, exchangeId, symbol, timeframe, type);
    result = await this.redis.get(overflowKey);
  }

  if (!result) return null;
  return JSON.parse(result) as CachedIndicatorValue;
}
```

**3. Update `getIndicatorsBulk` with dual-read:**
For each request, check exchange-scoped first, then legacy, then overflow.
Use Promise.all for parallel fetches per tier (Azure Redis Cluster compatible).

**4. Add tier parameter to `setIndicator`:**
```typescript
async setIndicator(
  userId: number,
  exchangeId: number,
  indicator: CachedIndicatorValue,
  tier: 1 | 2 = 1  // Default to shared (Tier 1)
): Promise<void> {
  const key = tier === 1
    ? exchangeIndicatorKey(exchangeId, indicator.symbol, indicator.timeframe, indicator.type)
    : userIndicatorKey(userId, exchangeId, indicator.symbol, indicator.timeframe, indicator.type);

  await this.redis.set(key, JSON.stringify(indicator), 'EX', this.defaultTtlSeconds);
}
```

**5. Add tier parameter to `setIndicators` (bulk):**
Same pattern.

**6. Update `hasIndicator` with dual-read check:**
Return true if indicator exists in any tier (exchange-scoped, legacy, or overflow).

**7. Keep backward compatibility:**
All method signatures work with existing callers (tier defaults to 1).
  </action>
  <verify>
Run: `cd packages/cache && npx tsc --noEmit`
Verify method signatures are backward compatible.
  </verify>
  <done>
- getIndicator reads exchange-scoped -> legacy -> user-overflow in order
- getIndicatorsBulk reads with dual-read pattern
- setIndicator accepts tier parameter, defaults to 1
- setIndicators accepts tier parameter, defaults to 1
- hasIndicator checks all tiers
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify cache strategy backward compatibility</name>
  <files>N/A - verification only</files>
  <action>
Verify that existing code still works by:

1. Check that all methods have default tier values so existing callers don't break
2. Run the full TypeScript build: `npx turbo run build --filter=@livermore/cache`
3. Verify no TypeScript errors in packages that import cache strategies

The key test: Existing code that calls `addCandle(userId, exchangeId, candle)` must still work
without passing a tier parameter.
  </action>
  <verify>
Run: `npx turbo run build --filter=@livermore/cache`
Run: `npx turbo run build --filter=@livermore/coinbase-client` (uses cache strategies)
Both should complete without TypeScript errors.
  </verify>
  <done>
- Cache package builds without errors
- Dependent packages (coinbase-client, api) build without errors
- No breaking changes to existing method signatures
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx turbo run build --filter=@livermore/cache`
2. Dual-read order: exchange-scoped -> legacy -> user-overflow
3. Tier parameter defaults to 1 (shared)
4. TTL only on Tier 2 (candle cache)
5. Dependent packages still build
</verification>

<success_criteria>
- DATA-04: Cache strategies read from exchange-scoped keys first, fall back to user-scoped
- Tier 1 writes go to exchange-scoped keys (no userId in key)
- Tier 2 writes go to user-scoped keys with TTL
- All existing code continues to work without modification
</success_criteria>

<output>
After completion, create `.planning/phases/24-data-architecture/24-02-SUMMARY.md`
</output>
