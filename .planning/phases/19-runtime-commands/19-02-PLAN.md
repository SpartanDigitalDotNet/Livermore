---
phase: 19-runtime-commands
plan: 02
type: execute
wave: 2
depends_on: [19-01]
files_modified:
  - apps/api/src/server.ts
  - apps/api/src/services/control-channel.service.ts
autonomous: true

must_haves:
  truths:
    - "Pause command stops WebSocket and indicator processing (RUN-04)"
    - "Resume command restarts WebSocket and indicator processing (RUN-05)"
    - "Services are stopped in correct dependency order (downstream first)"
    - "Services are started in correct dependency order (upstream first)"
  artifacts:
    - path: "apps/api/src/server.ts"
      provides: "ServiceRegistry injection to ControlChannelService"
      contains: "new ControlChannelService(TEST_IDENTITY_SUB, services)"
    - path: "apps/api/src/services/control-channel.service.ts"
      provides: "Command dispatcher and pause/resume handlers"
      contains: "handlePause"
  key_links:
    - from: "apps/api/src/server.ts"
      to: "apps/api/src/services/control-channel.service.ts"
      via: "ServiceRegistry parameter"
      pattern: "services.*coinbaseAdapter"
    - from: "apps/api/src/services/control-channel.service.ts"
      to: "services.coinbaseAdapter"
      via: "disconnect/connect calls"
      pattern: "this\\.services.*disconnect|connect"
---

<objective>
Inject services into ControlChannelService from server.ts and implement pause/resume command handlers.

Purpose: Satisfies RUN-04 (pause stops WebSocket and indicators) and RUN-05 (resume restarts them). The pause/resume handlers need actual service references to call stop/start methods.

Output: Working pause/resume commands that stop and restart the data pipeline.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-runtime-commands/19-RESEARCH.md
@.planning/phases/19-runtime-commands/19-01-SUMMARY.md
@apps/api/src/services/control-channel.service.ts
@apps/api/src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inject ServiceRegistry in server.ts</name>
  <files>apps/api/src/server.ts</files>
  <action>
Modify server.ts to build ServiceRegistry and pass to ControlChannelService:

1. Import ServiceRegistry and RuntimeConfig:
```typescript
import type { ServiceRegistry, RuntimeConfig } from './services/types/service-registry';
```

2. After all services are created (coinbaseAdapter, indicatorService, alertService, boundaryRestService), but BEFORE controlChannelService.start(), build the registry:

```typescript
// Build ServiceRegistry for ControlChannelService command handlers
const runtimeConfig: RuntimeConfig = {
  apiKeyId: config.Coinbase_ApiKeyId,
  privateKeyPem: config.Coinbase_EcPrivateKeyPem,
};

const serviceRegistry: ServiceRegistry = {
  coinbaseAdapter,
  indicatorService,
  alertService,
  boundaryRestService,
  redis,
  db,
  config: runtimeConfig,
  // Store symbols and configs for resume
  monitoredSymbols,
  indicatorConfigs,
  timeframes: SUPPORTED_TIMEFRAMES,
};
```

3. Update ControlChannelService instantiation to pass services:
```typescript
const controlChannelService = new ControlChannelService(TEST_IDENTITY_SUB, serviceRegistry);
```

4. Move ControlChannelService instantiation AFTER all services are created but BEFORE server starts listening (so pause/resume have access to all services).

IMPORTANT: The order should be:
- Create all services (adapter, indicator, alert, boundary)
- Build ServiceRegistry
- Create ControlChannelService WITH ServiceRegistry
- Start ControlChannelService
- Start other services
- Start server listening

This ensures ControlChannelService can receive commands as soon as it starts, with full access to all services.
  </action>
  <verify>
Server starts without errors: `cd apps/api && npm run dev` (Ctrl+C after startup logs)
No TypeScript errors: `cd apps/api && npx tsc --noEmit`
  </verify>
  <done>ServiceRegistry injected into ControlChannelService, server starts successfully</done>
</task>

<task type="auto">
  <name>Task 2: Implement command dispatcher and pause/resume handlers</name>
  <files>apps/api/src/services/control-channel.service.ts</files>
  <action>
Replace the stub executeCommand() with a proper dispatcher and implement pause/resume handlers:

1. Add import for Timeframe type:
```typescript
import type { Timeframe } from '@livermore/schemas';
```

2. Replace executeCommand() with dispatcher:
```typescript
private async executeCommand(command: Command): Promise<Record<string, unknown>> {
  const { type, payload } = command;

  logger.info({ type, payload }, 'Executing command');

  switch (type) {
    case 'pause':
      return this.handlePause();
    case 'resume':
      return this.handleResume();
    case 'reload-settings':
      return this.handleReloadSettings();
    case 'switch-mode':
      return this.handleSwitchMode(payload);
    case 'force-backfill':
      return this.handleForceBackfill(payload);
    case 'clear-cache':
      return this.handleClearCache(payload);
    default:
      throw new Error(`Unknown command type: ${type}`);
  }
}
```

3. Implement handlePause():
```typescript
/**
 * Handle pause command (RUN-04)
 * Stops services in dependency order: downstream first (consumers before producers)
 */
private async handlePause(): Promise<Record<string, unknown>> {
  if (!this.services) {
    throw new Error('Services not initialized');
  }

  if (this.isPaused) {
    return { status: 'already_paused' };
  }

  logger.info('Pausing services...');

  // Stop in dependency order (downstream to upstream)
  // 1. AlertService - consumes indicator events
  await this.services.alertService.stop();
  logger.debug('AlertService stopped');

  // 2. CoinbaseAdapter - produces candle events (disconnect WebSocket)
  this.services.coinbaseAdapter.disconnect();
  logger.debug('CoinbaseAdapter disconnected');

  // 3. BoundaryRestService - produces candle events from REST
  await this.services.boundaryRestService.stop();
  logger.debug('BoundaryRestService stopped');

  // 4. IndicatorService - consumes candle events
  await this.services.indicatorService.stop();
  logger.debug('IndicatorService stopped');

  this.isPaused = true;
  logger.info('All services paused');

  return {
    status: 'paused',
    timestamp: Date.now(),
  };
}
```

4. Implement handleResume():
```typescript
/**
 * Handle resume command (RUN-05)
 * Starts services in dependency order: upstream first (producers before consumers)
 */
private async handleResume(): Promise<Record<string, unknown>> {
  if (!this.services) {
    throw new Error('Services not initialized');
  }

  if (!this.isPaused) {
    return { status: 'already_running' };
  }

  logger.info('Resuming services...');

  // Start in dependency order (upstream to downstream)
  // 1. IndicatorService - needs to be listening before events arrive
  await this.services.indicatorService.start(this.services.indicatorConfigs);
  logger.debug('IndicatorService started');

  // 2. CoinbaseAdapter - connect WebSocket and subscribe
  await this.services.coinbaseAdapter.connect();
  this.services.coinbaseAdapter.subscribe(this.services.monitoredSymbols, '5m');
  logger.debug('CoinbaseAdapter connected and subscribed');

  // 3. BoundaryRestService - start listening for boundary events
  await this.services.boundaryRestService.start(this.services.monitoredSymbols);
  logger.debug('BoundaryRestService started');

  // 4. AlertService - start evaluating alerts
  await this.services.alertService.start(
    this.services.monitoredSymbols,
    this.services.timeframes
  );
  logger.debug('AlertService started');

  this.isPaused = false;
  logger.info('All services resumed');

  return {
    status: 'resumed',
    timestamp: Date.now(),
  };
}
```

5. Add stub handlers for other commands (to be implemented in Plan 03):
```typescript
private async handleReloadSettings(): Promise<Record<string, unknown>> {
  throw new Error('reload-settings not yet implemented');
}

private async handleSwitchMode(_payload?: Record<string, unknown>): Promise<Record<string, unknown>> {
  throw new Error('switch-mode not yet implemented');
}

private async handleForceBackfill(_payload?: Record<string, unknown>): Promise<Record<string, unknown>> {
  throw new Error('force-backfill not yet implemented');
}

private async handleClearCache(_payload?: Record<string, unknown>): Promise<Record<string, unknown>> {
  throw new Error('clear-cache not yet implemented');
}
```
  </action>
  <verify>
TypeScript compiles: `cd apps/api && npx tsc --noEmit`
Server starts: `cd apps/api && npm run dev` (check logs for "Control Channel Service started")
  </verify>
  <done>Command dispatcher routes to handlers, pause/resume handlers implemented with correct service ordering</done>
</task>

<task type="auto">
  <name>Task 3: Update ServiceRegistry interface with runtime state</name>
  <files>apps/api/src/services/types/service-registry.ts</files>
  <action>
Add the runtime state fields to ServiceRegistry that pause/resume need:

```typescript
// Add to ServiceRegistry interface:
/** Symbols currently being monitored (for resume resubscription) */
monitoredSymbols: string[];

/** Indicator configs for all symbol/timeframe combinations */
indicatorConfigs: Array<{ symbol: string; timeframe: Timeframe }>;

/** Supported timeframes for alert service */
timeframes: Timeframe[];
```

Import Timeframe type:
```typescript
import type { Timeframe } from '@livermore/schemas';
```

This allows pause/resume to know which symbols and configs to use when restarting services.
  </action>
  <verify>
TypeScript compiles: `cd apps/api && npx tsc --noEmit`
  </verify>
  <done>ServiceRegistry includes monitoredSymbols, indicatorConfigs, and timeframes fields</done>
</task>

</tasks>

<verification>
1. Server starts with ServiceRegistry injected
2. TypeScript compiles without errors
3. Pause command logs show services stopping in correct order
4. Resume command logs show services starting in correct order
5. isPaused state toggles correctly
</verification>

<success_criteria>
- RUN-04: pause command stops WebSocket and indicators (logs confirm stop order)
- RUN-05: resume command restarts WebSocket and indicators (logs confirm start order)
- Server starts and ControlChannelService has access to all services
- Stub handlers exist for other commands (throw "not yet implemented")
</success_criteria>

<output>
After completion, create `.planning/phases/19-runtime-commands/19-02-SUMMARY.md`
</output>
