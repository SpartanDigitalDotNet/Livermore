---
phase: 19-runtime-commands
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/services/types/service-registry.ts
  - apps/api/src/services/control-channel.service.ts
autonomous: true

must_haves:
  truths:
    - "ControlChannelService can access other services via typed registry"
    - "Service registry interface defines all pausable services"
    - "Constructor signature changed but existing start/stop still works"
  artifacts:
    - path: "apps/api/src/services/types/service-registry.ts"
      provides: "ServiceRegistry interface definition"
      exports: ["ServiceRegistry", "RuntimeConfig"]
    - path: "apps/api/src/services/control-channel.service.ts"
      provides: "Updated constructor accepting services"
      contains: "private services"
  key_links:
    - from: "apps/api/src/services/control-channel.service.ts"
      to: "apps/api/src/services/types/service-registry.ts"
      via: "import ServiceRegistry"
      pattern: "import.*ServiceRegistry"
---

<objective>
Create ServiceRegistry interface and modify ControlChannelService to accept service references via constructor injection.

Purpose: ControlChannelService needs access to CoinbaseAdapter, IndicatorCalculationService, AlertEvaluationService, and BoundaryRestService to implement pause/resume and other runtime commands. The ServiceRegistry pattern provides type-safe dependency injection.

Output: ServiceRegistry type file and updated ControlChannelService constructor that accepts services parameter.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-runtime-commands/19-RESEARCH.md
@apps/api/src/services/control-channel.service.ts
@apps/api/src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ServiceRegistry interface</name>
  <files>apps/api/src/services/types/service-registry.ts</files>
  <action>
Create a new file defining the ServiceRegistry interface that ControlChannelService will use to access other services.

The interface should include:
1. `coinbaseAdapter` - CoinbaseAdapter instance (for WebSocket disconnect/connect)
2. `indicatorService` - IndicatorCalculationService instance (for stop/start)
3. `alertService` - AlertEvaluationService instance (for stop/start)
4. `boundaryRestService` - BoundaryRestService instance (for stop/start)
5. `redis` - Redis client (for cache clearing)
6. `db` - Database client (for settings reload)
7. `config` - RuntimeConfig with Coinbase credentials (for backfill)

Also define RuntimeConfig interface:
```typescript
interface RuntimeConfig {
  apiKeyId: string;
  privateKeyPem: string;
}
```

Import types from their respective packages:
- CoinbaseAdapter from '@livermore/coinbase-client'
- IndicatorCalculationService from '../indicator-calculation.service'
- AlertEvaluationService from '../alert-evaluation.service'
- BoundaryRestService from '@livermore/coinbase-client'
- Redis from 'ioredis'
- db type inferred from getDbClient

Export both interfaces.
  </action>
  <verify>
File exists at apps/api/src/services/types/service-registry.ts.
TypeScript compiles without errors: `cd apps/api && npx tsc --noEmit`
  </verify>
  <done>ServiceRegistry interface exported with all required service types</done>
</task>

<task type="auto">
  <name>Task 2: Modify ControlChannelService constructor</name>
  <files>apps/api/src/services/control-channel.service.ts</files>
  <action>
Update ControlChannelService to accept services via constructor:

1. Import ServiceRegistry from './types/service-registry'

2. Add private field:
```typescript
private services: ServiceRegistry | null = null;
```

3. Update constructor to accept optional services parameter:
```typescript
constructor(identitySub: string, services?: ServiceRegistry) {
  this.identitySub = identitySub;
  this.commandChannelKey = commandChannel(identitySub);
  this.responseChannelKey = responseChannel(identitySub);
  this.commandQueueKey = `livermore:command-queue:${identitySub}`;
  if (services) {
    this.services = services;
  }
}
```

4. Add isPaused state field:
```typescript
private isPaused = false;
```

5. Add getter for paused state:
```typescript
get paused(): boolean {
  return this.isPaused;
}
```

DO NOT modify executeCommand() yet - that will be in Plan 02.

The services parameter is optional so server.ts continues to work until Plan 02 updates it.
  </action>
  <verify>
File compiles without errors: `cd apps/api && npx tsc --noEmit`
Existing tests pass (if any): `cd apps/api && npm test`
  </verify>
  <done>ControlChannelService constructor accepts optional ServiceRegistry, has isPaused state field</done>
</task>

</tasks>

<verification>
1. Both files exist and TypeScript compiles
2. ServiceRegistry interface exports all required service types
3. ControlChannelService constructor accepts ServiceRegistry parameter
4. Server still starts (services parameter optional, backward compatible)
</verification>

<success_criteria>
- ServiceRegistry interface defined with all service types
- ControlChannelService constructor updated to accept services
- Backward compatible - server.ts still works without changes
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/19-runtime-commands/19-01-SUMMARY.md`
</output>
