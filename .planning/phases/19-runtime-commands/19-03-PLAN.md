---
phase: 19-runtime-commands
plan: 03
type: execute
wave: 3
depends_on: [19-02]
files_modified:
  - apps/api/src/services/control-channel.service.ts
autonomous: true

must_haves:
  truths:
    - "reload-settings fetches settings from database and applies them (RUN-06)"
    - "switch-mode validates mode and returns stub response (RUN-07)"
    - "force-backfill triggers candle backfill for specified symbol (RUN-08)"
    - "clear-cache clears Redis cache with appropriate scope (RUN-09)"
  artifacts:
    - path: "apps/api/src/services/control-channel.service.ts"
      provides: "All command handlers implemented"
      contains: ["handleReloadSettings", "handleSwitchMode", "handleForceBackfill", "handleClearCache"]
  key_links:
    - from: "handleForceBackfill"
      to: "StartupBackfillService"
      via: "instantiation and backfill call"
      pattern: "StartupBackfillService.*backfill"
    - from: "handleClearCache"
      to: "redis.keys/del"
      via: "pattern-based key deletion"
      pattern: "redis\\.keys.*redis\\.del"
---

<objective>
Implement the remaining runtime command handlers: reload-settings, switch-mode (stub), force-backfill, and clear-cache.

Purpose: Completes Phase 19 requirements RUN-06 through RUN-09. These handlers provide operational control over the API without requiring restarts.

Output: All command handlers fully implemented, Phase 19 complete.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-runtime-commands/19-RESEARCH.md
@.planning/phases/19-runtime-commands/19-02-SUMMARY.md
@apps/api/src/services/control-channel.service.ts
@packages/cache/src/keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement reload-settings handler (RUN-06)</name>
  <files>apps/api/src/services/control-channel.service.ts</files>
  <action>
Replace the stub handleReloadSettings() with actual implementation:

1. Add required imports at top of file:
```typescript
import { eq, and } from 'drizzle-orm';
import { users } from '@livermore/database';
```

2. Implement handleReloadSettings():
```typescript
/**
 * Handle reload-settings command (RUN-06)
 * Fetches user settings from database
 *
 * Note: Currently just validates settings exist. Future phases will
 * apply settings to running services (symbol list, alert thresholds, etc.)
 */
private async handleReloadSettings(): Promise<Record<string, unknown>> {
  if (!this.services) {
    throw new Error('Services not initialized');
  }

  logger.info({ identitySub: this.identitySub }, 'Reloading settings from database');

  // Fetch settings from database
  const result = await this.services.db
    .select({ settings: users.settings })
    .from(users)
    .where(
      and(
        eq(users.identityProvider, 'clerk'),
        eq(users.identitySub, this.identitySub)
      )
    )
    .limit(1);

  if (result.length === 0) {
    throw new Error(`User not found: ${this.identitySub}`);
  }

  const settings = result[0].settings;

  // Log what was loaded
  logger.info(
    { identitySub: this.identitySub, hasSettings: settings !== null },
    'Settings reloaded from database'
  );

  // TODO: Apply settings to running services
  // This will be expanded when symbol management and other
  // runtime-configurable settings are implemented

  return {
    reloaded: true,
    timestamp: Date.now(),
    hasSettings: settings !== null,
  };
}
```

Note: The handler fetches and validates settings but doesn't yet apply them to running services. Full settings application will be implemented when symbol management (Phase 20) is complete.
  </action>
  <verify>
TypeScript compiles: `cd apps/api && npx tsc --noEmit`
  </verify>
  <done>reload-settings handler fetches settings from database, returns confirmation</done>
</task>

<task type="auto">
  <name>Task 2: Implement switch-mode handler stub (RUN-07)</name>
  <files>apps/api/src/services/control-channel.service.ts</files>
  <action>
Replace the stub handleSwitchMode() with a proper stub that validates input:

```typescript
/**
 * Handle switch-mode command (RUN-07)
 * STUB: Validates mode but does not actually switch
 *
 * Valid modes:
 * - position-monitor: Track positions only (current default)
 * - scalper-macdv: MACD-V based scalping signals
 * - scalper-orderbook: Orderbook imbalance scalping (v4.1)
 */
private async handleSwitchMode(payload?: Record<string, unknown>): Promise<Record<string, unknown>> {
  const mode = payload?.mode as string | undefined;

  const validModes = ['position-monitor', 'scalper-macdv', 'scalper-orderbook'];

  if (!mode) {
    throw new Error('mode is required in payload');
  }

  if (!validModes.includes(mode)) {
    throw new Error(`Invalid mode: ${mode}. Must be one of: ${validModes.join(', ')}`);
  }

  // RUN-07 specifies this is a stub for now
  // scalper-orderbook requires orderbook imbalance detection (v4.1)
  // scalper-macdv requires strategy implementation
  logger.info({ mode }, 'Mode switch requested (stub - no actual change)');

  return {
    switched: false,
    mode,
    message: 'Mode switching is a stub - actual implementation pending strategy work',
    validModes,
  };
}
```
  </action>
  <verify>
TypeScript compiles: `cd apps/api && npx tsc --noEmit`
  </verify>
  <done>switch-mode handler validates mode, returns stub response with valid modes</done>
</task>

<task type="auto">
  <name>Task 3: Implement force-backfill and clear-cache handlers (RUN-08, RUN-09)</name>
  <files>apps/api/src/services/control-channel.service.ts</files>
  <action>
1. Add import for StartupBackfillService:
```typescript
import { StartupBackfillService } from '@livermore/coinbase-client';
```

2. Implement handleForceBackfill():
```typescript
/**
 * Handle force-backfill command (RUN-08)
 * Triggers candle backfill for a specified symbol
 *
 * Payload:
 * - symbol: string (required) - e.g., "BTC-USD"
 * - timeframes: string[] (optional) - defaults to all supported
 */
private async handleForceBackfill(payload?: Record<string, unknown>): Promise<Record<string, unknown>> {
  if (!this.services) {
    throw new Error('Services not initialized');
  }

  const symbol = payload?.symbol as string | undefined;
  if (!symbol) {
    throw new Error('symbol is required in payload');
  }

  // Use specified timeframes or default to all
  const requestedTimeframes = payload?.timeframes as Timeframe[] | undefined;
  const timeframes: Timeframe[] = requestedTimeframes ?? ['1m', '5m', '15m', '1h', '4h', '1d'];

  logger.info({ symbol, timeframes }, 'Starting force backfill');

  // Create backfill service with credentials from config
  const backfillService = new StartupBackfillService(
    this.services.config.apiKeyId,
    this.services.config.privateKeyPem,
    this.services.redis
  );

  // Run backfill for the symbol
  await backfillService.backfill([symbol], timeframes);

  // Force indicator recalculation after backfill
  for (const timeframe of timeframes) {
    await this.services.indicatorService.forceRecalculate(symbol, timeframe);
  }

  logger.info({ symbol, timeframes }, 'Force backfill complete');

  return {
    backfilled: true,
    symbol,
    timeframes,
    timestamp: Date.now(),
  };
}
```

3. Implement handleClearCache():
```typescript
/**
 * Handle clear-cache command (RUN-09)
 * Clears Redis cache with specified scope
 *
 * Payload:
 * - scope: 'all' | 'symbol' | 'timeframe' (required)
 * - symbol: string (required if scope='symbol')
 * - timeframe: string (required if scope='timeframe')
 */
private async handleClearCache(payload?: Record<string, unknown>): Promise<Record<string, unknown>> {
  if (!this.services) {
    throw new Error('Services not initialized');
  }

  const scope = payload?.scope as string | undefined;
  if (!scope) {
    throw new Error('scope is required in payload (all, symbol, or timeframe)');
  }

  const symbol = payload?.symbol as string | undefined;
  const timeframe = payload?.timeframe as Timeframe | undefined;

  // Hardcoded for now - will use identity mapping when multi-user is implemented
  const userId = 1;
  const exchangeId = 1;

  let deletedCount = 0;

  switch (scope) {
    case 'all': {
      // Delete all candles and indicators for this user
      const candlePattern = `candles:${userId}:${exchangeId}:*`;
      const indicatorPattern = `indicator:${userId}:${exchangeId}:*`;
      const tickerPattern = `ticker:${userId}:${exchangeId}:*`;

      const candleKeys = await this.services.redis.keys(candlePattern);
      const indicatorKeys = await this.services.redis.keys(indicatorPattern);
      const tickerKeys = await this.services.redis.keys(tickerPattern);

      const allKeys = [...candleKeys, ...indicatorKeys, ...tickerKeys];
      if (allKeys.length > 0) {
        await this.services.redis.del(...allKeys);
        deletedCount = allKeys.length;
      }
      break;
    }

    case 'symbol': {
      if (!symbol) {
        throw new Error('symbol is required when scope=symbol');
      }

      // Delete all timeframes for this symbol
      const candlePattern = `candles:${userId}:${exchangeId}:${symbol}:*`;
      const indicatorPattern = `indicator:${userId}:${exchangeId}:${symbol}:*`;
      const tickerKey = `ticker:${userId}:${exchangeId}:${symbol}`;

      const candleKeys = await this.services.redis.keys(candlePattern);
      const indicatorKeys = await this.services.redis.keys(indicatorPattern);

      const allKeys = [...candleKeys, ...indicatorKeys, tickerKey];
      if (allKeys.length > 0) {
        await this.services.redis.del(...allKeys);
        deletedCount = allKeys.length;
      }
      break;
    }

    case 'timeframe': {
      if (!timeframe) {
        throw new Error('timeframe is required when scope=timeframe');
      }

      // Delete all symbols for this timeframe
      const candlePattern = `candles:${userId}:${exchangeId}:*:${timeframe}`;
      const indicatorPattern = `indicator:${userId}:${exchangeId}:*:${timeframe}:*`;

      const candleKeys = await this.services.redis.keys(candlePattern);
      const indicatorKeys = await this.services.redis.keys(indicatorPattern);

      const allKeys = [...candleKeys, ...indicatorKeys];
      if (allKeys.length > 0) {
        await this.services.redis.del(...allKeys);
        deletedCount = allKeys.length;
      }
      break;
    }

    default:
      throw new Error(`Invalid scope: ${scope}. Must be one of: all, symbol, timeframe`);
  }

  logger.info({ scope, symbol, timeframe, deletedCount }, 'Cache cleared');

  return {
    cleared: true,
    scope,
    symbol,
    timeframe,
    deletedCount,
    timestamp: Date.now(),
  };
}
```
  </action>
  <verify>
TypeScript compiles: `cd apps/api && npx tsc --noEmit`
Server starts: `cd apps/api && npm run dev` (Ctrl+C after confirming startup)
  </verify>
  <done>force-backfill and clear-cache handlers implemented with proper scope handling</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Server starts successfully
3. All command handlers implemented (no more "not yet implemented" stubs)
4. reload-settings queries database for user settings
5. switch-mode validates mode and returns stub response
6. force-backfill uses StartupBackfillService pattern
7. clear-cache supports all, symbol, and timeframe scopes
</verification>

<success_criteria>
- RUN-06: reload-settings fetches settings from database
- RUN-07: switch-mode validates mode, returns stub response
- RUN-08: force-backfill triggers candle backfill and indicator recalculation
- RUN-09: clear-cache clears Redis with appropriate scope (all/symbol/timeframe)
- All Phase 19 requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/19-runtime-commands/19-03-SUMMARY.md`
</output>
