---
phase: 04-foundation
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - packages/coinbase-client/src/adapter/base-adapter.ts
  - packages/coinbase-client/src/adapter/index.ts
  - packages/coinbase-client/src/index.ts
autonomous: true

must_haves:
  truths:
    - "BaseExchangeAdapter is abstract class implementing IExchangeAdapter"
    - "Abstract methods defined for connect, disconnect, subscribe, unsubscribe, isConnected"
    - "Shared reconnection logic with exponential backoff implemented in protected method"
    - "Class extends EventEmitter<ExchangeAdapterEvents> for typed events"
  artifacts:
    - path: "packages/coinbase-client/src/adapter/base-adapter.ts"
      provides: "BaseExchangeAdapter abstract class"
      exports: ["BaseExchangeAdapter"]
      min_lines: 50
    - path: "packages/coinbase-client/src/adapter/index.ts"
      provides: "Barrel export for adapter"
      exports: ["*"]
  key_links:
    - from: "packages/coinbase-client/src/adapter/base-adapter.ts"
      to: "@livermore/schemas"
      via: "imports IExchangeAdapter, ExchangeAdapterEvents, Timeframe"
      pattern: "import.*from '@livermore/schemas'"
    - from: "packages/coinbase-client/src/index.ts"
      to: "packages/coinbase-client/src/adapter/index.ts"
      via: "barrel export"
      pattern: "export \\* from './adapter'"
---

<objective>
Create abstract base class for exchange adapters with shared reconnection logic.

Purpose: Provide common infrastructure (exponential backoff, event emission, connection state) that all exchange adapters will inherit. Phase 05 (Coinbase Adapter) will extend this class, and future Binance adapter will reuse the same base.

Output:
- `BaseExchangeAdapter` abstract class with:
  - Abstract methods: connect, disconnect, subscribe, unsubscribe, isConnected
  - Shared: handleReconnect() with exponential backoff
  - Shared: connection state tracking
  - Shared: properly typed event emission
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-foundation/04-RESEARCH.md

# Dependent on Plan 01 output
@packages/schemas/src/adapter/exchange-adapter.schema.ts

# Existing patterns (current WebSocket client has similar reconnection logic)
@packages/coinbase-client/src/websocket/client.ts
@packages/coinbase-client/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BaseExchangeAdapter abstract class</name>
  <files>packages/coinbase-client/src/adapter/base-adapter.ts</files>
  <action>
Create new file `packages/coinbase-client/src/adapter/base-adapter.ts`:

```typescript
import { EventEmitter } from 'events';
import { logger } from '@livermore/utils';
import type { ExchangeAdapterEvents, IExchangeAdapter, Timeframe } from '@livermore/schemas';

/**
 * Abstract base class for exchange adapters
 *
 * Provides shared infrastructure for all exchange implementations:
 * - Typed event emission (candle:close, connected, disconnected, error, reconnecting)
 * - Exponential backoff reconnection logic
 * - Connection state tracking
 *
 * Concrete adapters (CoinbaseAdapter, BinanceAdapter) extend this class
 * and implement the abstract methods.
 */
export abstract class BaseExchangeAdapter
  extends EventEmitter<ExchangeAdapterEvents>
  implements IExchangeAdapter
{
  /** Current reconnection attempt counter */
  protected reconnectAttempts = 0;

  /** Maximum reconnection attempts before giving up */
  protected maxReconnectAttempts = 10;

  /** Base delay between reconnection attempts (ms) */
  protected reconnectDelay = 5000;

  /** Exchange identifier for logging and UnifiedCandle.exchange field */
  protected abstract readonly exchangeId: string;

  /**
   * Establish connection to exchange WebSocket
   * Implementations should:
   * 1. Create WebSocket connection
   * 2. Set up message handlers
   * 3. Emit 'connected' event on success
   * 4. Call handleReconnect() on unexpected disconnect
   */
  abstract connect(): Promise<void>;

  /**
   * Gracefully close connection
   * Implementations should:
   * 1. Set intentional close flag to prevent auto-reconnect
   * 2. Close WebSocket connection
   * 3. Emit 'disconnected' event with reason
   */
  abstract disconnect(): void;

  /**
   * Subscribe to candle updates for symbols
   * @param symbols Array of trading pairs (e.g., ['BTC-USD', 'ETH-USD'])
   * @param timeframe Candle timeframe (e.g., '5m')
   */
  abstract subscribe(symbols: string[], timeframe: Timeframe): void;

  /**
   * Unsubscribe from candle updates
   * @param symbols Array of trading pairs to unsubscribe
   * @param timeframe Candle timeframe
   */
  abstract unsubscribe(symbols: string[], timeframe: Timeframe): void;

  /**
   * Check if currently connected to exchange
   */
  abstract isConnected(): boolean;

  /**
   * Handle reconnection with exponential backoff
   *
   * Call this from concrete adapter's close/error handlers when
   * disconnection was unexpected (not intentional close).
   *
   * Emits 'reconnecting' event before each attempt.
   * Emits 'error' event if max attempts reached.
   */
  protected async handleReconnect(): Promise<void> {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      const error = new Error(
        `Max reconnection attempts (${this.maxReconnectAttempts}) reached for ${this.exchangeId}`
      );
      logger.error({ exchangeId: this.exchangeId }, error.message);
      this.emit('error', error);
      return;
    }

    this.reconnectAttempts++;
    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);

    logger.info(
      { exchangeId: this.exchangeId, attempt: this.reconnectAttempts, delay },
      'Attempting to reconnect to exchange WebSocket'
    );

    this.emit('reconnecting', this.reconnectAttempts, delay);

    await new Promise(resolve => setTimeout(resolve, delay));

    try {
      await this.connect();
      // Reset counter on successful reconnect
      this.reconnectAttempts = 0;
    } catch (error) {
      logger.error(
        { exchangeId: this.exchangeId, error, attempt: this.reconnectAttempts },
        'Reconnection attempt failed'
      );
      // Recursive call for next attempt
      await this.handleReconnect();
    }
  }

  /**
   * Reset reconnection counter
   * Call this after successful connection in concrete adapter
   */
  protected resetReconnectAttempts(): void {
    this.reconnectAttempts = 0;
  }
}
```

**Key design decisions:**
- Uses `abstract readonly exchangeId` so concrete classes define their exchange name
- `handleReconnect()` is protected - called by concrete adapters, not external code
- Resets reconnect counter on successful connect (inside handleReconnect)
- Uses existing logger from @livermore/utils
- Follows existing reconnection pattern from CoinbaseWebSocketClient
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/coinbase-client/tsconfig.json` - should compile without errors.
Verify class extends EventEmitter<ExchangeAdapterEvents>.
Verify all IExchangeAdapter methods are declared as abstract.
  </verify>
  <done>
- BaseExchangeAdapter abstract class created
- Extends EventEmitter<ExchangeAdapterEvents> for typed events
- Implements IExchangeAdapter interface
- 5 abstract methods defined (connect, disconnect, subscribe, unsubscribe, isConnected)
- handleReconnect() method with exponential backoff
- exchangeId abstract property for logging
  </done>
</task>

<task type="auto">
  <name>Task 2: Create barrel export and update coinbase-client index</name>
  <files>packages/coinbase-client/src/adapter/index.ts, packages/coinbase-client/src/index.ts</files>
  <action>
1. **Create barrel export** at `packages/coinbase-client/src/adapter/index.ts`:
   ```typescript
   /**
    * Exchange adapter base class and types
    */
   export { BaseExchangeAdapter } from './base-adapter';
   ```

2. **Update main index** at `packages/coinbase-client/src/index.ts`:
   Add export line at the end of file:
   ```typescript
   // Adapter base class
   export * from './adapter';
   ```

This makes BaseExchangeAdapter importable from @livermore/coinbase-client.
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/coinbase-client/tsconfig.json` - should compile without errors.
Verify BaseExchangeAdapter is exported from @livermore/coinbase-client.
  </verify>
  <done>
- adapter/index.ts barrel export created
- coinbase-client/index.ts updated to export adapter module
- BaseExchangeAdapter exported from @livermore/coinbase-client
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `npx tsc --noEmit -p packages/coinbase-client/tsconfig.json` passes
2. `npx tsc --noEmit -p packages/schemas/tsconfig.json` passes
3. BaseExchangeAdapter is importable from @livermore/coinbase-client

Integration check:
```typescript
import { BaseExchangeAdapter } from '@livermore/coinbase-client';
import { IExchangeAdapter, UnifiedCandle } from '@livermore/schemas';

// Verify types are compatible
const adapter: IExchangeAdapter = {} as BaseExchangeAdapter;
```
</verification>

<success_criteria>
- [ ] BaseExchangeAdapter abstract class created in adapter/base-adapter.ts
- [ ] Class extends EventEmitter<ExchangeAdapterEvents>
- [ ] Class implements IExchangeAdapter interface
- [ ] 5 abstract methods declared (connect, disconnect, subscribe, unsubscribe, isConnected)
- [ ] handleReconnect() protected method with exponential backoff
- [ ] exchangeId abstract property defined
- [ ] Barrel export created and main index updated
- [ ] TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/04-foundation/04-03-SUMMARY.md`
</output>
