---
phase: 04-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/cache/src/keys.ts
  - packages/cache/src/strategies/candle-cache.ts
autonomous: true

must_haves:
  truths:
    - "candleCloseChannel() function generates Redis pub/sub channel for candle:close events"
    - "addCandleIfNewer() method rejects writes when existing candle has higher/equal sequence number"
    - "Versioned writes use sequence number comparison, not just timestamp"
    - "Both functions follow existing naming and parameter conventions"
  artifacts:
    - path: "packages/cache/src/keys.ts"
      provides: "candleCloseChannel() function"
      exports: ["candleCloseChannel"]
      contains: "candleCloseChannel"
    - path: "packages/cache/src/strategies/candle-cache.ts"
      provides: "addCandleIfNewer() method on CandleCacheStrategy"
      contains: "addCandleIfNewer"
  key_links:
    - from: "packages/cache/src/strategies/candle-cache.ts"
      to: "packages/cache/src/keys.ts"
      via: "uses candleKey for cache operations"
      pattern: "candleKey\\("
    - from: "packages/cache/src/index.ts"
      to: "packages/cache/src/keys.ts"
      via: "already exports keys"
      pattern: "export \\* from './keys'"
---

<objective>
Add Redis pub/sub channel pattern for candle:close events and versioned cache write operations.

Purpose: Enable event-driven architecture where adapters publish candle close events and indicator service subscribes. Versioned writes prevent out-of-order WebSocket messages from corrupting cache with stale data.

Output:
- `candleCloseChannel()` function following existing channel naming pattern
- `addCandleIfNewer()` method on CandleCacheStrategy that uses sequence number comparison
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-foundation/04-RESEARCH.md

# Existing patterns to follow
@packages/cache/src/keys.ts
@packages/cache/src/strategies/candle-cache.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add candleCloseChannel() to keys.ts</name>
  <files>packages/cache/src/keys.ts</files>
  <action>
Add new function to `packages/cache/src/keys.ts` following the existing channel pattern.

Place after `candleChannel()` function (around line 67):

```typescript
/**
 * Build a Redis pub/sub channel name for candle close events
 * Used by exchange adapters to publish and indicator service to subscribe
 * when candles finalize
 */
export function candleCloseChannel(
  userId: number,
  exchangeId: number,
  symbol: string,
  timeframe: Timeframe
): string {
  return `channel:candle:close:${userId}:${exchangeId}:${symbol}:${timeframe}`;
}
```

Note: Use pattern `channel:candle:close:` to distinguish from existing `channel:candle:` pattern.
This is intentional - existing candleChannel is for updates, new candleCloseChannel is for finalized candles.
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/cache/tsconfig.json` - should compile without errors.
Verify function signature matches existing channel functions.
  </verify>
  <done>
- candleCloseChannel() function added to keys.ts
- Function signature matches existing channel functions (userId, exchangeId, symbol, timeframe)
- Returns pattern `channel:candle:close:{userId}:{exchangeId}:{symbol}:{timeframe}`
  </done>
</task>

<task type="auto">
  <name>Task 2: Add addCandleIfNewer() method to CandleCacheStrategy</name>
  <files>packages/cache/src/strategies/candle-cache.ts</files>
  <action>
Add new method to `CandleCacheStrategy` class in `packages/cache/src/strategies/candle-cache.ts`.

**First, update imports** at top of file to include UnifiedCandle:
```typescript
import { CandleSchema, type Candle, type Timeframe, HARDCODED_CONFIG } from '@livermore/schemas';
```
becomes:
```typescript
import { CandleSchema, UnifiedCandleSchema, type Candle, type UnifiedCandle, type Timeframe, HARDCODED_CONFIG } from '@livermore/schemas';
```

**Then add method** after `addCandles()` method (around line 82):

```typescript
/**
 * Add candle only if newer than existing (versioned write)
 * Uses sequence number for ordering when timestamps match.
 * This prevents out-of-order WebSocket messages from overwriting newer data.
 *
 * @returns true if written, false if skipped (older or same sequence number)
 */
async addCandleIfNewer(
  userId: number,
  exchangeId: number,
  candle: UnifiedCandle
): Promise<boolean> {
  // Validate with Zod
  const validated = UnifiedCandleSchema.parse(candle);

  const key = candleKey(userId, exchangeId, validated.symbol, validated.timeframe);

  // Get existing candle at this timestamp
  const existing = await this.redis.zrangebyscore(
    key,
    validated.timestamp,
    validated.timestamp
  );

  if (existing.length > 0) {
    // Candle exists at this timestamp - check if we should update
    const existingCandle = JSON.parse(existing[0]) as UnifiedCandle;

    // If both have sequence numbers, use them for ordering
    if (validated.sequenceNum !== undefined && existingCandle.sequenceNum !== undefined) {
      if (validated.sequenceNum <= existingCandle.sequenceNum) {
        return false; // Skip - older or same data
      }
    } else if (validated.sequenceNum === undefined && existingCandle.sequenceNum !== undefined) {
      // New candle has no sequence, existing does - skip (existing is more authoritative)
      return false;
    }
    // If existing has no sequence but new does, or neither has sequence, allow overwrite
  }

  // Remove existing candle at this timestamp and write new one
  await this.redis.zremrangebyscore(key, validated.timestamp, validated.timestamp);
  await this.redis.zadd(key, validated.timestamp, JSON.stringify(validated));

  // Set expiration (24 hours for candle data)
  const ttlSeconds = HARDCODED_CONFIG.cache.candleTtlHours * 3600;
  await this.redis.expire(key, ttlSeconds);

  // Keep only the most recent candles (limit to 1000)
  await this.redis.zremrangebyrank(key, 0, -1001);

  return true;
}
```

**Key difference from addCandle():**
- Uses `UnifiedCandle` type (has sequenceNum field)
- Returns boolean indicating if write occurred
- Compares sequence numbers when candle exists at same timestamp
- Skips write if existing candle has higher/equal sequence number
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/cache/tsconfig.json` - should compile without errors.
Verify method accepts UnifiedCandle type.
Verify return type is Promise<boolean>.
  </verify>
  <done>
- addCandleIfNewer() method added to CandleCacheStrategy
- Method accepts UnifiedCandle (not plain Candle)
- Returns true if written, false if skipped
- Sequence number comparison implemented correctly
- Follows same cache patterns as addCandle() (TTL, limit to 1000)
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `npx tsc --noEmit -p packages/cache/tsconfig.json` passes
2. `candleCloseChannel` is exported from @livermore/cache
3. `addCandleIfNewer` method exists on CandleCacheStrategy

Manual verification of versioning logic:
- If no existing candle: writes, returns true
- If existing candle with lower sequence: writes, returns true
- If existing candle with equal/higher sequence: skips, returns false
- If existing candle has sequence but new doesn't: skips, returns false
</verification>

<success_criteria>
- [ ] candleCloseChannel() function added to keys.ts
- [ ] Function follows existing naming pattern (channel:candle:close:...)
- [ ] addCandleIfNewer() method added to CandleCacheStrategy
- [ ] Method uses sequence number comparison for versioning
- [ ] Method returns boolean indicating if write occurred
- [ ] TypeScript compilation succeeds for cache package
</success_criteria>

<output>
After completion, create `.planning/phases/04-foundation/04-02-SUMMARY.md`
</output>
