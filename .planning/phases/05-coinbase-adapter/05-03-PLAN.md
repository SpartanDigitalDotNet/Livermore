---
phase: 05-coinbase-adapter
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - packages/coinbase-client/src/adapter/coinbase-adapter.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Watchdog timer fires if no message received in 30 seconds"
    - "Watchdog timer resets on every message (including heartbeats)"
    - "Sequence numbers are tracked per connection"
    - "Gap detection identifies missing messages on reconnection"
    - "REST backfill is triggered when gap > 5 minutes is detected"
  artifacts:
    - path: "packages/coinbase-client/src/adapter/coinbase-adapter.ts"
      provides: "Complete CoinbaseAdapter with reliability features"
      contains: "watchdogTimeout"
      min_lines: 300
  key_links:
    - from: "packages/coinbase-client/src/adapter/coinbase-adapter.ts"
      to: "setTimeout/clearTimeout"
      via: "watchdog timer"
      pattern: "this\\.watchdogTimeout"
    - from: "packages/coinbase-client/src/adapter/coinbase-adapter.ts"
      to: "packages/coinbase-client/src/rest/client.ts"
      via: "REST backfill"
      pattern: "this\\.restClient\\.getCandles"
---

<objective>
Implement connection reliability features: watchdog timer, sequence tracking, and REST backfill on reconnection.

Purpose: Ensure the adapter detects silent disconnections quickly (watchdog), identifies data gaps (sequence tracking), and fills those gaps automatically (REST backfill).

Output: Production-ready CoinbaseAdapter with robust connection management.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan summaries
@.planning/phases/05-coinbase-adapter/05-01-SUMMARY.md
@.planning/phases/05-coinbase-adapter/05-02-SUMMARY.md

# Research - watchdog patterns, backfill, sequence tracking pitfalls
@.planning/phases/05-coinbase-adapter/05-RESEARCH.md

# Existing code
@packages/coinbase-client/src/adapter/coinbase-adapter.ts
@packages/coinbase-client/src/rest/client.ts
@packages/cache/src/strategies/candle-cache.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement watchdog timer</name>
  <files>packages/coinbase-client/src/adapter/coinbase-adapter.ts</files>
  <action>
Add watchdog timer fields:
```typescript
// Add to private fields
private watchdogTimeout: NodeJS.Timeout | null = null;
private readonly WATCHDOG_INTERVAL_MS = 30_000; // 30 seconds
```

Add watchdog methods:
```typescript
/**
 * Reset watchdog timer - call on every message
 * If no message received within WATCHDOG_INTERVAL_MS, force reconnect
 */
private resetWatchdog(): void {
  if (this.watchdogTimeout) {
    clearTimeout(this.watchdogTimeout);
  }

  this.watchdogTimeout = setTimeout(() => {
    logger.warn(
      { exchangeId: this.exchangeId, intervalMs: this.WATCHDOG_INTERVAL_MS },
      'Watchdog timeout - no message received, forcing reconnect'
    );
    this.forceReconnect();
  }, this.WATCHDOG_INTERVAL_MS);
}

/**
 * Stop watchdog timer - call on intentional disconnect
 */
private stopWatchdog(): void {
  if (this.watchdogTimeout) {
    clearTimeout(this.watchdogTimeout);
    this.watchdogTimeout = null;
  }
}

/**
 * Force reconnection due to watchdog timeout or other issue
 */
private forceReconnect(): void {
  logger.info({ exchangeId: this.exchangeId }, 'Forcing reconnect');

  // Close existing connection without triggering normal disconnect
  if (this.ws) {
    this.ws.removeAllListeners();
    this.ws.close();
    this.ws = null;
  }

  // Clear watchdog
  this.stopWatchdog();

  // Trigger reconnect via base class
  this.handleReconnect();
}
```

Update connect() to start watchdog after subscribing to heartbeats:
```typescript
// In the ws.on('open') handler, after subscribeToHeartbeats():
this.resetWatchdog();
```

Update disconnect() to stop watchdog:
```typescript
// At the start of disconnect():
this.stopWatchdog();
```

Update handleMessage() to reset watchdog on EVERY message:
```typescript
// At the very start of handleMessage(), before try block:
this.resetWatchdog();
```
  </action>
  <verify>
```bash
npx tsc --noEmit -p packages/coinbase-client/tsconfig.json
grep "watchdogTimeout" packages/coinbase-client/src/adapter/coinbase-adapter.ts
grep "resetWatchdog" packages/coinbase-client/src/adapter/coinbase-adapter.ts
```
  </verify>
  <done>
Watchdog timer implemented. Resets on every message. Fires forceReconnect() after 30 seconds of silence. Stops on intentional disconnect.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement sequence tracking and gap detection</name>
  <files>packages/coinbase-client/src/adapter/coinbase-adapter.ts</files>
  <action>
Add sequence tracking fields:
```typescript
// Add to private fields
private lastSequenceNum = 0;
private hasDetectedGap = false;
```

Update handleCandlesMessage() to track sequences (add at the start of the method):
```typescript
/**
 * Process incoming candle messages
 * Tracks sequence numbers and detects gaps
 */
private async handleCandlesMessage(message: CandlesMessage): Promise<void> {
  const sequenceNum = message.sequence_num;

  // Check for sequence gap (more than 1 difference indicates missed messages)
  // Note: Sequence numbers reset per connection, so only check after first message
  if (this.lastSequenceNum > 0 && sequenceNum > this.lastSequenceNum + 1) {
    const gap = sequenceNum - this.lastSequenceNum - 1;
    logger.warn(
      { lastSequence: this.lastSequenceNum, newSequence: sequenceNum, gap },
      'Sequence gap detected - messages may have been dropped'
    );
    this.hasDetectedGap = true;
  }

  this.lastSequenceNum = sequenceNum;

  // ... rest of existing implementation
}
```

Add method to reset sequence tracking on reconnection:
```typescript
/**
 * Reset sequence tracking - call after reconnection
 * Sequence numbers are per-connection, so reset to 0
 */
private resetSequenceTracking(): void {
  this.lastSequenceNum = 0;
  this.hasDetectedGap = false;
}
```

Update connect() to reset sequence tracking:
```typescript
// In the ws.on('open') handler, before resetWatchdog():
this.resetSequenceTracking();
```

Add method to check if gap detection triggered backfill need:
```typescript
/**
 * Check if we need to backfill after reconnection
 * Returns true if a sequence gap was detected during the last connection
 */
needsBackfill(): boolean {
  return this.hasDetectedGap;
}
```
  </action>
  <verify>
```bash
npx tsc --noEmit -p packages/coinbase-client/tsconfig.json
grep "lastSequenceNum" packages/coinbase-client/src/adapter/coinbase-adapter.ts
grep "hasDetectedGap" packages/coinbase-client/src/adapter/coinbase-adapter.ts
```
  </verify>
  <done>
Sequence numbers tracked per connection. Gap detection logs warnings when messages are dropped. Tracking resets on reconnection (per Coinbase behavior).
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement REST backfill on reconnection</name>
  <files>packages/coinbase-client/src/adapter/coinbase-adapter.ts</files>
  <action>
Add backfill constants:
```typescript
// Add to class constants
private readonly BACKFILL_THRESHOLD_MS = 5 * 60 * 1000; // 5 minutes
```

Add backfill method:
```typescript
/**
 * Check for data gaps and backfill from REST API if needed
 * Called after reconnection to fill any gaps that occurred during disconnect
 */
private async checkAndBackfill(): Promise<void> {
  if (this.subscribedSymbols.length === 0) {
    logger.debug('No subscribed symbols - skipping backfill check');
    return;
  }

  const now = Date.now();

  for (const symbol of this.subscribedSymbols) {
    try {
      // Get latest cached candle for this symbol
      const latestCached = await this.candleCache.getLatestCandle(
        this.userIdNum,
        this.exchangeIdNum,
        symbol,
        '5m'
      );

      const lastTimestamp = latestCached?.timestamp ?? 0;
      const gapMs = now - lastTimestamp;

      // Only backfill if gap > threshold (5 minutes)
      if (gapMs > this.BACKFILL_THRESHOLD_MS) {
        logger.info(
          { symbol, lastTimestamp: new Date(lastTimestamp).toISOString(), gapMs },
          'Gap detected - backfilling from REST API'
        );

        await this.backfillSymbol(symbol, lastTimestamp, now);
      } else {
        logger.debug(
          { symbol, gapMs },
          'Gap within threshold - no backfill needed'
        );
      }
    } catch (error) {
      logger.error({ error, symbol }, 'Error checking/backfilling symbol');
    }
  }
}

/**
 * Backfill candles for a single symbol from REST API
 */
private async backfillSymbol(symbol: string, fromTimestamp: number, toTimestamp: number): Promise<void> {
  try {
    // Fetch candles from REST API
    const candles = await this.restClient.getCandles(
      symbol,
      '5m',
      fromTimestamp,
      toTimestamp
    );

    logger.info(
      { symbol, fromTimestamp: new Date(fromTimestamp).toISOString(), candleCount: candles.length },
      'Fetched candles from REST API for backfill'
    );

    // Write to cache using versioned writes
    for (const candle of candles) {
      const unified: UnifiedCandle = {
        ...candle,
        exchange: 'coinbase',
        // REST candles don't have sequence numbers
      };

      await this.candleCache.addCandleIfNewer(
        this.userIdNum,
        this.exchangeIdNum,
        unified
      );
    }

    logger.info({ symbol, candleCount: candles.length }, 'Backfill complete');
  } catch (error) {
    logger.error({ error, symbol }, 'REST backfill failed');
  }
}
```

Update connect() to trigger backfill check after successful reconnection.
Add a method to handle post-connection setup:
```typescript
/**
 * Called after successful connection/reconnection
 * Resubscribes to channels and checks for backfill needs
 */
private async onConnected(): Promise<void> {
  // Resubscribe to channels if we had subscriptions
  if (this.subscribedSymbols.length > 0) {
    this.subscribe(this.subscribedSymbols, this.subscribedTimeframe);

    // Check for gaps and backfill if needed
    // Note: Only backfill on REconnection, not initial connection
    if (this.reconnectAttempts > 0 || this.hasDetectedGap) {
      await this.checkAndBackfill();
    }
  }
}
```

Update the ws.on('open') handler in connect():
```typescript
this.ws.on('open', () => {
  logger.info({ exchangeId: this.exchangeId }, 'Connected to Coinbase WebSocket');
  this.resetReconnectAttempts();
  this.resetSequenceTracking();
  this.subscribeToHeartbeats();
  this.resetWatchdog();

  // Handle post-connection setup (resubscribe, backfill)
  this.onConnected().catch(error => {
    logger.error({ error }, 'Error in post-connection setup');
  });

  this.emit('connected');
  resolve();
});
```

Note: The backfill happens asynchronously after connection is established. It doesn't block the connection promise from resolving.
  </action>
  <verify>
```bash
npx tsc --noEmit -p packages/coinbase-client/tsconfig.json
grep "checkAndBackfill" packages/coinbase-client/src/adapter/coinbase-adapter.ts
grep "backfillSymbol" packages/coinbase-client/src/adapter/coinbase-adapter.ts
grep "BACKFILL_THRESHOLD_MS" packages/coinbase-client/src/adapter/coinbase-adapter.ts
```
  </verify>
  <done>
REST backfill implemented. checkAndBackfill() runs after reconnection, checks each symbol for gaps > 5 minutes, fetches from REST API, writes with versioned writes. Errors don't break reconnection flow.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript compilation succeeds:
   ```bash
   npx tsc --noEmit -p packages/coinbase-client/tsconfig.json
   ```

2. Watchdog timer implemented:
   ```bash
   grep -E "(watchdogTimeout|resetWatchdog|stopWatchdog|forceReconnect)" packages/coinbase-client/src/adapter/coinbase-adapter.ts
   ```

3. Sequence tracking implemented:
   ```bash
   grep -E "(lastSequenceNum|hasDetectedGap|resetSequenceTracking)" packages/coinbase-client/src/adapter/coinbase-adapter.ts
   ```

4. Backfill implemented:
   ```bash
   grep -E "(checkAndBackfill|backfillSymbol|BACKFILL_THRESHOLD_MS)" packages/coinbase-client/src/adapter/coinbase-adapter.ts
   ```

5. All pieces integrated:
   ```bash
   # Verify connect() calls all setup methods
   grep -A20 "ws.on('open'" packages/coinbase-client/src/adapter/coinbase-adapter.ts | grep -E "(resetWatchdog|resetSequenceTracking|onConnected)"
   ```
</verification>

<success_criteria>
- [x] Watchdog timer (30s) implemented with setTimeout
- [x] Watchdog resets on every message (including heartbeats)
- [x] Watchdog fires forceReconnect() on timeout
- [x] Watchdog stops on intentional disconnect
- [x] Sequence numbers tracked per connection
- [x] Sequence tracking resets on reconnection (per Coinbase behavior)
- [x] Gap detection logs warning when messages dropped
- [x] checkAndBackfill() runs after reconnection
- [x] Backfill only triggers when gap > 5 minutes
- [x] REST backfill uses existing CoinbaseRestClient.getCandles()
- [x] Backfill uses addCandleIfNewer() for versioned writes
- [x] Errors in backfill don't break main connection flow
- [x] TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/05-coinbase-adapter/05-03-SUMMARY.md`
</output>
