---
phase: 36-binance-websocket-adapter
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/exchange-core/src/adapter/binance-adapter.ts
  - packages/exchange-core/src/adapter/index.ts
  - packages/exchange-core/src/index.ts
autonomous: true
must_haves:
  truths:
    - "BinanceAdapter extends BaseExchangeAdapter and implements IExchangeAdapter"
    - "BinanceAdapter connects to Binance combined WebSocket stream and receives kline messages"
    - "BinanceAdapter normalizes Binance kline data into UnifiedCandle with isClosed detection via the x field"
    - "BinanceAdapter writes closed candles to cache via CandleCacheStrategy and publishes to Redis pub/sub"
    - "BinanceAdapter handles ticker messages, caches via TickerCacheStrategy, and publishes updates"
    - "BinanceAdapter reads wsUrl from constructor options (supporting both binance.com and binance.us without code changes)"
    - "BinanceAdapter manages subscriptions for multiple symbols via combined stream URL or SUBSCRIBE method frames"
    - "BinanceAdapter reconnects automatically with exponential backoff on unexpected disconnect"
    - "BinanceAdapter has a watchdog timer that forces reconnect on silence"
  artifacts:
    - path: "packages/exchange-core/src/adapter/binance-adapter.ts"
      provides: "BinanceAdapter class implementing IExchangeAdapter"
      contains: "export class BinanceAdapter extends BaseExchangeAdapter"
    - path: "packages/exchange-core/src/adapter/index.ts"
      provides: "Barrel export of BinanceAdapter"
      contains: "BinanceAdapter"
  key_links:
    - from: "packages/exchange-core/src/adapter/binance-adapter.ts"
      to: "@livermore/cache"
      via: "CandleCacheStrategy and TickerCacheStrategy for Redis writes"
      pattern: "CandleCacheStrategy|TickerCacheStrategy"
    - from: "packages/exchange-core/src/adapter/binance-adapter.ts"
      to: "@livermore/cache"
      via: "exchangeCandleCloseChannel for pub/sub"
      pattern: "exchangeCandleCloseChannel"
    - from: "packages/exchange-core/src/adapter/binance-adapter.ts"
      to: "packages/exchange-core/src/adapter/base-adapter.ts"
      via: "extends BaseExchangeAdapter for reconnection"
      pattern: "extends BaseExchangeAdapter"
---

<objective>
Create the BinanceAdapter class that implements IExchangeAdapter for real-time candle and ticker streaming via Binance WebSocket. The adapter handles Binance's combined stream message format, kline close detection via the `x` field, symbol subscription management, ping/pong heartbeat, watchdog timer, and automatic reconnection with exponential backoff.

Purpose: Enable Livermore to stream real-time candle and ticker data from Binance exchanges (both binance.com and binance.us) using the same adapter interface as CoinbaseAdapter, so the rest of the pipeline (indicators, alerts, cache) works unchanged.

Output: `BinanceAdapter` class in exchange-core with full WebSocket lifecycle, exported via barrel files.
</objective>

<execution_context>
@C:/Users/Mike McWilliams/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Mike McWilliams/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/exchange-core/src/adapter/base-adapter.ts
@packages/exchange-core/src/adapter/coinbase-adapter.ts
@packages/schemas/src/adapter/exchange-adapter.schema.ts
@packages/cache/src/keys.ts
@packages/cache/src/strategies/candle-cache.ts
@packages/cache/src/strategies/ticker-cache.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BinanceAdapter class with WebSocket streaming</name>
  <files>packages/exchange-core/src/adapter/binance-adapter.ts</files>
  <action>
Create `BinanceAdapter` extending `BaseExchangeAdapter` following the same structural patterns as CoinbaseAdapter but adapted for Binance's WebSocket protocol.

**Constructor options interface (`BinanceAdapterOptions`):**
```typescript
export interface BinanceAdapterOptions {
  /** Binance WebSocket base URL (from exchanges table wsUrl column) */
  wsUrl: string;  // e.g., 'wss://stream.binance.com:9443' or 'wss://stream.binance.us:9443'
  /** Redis client for caching and pub/sub */
  redis: RedisClient;
  /** User ID for cache key scoping */
  userId: number;
  /** Exchange ID (numeric) for cache key scoping */
  exchangeId: number;
  /** Exchange name for logging and UnifiedCandle.exchange field */
  exchangeName: string;  // 'binance' or 'binance_us'
  /** Optional REST client for reconnection backfill */
  restClient?: IRestClient;
}
```

**Key design: wsUrl from options, NOT hardcoded.** The wsUrl comes from the `exchanges` table (injected by factory). binance.com uses `wss://stream.binance.com:9443`, binance.us uses `wss://stream.binance.us:9443`. The adapter code is identical for both -- only the URL differs. This satisfies BIN-02.

**WebSocket connection strategy -- Combined Streams:**
Binance supports combined streams via URL: `wss://stream.binance.com:9443/stream?streams=btcusdt@kline_1m/ethusdt@kline_5m`
However, this requires disconnecting and reconnecting to change subscriptions. Instead, use the **WebSocket API method** approach:
- Connect to `{wsUrl}/ws` (bare endpoint)
- Send JSON frames to subscribe/unsubscribe dynamically:
  ```json
  {"method": "SUBSCRIBE", "params": ["btcusdt@kline_5m", "ethusdt@kline_5m"], "id": 1}
  ```
  ```json
  {"method": "UNSUBSCRIBE", "params": ["btcusdt@kline_5m"], "id": 2}
  ```
- This matches the CoinbaseAdapter pattern where subscribe() sends a message over the existing connection.
- Max 200 streams per connection (well within our needs).

**Message format handling:**
When using the `/ws` endpoint with SUBSCRIBE method, messages arrive in the combined stream wrapper format:
```json
{"stream": "btcusdt@kline_5m", "data": {"e": "kline", "E": 1234567890, "s": "BTCUSDT", "k": {...}}}
```

**Kline data parsing:**
The `k` object contains:
- `t`: kline start time (ms)
- `T`: kline close time (ms)
- `s`: symbol (e.g., "BTCUSDT")
- `i`: interval (e.g., "5m")
- `o`: open price (string)
- `c`: close price (string)
- `h`: high price (string)
- `l`: low price (string)
- `v`: base asset volume (string)
- `x`: is this kline closed? (boolean) -- KEY DIFFERENCE from Coinbase. When `x` is `true`, the candle is finalized.

**Candle close detection:**
Unlike CoinbaseAdapter which compares timestamps to detect close, BinanceAdapter simply checks `k.x === true`. This is much cleaner. When `x` is true, call `onCandleClose()` with the normalized candle.

**normalizeCandle():**
Convert Binance kline to UnifiedCandle:
```typescript
private normalizeCandle(kline: BinanceKline, symbol: string, timeframe: Timeframe): UnifiedCandle {
  return {
    timestamp: kline.t,  // Already in milliseconds
    open: parseFloat(kline.o),
    high: parseFloat(kline.h),
    low: parseFloat(kline.l),
    close: parseFloat(kline.c),
    volume: parseFloat(kline.v),
    symbol,  // Use native Binance symbol (e.g., BTCUSDT)
    timeframe,
    exchange: this.exchangeName,  // 'binance' or 'binance_us'
  };
}
```

Note: `symbol` uses the native Binance format (BTCUSDT, not BTC-USD). The `exchange_symbols` table stores symbols in native format per exchange, so this is correct.

**onCandleClose():**
Follow the same pattern as CoinbaseAdapter:
1. Emit `candle:close` event with UnifiedCandle
2. Publish to Redis exchange-scoped channel: `exchangeCandleCloseChannel(exchangeId, symbol, timeframe)`
3. Publish to Redis user-scoped legacy channel: `candleCloseChannel(userId, exchangeId, symbol, timeframe)`
4. Write to cache via `candleCache.addCandleIfNewer()`

**Ticker handling:**
Binance has a mini-ticker stream: `btcusdt@miniTicker`. Subscribe to this alongside klines.
Mini-ticker format:
```json
{"e": "24hrMiniTicker", "E": eventTime, "s": "BTCUSDT", "c": "close", "o": "open", "h": "high", "l": "low", "v": "volume", "q": "quoteVolume"}
```
Transform to `Ticker` type:
```typescript
const ticker: Ticker = {
  symbol: data.s,
  price: parseFloat(data.c),
  change24h: parseFloat(data.c) - parseFloat(data.o),
  changePercent24h: ((parseFloat(data.c) - parseFloat(data.o)) / parseFloat(data.o)) * 100,
  volume24h: parseFloat(data.v),
  low24h: parseFloat(data.l),
  high24h: parseFloat(data.h),
  timestamp: data.E,
};
```
Cache via `tickerCache.setTicker(exchangeId, ticker)` and publish via `tickerCache.publishUpdate(exchangeId, ticker)`.

**Ping/Pong heartbeat:**
The `ws` library automatically handles WebSocket protocol-level ping/pong frames. Binance sends ping frames; the ws library responds with pong automatically. No manual handling needed.

**Watchdog timer:**
Same pattern as CoinbaseAdapter: 30-second watchdog that forces reconnect if no message received. Reset on every message.

**Reconnection:**
- `isIntentionalClose` flag prevents reconnect on graceful disconnect
- On unexpected close, call `this.handleReconnect()` (inherited from BaseExchangeAdapter)
- On successful reconnection, resubscribe to previously subscribed symbols
- If `restClient` is provided and reconnectAttempts > 0, call `checkAndBackfill()` to fill gaps

**Backfill on reconnect (optional, only if restClient provided):**
Same 2-pass pattern as CoinbaseAdapter:
1. Check each symbol's latest cached candle timestamp
2. If gap > 5 minutes, fetch from REST API with 100ms throttle between calls

**Subscribe method:**
```typescript
subscribe(symbols: string[], timeframe: Timeframe): void {
  // Store subscriptions
  this.subscribedSymbols = symbols;
  this.subscribedTimeframe = timeframe;

  // Build stream names: ["btcusdt@kline_5m", "ethusdt@kline_5m"]
  const klineStreams = symbols.map(s => `${s.toLowerCase()}@kline_${timeframe}`);
  const tickerStreams = symbols.map(s => `${s.toLowerCase()}@miniTicker`);
  const allStreams = [...klineStreams, ...tickerStreams];

  this.requestId++;
  const msg = { method: 'SUBSCRIBE', params: allStreams, id: this.requestId };
  this.ws!.send(JSON.stringify(msg));
}
```

**Unsubscribe method:**
Same pattern but with `UNSUBSCRIBE` method. Update `subscribedSymbols` to remove the symbols.

**connect() method:**
```typescript
async connect(): Promise<void> {
  return new Promise((resolve, reject) => {
    this.isIntentionalClose = false;
    this.ws = new WebSocket(`${this.wsUrl}/ws`);

    this.ws.on('open', () => {
      logger.info({ exchangeId: this.exchangeName }, 'Connected to Binance WebSocket');
      this.resetReconnectAttempts();
      this.resetWatchdog();
      this.onConnected().catch(err => logger.error({ err }, 'Error in post-connection setup'));
      this.emit('connected');
      resolve();
    });

    this.ws.on('message', (data) => this.handleMessage(data));
    this.ws.on('error', (error) => { ... });  // Same pattern as CoinbaseAdapter
    this.ws.on('close', (code, reason) => { ... });  // Same pattern as CoinbaseAdapter
  });
}
```

**handleMessage() routing:**
Parse JSON. The message may be:
1. A combined stream message with `stream` field: route to `handleKlineMessage()` or `handleMiniTickerMessage()` based on stream name
2. A SUBSCRIBE/UNSUBSCRIBE response with `result` and `id` fields: log confirmation
3. An error with `error` field: log error

```typescript
private handleMessage(data: WebSocket.Data): void {
  this.resetWatchdog();
  try {
    const msg = JSON.parse(data.toString());

    // Subscription response
    if ('id' in msg && 'result' in msg) {
      logger.debug({ id: msg.id, result: msg.result }, 'Binance subscription response');
      return;
    }

    // Combined stream message
    if ('stream' in msg && 'data' in msg) {
      const streamName = msg.stream as string;
      if (streamName.includes('@kline_')) {
        this.handleKlineMessage(msg.data);
      } else if (streamName.includes('@miniTicker')) {
        this.handleMiniTickerMessage(msg.data);
      }
      return;
    }

    // Error
    if ('error' in msg) {
      logger.error({ error: msg.error }, 'Binance WebSocket error message');
      return;
    }
  } catch (error) {
    logger.error({ error }, 'Failed to parse Binance WebSocket message');
  }
}
```

**Interfaces to define at top of file:**
```typescript
interface BinanceKlineEvent {
  e: 'kline';
  E: number;  // Event time (ms)
  s: string;  // Symbol
  k: BinanceKline;
}

interface BinanceKline {
  t: number;  // Kline start time (ms)
  T: number;  // Kline close time (ms)
  s: string;  // Symbol
  i: string;  // Interval
  o: string;  // Open price
  c: string;  // Close price
  h: string;  // High price
  l: string;  // Low price
  v: string;  // Base asset volume
  x: boolean; // Is this kline closed?
}

interface BinanceMiniTickerEvent {
  e: '24hrMiniTicker';
  E: number;  // Event time (ms)
  s: string;  // Symbol
  c: string;  // Close price
  o: string;  // Open price
  h: string;  // 24h high
  l: string;  // 24h low
  v: string;  // Total traded base asset volume
  q: string;  // Total traded quote asset volume
}
```

**DO NOT:**
- Hardcode WebSocket URLs (use wsUrl from options)
- Import from @livermore/binance-client (keep exchange-core independent -- REST client comes via IRestClient in options)
- Add sequence tracking (Binance combined streams don't have sequence numbers like Coinbase)
- Build 1m candles from trades (Binance has native 1m kline streams, unlike Coinbase which only has 5m)
- Add aggregation logic (hard constraint: NO aggregation)

**File should be approximately 400-550 lines** following the structural density of CoinbaseAdapter (971 lines) but simpler because:
- No JWT auth for WebSocket (Binance WebSocket is public for market data)
- No sequence tracking needed
- No 1m candle aggregation from trades (native 1m klines available)
- Candle close detection is trivial (`x` field) vs timestamp comparison
  </action>
  <verify>
Run `npx turbo build --filter=@livermore/exchange-core` and confirm it compiles without errors. Verify the file exports `BinanceAdapter` and `BinanceAdapterOptions`.
  </verify>
  <done>
BinanceAdapter class exists in exchange-core, extends BaseExchangeAdapter, implements all IExchangeAdapter methods (connect, disconnect, subscribe, unsubscribe, isConnected), handles Binance kline and miniTicker message formats, writes to cache via CandleCacheStrategy/TickerCacheStrategy, publishes to Redis pub/sub, supports reconnection with watchdog, and accepts wsUrl to support both binance.com and binance.us without code changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Export BinanceAdapter from barrel files</name>
  <files>
packages/exchange-core/src/adapter/index.ts
packages/exchange-core/src/index.ts
  </files>
  <action>
**Update `packages/exchange-core/src/adapter/index.ts`:**
Add export for BinanceAdapter and BinanceAdapterOptions alongside existing CoinbaseAdapter exports:
```typescript
export { BinanceAdapter } from './binance-adapter';
export type { BinanceAdapterOptions } from './binance-adapter';
```

**Verify `packages/exchange-core/src/index.ts`:**
The existing `export * from './adapter';` re-export already covers the new adapter/index.ts exports. No changes needed to the main index.ts.

**Verify:** After these changes, the following import should work from outside the package:
```typescript
import { BinanceAdapter, type BinanceAdapterOptions } from '@livermore/exchange-core';
```
  </action>
  <verify>
Run `npx turbo build --filter=@livermore/exchange-core` to confirm build succeeds. Then run `npx turbo build` for full workspace to confirm no downstream breakage.
  </verify>
  <done>
BinanceAdapter and BinanceAdapterOptions are importable from `@livermore/exchange-core` via barrel exports. Full workspace builds cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx turbo build` passes for the entire workspace
2. `packages/exchange-core/src/adapter/binance-adapter.ts` exists and exports `BinanceAdapter` class
3. `BinanceAdapter` extends `BaseExchangeAdapter` (grep for `extends BaseExchangeAdapter`)
4. BinanceAdapter implements all 5 IExchangeAdapter methods: connect, disconnect, subscribe, unsubscribe, isConnected
5. BinanceAdapter accepts `wsUrl` option (not hardcoded) to support both binance.com and binance.us
6. Kline messages are handled with `x === true` for candle close detection
7. Cache writes use CandleCacheStrategy.addCandleIfNewer and TickerCacheStrategy.setTicker
8. Redis pub/sub uses exchangeCandleCloseChannel for candle close events
9. Watchdog timer and reconnection logic present
</verification>

<success_criteria>
- BinanceAdapter compiles and is exported from @livermore/exchange-core
- All IExchangeAdapter methods implemented
- Binance kline message format correctly parsed into UnifiedCandle
- wsUrl parameterized (not hardcoded) for binance.com / binance.us flexibility
- Cache and pub/sub integration follows identical patterns to CoinbaseAdapter
- Full workspace build passes
</success_criteria>

<output>
After completion, create `.planning/phases/36-binance-websocket-adapter/36-01-SUMMARY.md`
</output>
