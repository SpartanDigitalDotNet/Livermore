---
phase: 17-settings-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - apps/api/src/routers/settings.router.ts
  - apps/api/src/routers/index.ts
autonomous: true

must_haves:
  truths:
    - "Authenticated user can retrieve their settings via tRPC"
    - "Authenticated user can replace entire settings document"
    - "Authenticated user can patch specific settings paths atomically"
  artifacts:
    - path: "apps/api/src/routers/settings.router.ts"
      provides: "tRPC settings endpoints"
      exports: ["settingsRouter"]
      min_lines: 80
    - path: "apps/api/src/routers/index.ts"
      provides: "Router registration"
      contains: "settings: settingsRouter"
  key_links:
    - from: "apps/api/src/routers/settings.router.ts"
      to: "@livermore/schemas"
      via: "Zod import"
      pattern: "import.*UserSettingsSchema.*@livermore/schemas"
    - from: "apps/api/src/routers/settings.router.ts"
      to: "@livermore/database"
      via: "Drizzle query"
      pattern: "from\\(users\\)"
    - from: "apps/api/src/routers/index.ts"
      to: "settings.router.ts"
      via: "router import"
      pattern: "import.*settingsRouter"
---

<objective>
Create tRPC settings router with get, update, and patch endpoints.

Purpose: Provides the core CRUD operations for user settings - get retrieves current settings, update replaces the entire document, and patch uses PostgreSQL jsonb_set() for atomic partial updates.

Output: Working settings.router.ts with three protected endpoints registered in appRouter.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-settings-infrastructure/17-RESEARCH.md
@.planning/phases/17-settings-infrastructure/17-01-SUMMARY.md

# Existing patterns
@apps/api/src/routers/user.router.ts
@apps/api/src/routers/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create settings router with get endpoint</name>
  <files>
    apps/api/src/routers/settings.router.ts
    apps/api/src/routers/index.ts
  </files>
  <action>
1. Create `apps/api/src/routers/settings.router.ts`:

```typescript
import { TRPCError } from '@trpc/server';
import { router, protectedProcedure } from '@livermore/trpc-config';
import { getDbClient, users } from '@livermore/database';
import { UserSettingsSchema, UserSettingsPatchSchema } from '@livermore/schemas';
import { eq, and, sql } from 'drizzle-orm';
```

2. Implement `settings.get` (SET-03):
   - Use protectedProcedure (requires Clerk auth)
   - Get clerkId from `ctx.auth.userId`
   - Query users table by identityProvider='clerk' AND identitySub=clerkId
   - Return settings or default `{ version: 1 }` if null
   - Throw NOT_FOUND if user doesn't exist

3. Register router in `apps/api/src/routers/index.ts`:
   - Import settingsRouter
   - Add to appRouter: `settings: settingsRouter`
   - Add to exports

Follow existing patterns from user.router.ts for:
- protectedProcedure usage
- User lookup by Clerk identity
- Error handling with TRPCError

CRITICAL: Use protectedProcedure, NOT publicProcedure - settings are user-specific and require auth.
  </action>
  <verify>
    - File exists: `test -f apps/api/src/routers/settings.router.ts`
    - Router registered: `grep -q "settings: settingsRouter" apps/api/src/routers/index.ts`
    - Uses protectedProcedure: `grep -q "protectedProcedure" apps/api/src/routers/settings.router.ts`
  </verify>
  <done>
    - settings.router.ts exists with get endpoint using protectedProcedure
    - settingsRouter registered in appRouter
    - Endpoint queries user by Clerk identity and returns settings
  </done>
</task>

<task type="auto">
  <name>Task 2: Add update endpoint (full replace)</name>
  <files>apps/api/src/routers/settings.router.ts</files>
  <action>
Add `settings.update` mutation (SET-04):

1. Use protectedProcedure with input validation:
   `.input(UserSettingsSchema)`

2. Implementation:
   - Get clerkId from ctx.auth.userId
   - Lookup user by Clerk identity (same pattern as get)
   - If user not found, throw NOT_FOUND
   - Update user's settings column with full input object
   - Set updatedAt to new Date().toISOString()
   - Return updated settings via .returning()

3. Important: This is intentional full replacement for scenarios like import or reset. The patch endpoint (Task 3) handles partial updates.

Per research Pitfall 3: Document in code comment that update() replaces entire document - for partial updates, use patch().
  </action>
  <verify>
    - `grep -q "update:.*protectedProcedure" apps/api/src/routers/settings.router.ts`
    - `grep -q "UserSettingsSchema" apps/api/src/routers/settings.router.ts`
  </verify>
  <done>
    - settings.update mutation validates input with UserSettingsSchema
    - Full settings document replacement works
    - updatedAt timestamp updated on save
  </done>
</task>

<task type="auto">
  <name>Task 3: Add patch endpoint (partial update via jsonb_set)</name>
  <files>apps/api/src/routers/settings.router.ts</files>
  <action>
Add `settings.patch` mutation (SET-05):

1. Use protectedProcedure with input validation:
   `.input(UserSettingsPatchSchema)` - expects { path: string[], value: unknown }

2. Implementation per research Pattern 2:
   - Get clerkId from ctx.auth.userId
   - Lookup user to get internal user.id (needed for raw SQL)
   - If user not found, throw NOT_FOUND
   - Build JSON path string: `{${input.path.join(',')}}`
   - Use raw SQL with jsonb_set:
   ```typescript
   await db.execute(sql`
     UPDATE users
     SET settings = jsonb_set(COALESCE(settings, '{}'), ${pathStr}::text[], ${valueJson}::jsonb, true),
         updated_at = NOW()
     WHERE id = ${user.id}
   `);
   ```
   - The `true` parameter creates missing intermediate keys
   - Fetch and return updated settings

3. CRITICAL per research Pitfall 2:
   - Always include user ID in WHERE clause
   - Never use hardcoded user IDs

Example usage:
- path: ['perseus_profile', 'timezone'], value: 'America/New_York'
- path: ['symbols'], value: ['BTC-USD', 'ETH-USD']
  </action>
  <verify>
    - `grep -q "patch:.*protectedProcedure" apps/api/src/routers/settings.router.ts`
    - `grep -q "jsonb_set" apps/api/src/routers/settings.router.ts`
    - TypeScript compiles: `pnpm --filter api build`
  </verify>
  <done>
    - settings.patch mutation uses jsonb_set for atomic partial updates
    - Path array converted to PostgreSQL path format
    - Missing intermediate keys created automatically
    - No race conditions (atomic DB operation)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# 1. TypeScript compilation
pnpm --filter api build

# 2. Router file exists with all endpoints
grep -E "(get:|update:|patch:)" apps/api/src/routers/settings.router.ts

# 3. Router registered
grep "settings: settingsRouter" apps/api/src/routers/index.ts

# 4. Uses protectedProcedure (not publicProcedure)
grep -c "protectedProcedure" apps/api/src/routers/settings.router.ts
# Should return 3 (one for each endpoint)

# 5. Uses jsonb_set for patch
grep "jsonb_set" apps/api/src/routers/settings.router.ts
```
</verification>

<success_criteria>
- [ ] settings.get returns user settings or default `{ version: 1 }`
- [ ] settings.update replaces entire settings document with validation
- [ ] settings.patch uses PostgreSQL jsonb_set for atomic partial updates
- [ ] All endpoints use protectedProcedure (require Clerk auth)
- [ ] All endpoints lookup user by Clerk identity (identityProvider + identitySub)
- [ ] settingsRouter registered in appRouter
- [ ] TypeScript compiles without errors
- [ ] Requirements SET-03, SET-04, SET-05 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/17-settings-infrastructure/17-02-SUMMARY.md`
</output>
