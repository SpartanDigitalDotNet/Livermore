---
phase: 14-user-sync-webhooks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/schemas/src/env/config.schema.ts
  - packages/database/src/schema/users.ts
  - apps/api/src/routes/webhooks/clerk.ts
  - apps/api/src/server.ts
autonomous: true

user_setup:
  - service: clerk-webhooks
    why: "Webhook signature verification requires signing secret from Clerk dashboard"
    env_vars:
      - name: CLERK_WEBHOOK_SIGNING_SECRET
        source: "Clerk Dashboard -> Webhooks -> Add Endpoint -> Signing Secret (after creating endpoint)"
    dashboard_config:
      - task: "Create webhook endpoint"
        location: "Clerk Dashboard -> Webhooks -> Add Endpoint"
        details: "Set endpoint URL to https://your-domain/webhooks/clerk, subscribe to user.created and user.updated events"

must_haves:
  truths:
    - "New Clerk user triggers webhook, creates row in users table"
    - "Updated Clerk user triggers webhook, updates users row"
    - "Webhook rejects requests with invalid svix signature (400)"
    - "Duplicate webhooks for same user are idempotent"
  artifacts:
    - path: "packages/schemas/src/env/config.schema.ts"
      provides: "CLERK_WEBHOOK_SIGNING_SECRET validation"
      contains: "CLERK_WEBHOOK_SIGNING_SECRET"
    - path: "packages/database/src/schema/users.ts"
      provides: "Users table with IAM columns"
      contains: "identityProvider"
    - path: "apps/api/src/routes/webhooks/clerk.ts"
      provides: "Clerk webhook handler with signature verification"
      exports: ["clerkWebhookHandler"]
    - path: "apps/api/src/server.ts"
      provides: "Webhook route registered before clerkPlugin"
      contains: "/webhooks/clerk"
  key_links:
    - from: "apps/api/src/routes/webhooks/clerk.ts"
      to: "@clerk/fastify/webhooks"
      via: "verifyWebhook import"
      pattern: "verifyWebhook"
    - from: "apps/api/src/routes/webhooks/clerk.ts"
      to: "@livermore/database"
      via: "getDbClient + users table"
      pattern: "getDbClient.*users"
    - from: "apps/api/src/server.ts"
      to: "apps/api/src/routes/webhooks/clerk.ts"
      via: "route registration before clerkPlugin"
      pattern: "fastify\\.post.*webhooks/clerk.*clerkPlugin"
---

<objective>
Implement Clerk webhook endpoint that syncs user.created and user.updated events to the PostgreSQL users table with OAuth identity fields.

Purpose: Clerk users automatically sync to database when created/updated, enabling database queries by Clerk user ID and supporting future authorization logic.

Output: Working `/webhooks/clerk` endpoint with signature verification and idempotent user upsert.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-user-sync-webhooks/14-RESEARCH.md

# Prior phase context (Clerk integration pattern)
@.planning/phases/13-clerk-authentication/13-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add webhook env var and update users schema</name>
  <files>
    packages/schemas/src/env/config.schema.ts
    packages/database/src/schema/users.ts
  </files>
  <action>
1. Add CLERK_WEBHOOK_SIGNING_SECRET to EnvConfigSchema:
   ```typescript
   CLERK_WEBHOOK_SIGNING_SECRET: z.string().min(1, 'Clerk webhook signing secret is required'),
   ```

2. Update packages/database/src/schema/users.ts to include IAM columns that exist in the database (from Phase 12) but are missing from source schema:
   ```typescript
   import { pgTable, serial, varchar, timestamp, boolean, text, uniqueIndex } from 'drizzle-orm/pg-core';
   import { sql } from 'drizzle-orm';

   export const users = pgTable('users', {
     id: serial('id').primaryKey(),
     username: varchar('username', { length: 50 }).notNull().unique(),
     email: varchar('email', { length: 255 }).notNull().unique(),
     isActive: boolean('is_active').default(true).notNull(),
     createdAt: timestamp('created_at', { mode: 'string' }).defaultNow().notNull(),
     updatedAt: timestamp('updated_at', { mode: 'string' }).defaultNow().notNull(),
     // IAM columns (added in Phase 12)
     identityProvider: varchar('identity_provider', { length: 20 }),
     identitySub: varchar('identity_sub', { length: 255 }),
     displayName: varchar('display_name', { length: 100 }),
     identityPictureUrl: text('identity_picture_url'),
     role: varchar('role', { length: 20 }).default('user').notNull(),
     lastLoginAt: timestamp('last_login_at', { mode: 'string' }),
   }, (table) => ({
     // Partial unique index for OAuth identity lookup (allows NULL identity_provider)
     identityProviderSubIdx: uniqueIndex('users_identity_provider_sub_idx')
       .on(table.identityProvider, table.identitySub)
       .where(sql`identity_provider IS NOT NULL`),
   }));

   export type User = typeof users.$inferSelect;
   export type NewUser = typeof users.$inferInsert;
   ```

The source schema must match the database structure (already deployed in Phase 12).
  </action>
  <verify>
    - `pnpm exec tsc --noEmit -p packages/schemas` passes
    - `pnpm exec tsc --noEmit -p packages/database` passes
    - users.ts exports identityProvider, identitySub, displayName, identityPictureUrl, role, lastLoginAt columns
  </verify>
  <done>
    - EnvConfigSchema validates CLERK_WEBHOOK_SIGNING_SECRET
    - users.ts source schema matches drizzle-generated schema with all IAM columns
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create webhook handler and register route</name>
  <files>
    apps/api/src/routes/webhooks/clerk.ts
    apps/api/src/server.ts
  </files>
  <action>
1. Create apps/api/src/routes/webhooks/clerk.ts:
   ```typescript
   import { verifyWebhook, type WebhookEvent } from '@clerk/fastify/webhooks';
   import type { FastifyRequest, FastifyReply } from 'fastify';
   import { getDbClient, users } from '@livermore/database';
   import { logger } from '@livermore/utils';
   import { eq, and } from 'drizzle-orm';

   // Clerk User data structure from webhook payload
   interface ClerkUserData {
     id: string;
     first_name: string | null;
     last_name: string | null;
     email_addresses: Array<{
       id: string;
       email_address: string;
     }>;
     primary_email_address_id: string | null;
     image_url: string | null;
     last_sign_in_at: number | null;  // Milliseconds since epoch
   }

   /**
    * Extract primary email from Clerk user data
    */
   function getPrimaryEmail(userData: ClerkUserData): string {
     if (!userData.primary_email_address_id || !userData.email_addresses.length) {
       throw new Error('User has no primary email address');
     }

     const primary = userData.email_addresses.find(
       (e) => e.id === userData.primary_email_address_id
     );

     if (!primary) {
       // Fallback to first email
       return userData.email_addresses[0].email_address;
     }

     return primary.email_address;
   }

   /**
    * Generate username from email
    * Format: email prefix + random suffix for uniqueness
    */
   function generateUsername(email: string): string {
     const prefix = email.split('@')[0].slice(0, 30);
     const suffix = Math.random().toString(36).substring(2, 7);
     return `${prefix}_${suffix}`;
   }

   /**
    * Sync Clerk user to PostgreSQL users table
    * Uses check-then-update pattern for idempotency
    */
   async function syncUser(userData: ClerkUserData): Promise<void> {
     const db = getDbClient();
     const email = getPrimaryEmail(userData);
     const displayName = [userData.first_name, userData.last_name]
       .filter(Boolean)
       .join(' ') || null;

     // Check if user exists by Clerk ID
     const existing = await db
       .select({ id: users.id, username: users.username })
       .from(users)
       .where(
         and(
           eq(users.identityProvider, 'clerk'),
           eq(users.identitySub, userData.id)
         )
       )
       .limit(1);

     if (existing.length > 0) {
       // UPDATE existing user
       await db
         .update(users)
         .set({
           email,
           displayName,
           identityPictureUrl: userData.image_url,
           lastLoginAt: userData.last_sign_in_at
             ? new Date(userData.last_sign_in_at).toISOString()
             : null,
           updatedAt: new Date().toISOString(),
         })
         .where(eq(users.id, existing[0].id));

       logger.info({ clerkId: userData.id, userId: existing[0].id }, 'Updated user from Clerk webhook');
     } else {
       // INSERT new user
       await db.insert(users).values({
         email,
         username: generateUsername(email),
         identityProvider: 'clerk',
         identitySub: userData.id,
         displayName,
         identityPictureUrl: userData.image_url,
         role: 'user',
         lastLoginAt: userData.last_sign_in_at
           ? new Date(userData.last_sign_in_at).toISOString()
           : null,
       });

       logger.info({ clerkId: userData.id, email }, 'Created user from Clerk webhook');
     }
   }

   /**
    * Clerk webhook handler
    * Processes user.created and user.updated events
    */
   export async function clerkWebhookHandler(
     request: FastifyRequest,
     reply: FastifyReply
   ): Promise<void> {
     try {
       // verifyWebhook validates svix signature using CLERK_WEBHOOK_SIGNING_SECRET
       const evt = await verifyWebhook(request) as WebhookEvent;

       logger.debug({ eventType: evt.type }, 'Received Clerk webhook');

       switch (evt.type) {
         case 'user.created':
         case 'user.updated':
           await syncUser(evt.data as ClerkUserData);
           break;
         default:
           logger.debug({ eventType: evt.type }, 'Ignoring unhandled webhook event type');
       }

       reply.code(200).send({ received: true });
     } catch (err) {
       logger.error({ error: (err as Error).message }, 'Clerk webhook error');
       reply.code(400).send({ error: 'Webhook verification failed' });
     }
   }
   ```

2. Modify apps/api/src/server.ts to register webhook route BEFORE clerkPlugin:

   a. Add import at top (after dotenv/config):
      ```typescript
      import { clerkWebhookHandler } from './routes/webhooks/clerk';
      ```

   b. Register webhook route BEFORE clerkPlugin registration (around line 164-166):
      ```typescript
      // WEBHOOK ROUTE - must be registered BEFORE clerkPlugin
      // This route does NOT require JWT authentication (server-to-server)
      fastify.post('/webhooks/clerk', clerkWebhookHandler);

      // Register Clerk authentication plugin (must be before tRPC so getAuth works in context)
      await fastify.register(clerkPlugin);
      ```

   CRITICAL: The webhook route MUST appear BEFORE `await fastify.register(clerkPlugin)`.
   Routes registered after clerkPlugin will fail with 401 because Clerk validates JWT on all routes.
  </action>
  <verify>
    - `pnpm exec tsc --noEmit -p apps/api` passes
    - apps/api/src/routes/webhooks/clerk.ts exports clerkWebhookHandler
    - In server.ts, `fastify.post('/webhooks/clerk'...)` appears BEFORE `fastify.register(clerkPlugin)`
    - Pattern check: `grep -n "webhooks/clerk\|clerkPlugin" apps/api/src/server.ts` shows webhook line number < clerkPlugin line number
  </verify>
  <done>
    - clerkWebhookHandler created with verifyWebhook() signature validation
    - syncUser() handles both user.created and user.updated via check-then-upsert pattern
    - Webhook route registered before clerkPlugin (bypasses JWT auth)
    - TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation:
   ```bash
   pnpm exec tsc --noEmit -p packages/schemas
   pnpm exec tsc --noEmit -p packages/database
   pnpm exec tsc --noEmit -p apps/api
   ```

2. Route registration order check:
   ```bash
   grep -n "webhooks/clerk\|clerkPlugin" apps/api/src/server.ts
   ```
   Webhook route line number MUST be less than clerkPlugin line number.

3. Schema verification:
   - users.ts has identityProvider, identitySub, displayName, identityPictureUrl, role, lastLoginAt columns
   - EnvConfigSchema has CLERK_WEBHOOK_SIGNING_SECRET field

4. File structure verification:
   - apps/api/src/routes/webhooks/clerk.ts exists
   - Exports clerkWebhookHandler function
</verification>

<success_criteria>
- [ ] CLERK_WEBHOOK_SIGNING_SECRET added to EnvConfigSchema
- [ ] users.ts source schema matches database schema (includes all IAM columns)
- [ ] clerkWebhookHandler validates svix signature via verifyWebhook()
- [ ] syncUser() creates user on first webhook, updates on subsequent webhooks
- [ ] Webhook route registered BEFORE clerkPlugin (route does not require JWT)
- [ ] All TypeScript packages compile without errors

**Requirements Covered:**
- AUTH-04: Clerk webhook endpoint `/webhooks/clerk` syncs users on `user.created`
- AUTH-05: Clerk webhook syncs user data on `user.updated` events
</success_criteria>

<output>
After completion, create `.planning/phases/14-user-sync-webhooks/14-01-SUMMARY.md`
</output>
